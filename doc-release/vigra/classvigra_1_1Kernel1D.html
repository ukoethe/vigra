<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Kernel1D&lt; ARITHTYPE &gt; Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Kernel1D&lt; ARITHTYPE &gt; Class Template Reference
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>


<p>Generic 1 dimensional convolution kernel.  
 <a href="classvigra_1_1Kernel1D.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="separableconvolution_8hxx_source.html">vigra/separableconvolution.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6c53fe234330a9d1604e0948fa47174b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a><br class="typebreak"/>
&lt; ARITHTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a></td></tr>
<tr class="separator:a6c53fe234330a9d1604e0948fa47174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a64d70f2934a8cb54eb8d81f059773"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
InternalVector::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab5a64d70f2934a8cb54eb8d81f059773">const_iterator</a></td></tr>
<tr class="separator:ab5a64d70f2934a8cb54eb8d81f059773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c87d7921339cc42075571aaf0c6534"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
InternalVector::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab6c87d7921339cc42075571aaf0c6534">const_reference</a></td></tr>
<tr class="separator:ab6c87d7921339cc42075571aaf0c6534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78445962f8673a1e2c1393dab7c7ad8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a><br class="typebreak"/>
&lt; ARITHTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a></td></tr>
<tr class="separator:aa78445962f8673a1e2c1393dab7c7ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef84b9c9d4f014effcfecbca87629d2"><td class="memItemLeft" align="right" valign="top">typedef InternalVector::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#adef84b9c9d4f014effcfecbca87629d2">Iterator</a></td></tr>
<tr class="separator:adef84b9c9d4f014effcfecbca87629d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0b17e9965a56ba56cb5fedc7119a92"><td class="memItemLeft" align="right" valign="top">typedef InternalVector::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a></td></tr>
<tr class="separator:a8c0b17e9965a56ba56cb5fedc7119a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130b31490ce7ba9051094274b190940d"><td class="memItemLeft" align="right" valign="top">typedef InternalVector::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a></td></tr>
<tr class="separator:a130b31490ce7ba9051094274b190940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821b18fa86c2bc45ccf17716429d438b"><td class="memItemLeft" align="right" valign="top">typedef InternalVector::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a></td></tr>
<tr class="separator:a821b18fa86c2bc45ccf17716429d438b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a40e8567a7e13dacc22cadde2f9d1dcd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a40e8567a7e13dacc22cadde2f9d1dcd0">accessor</a> () const </td></tr>
<tr class="separator:a40e8567a7e13dacc22cadde2f9d1dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e543db9ce291e86b9023cdb9202b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac1e543db9ce291e86b9023cdb9202b5b">accessor</a> ()</td></tr>
<tr class="separator:ac1e543db9ce291e86b9023cdb9202b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dbff83a4127cc415a7eb796d95051e"><td class="memItemLeft" align="right" valign="top">BorderTreatmentMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a> () const </td></tr>
<tr class="separator:a69dbff83a4127cc415a7eb796d95051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa906590f3f139cdfeb292a15add8e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a> ()</td></tr>
<tr class="separator:afa906590f3f139cdfeb292a15add8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fe279fbc6c3e2ce60ec778109b9923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab7fe279fbc6c3e2ce60ec778109b9923">initAveraging</a> (int radius, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr class="separator:ab7fe279fbc6c3e2ce60ec778109b9923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c19fd629e175e9b97af74733b2bbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a97c19fd629e175e9b97af74733b2bbd4">initAveraging</a> (int radius)</td></tr>
<tr class="separator:a97c19fd629e175e9b97af74733b2bbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192eec53d760d825b0eedab01a6a2ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a192eec53d760d825b0eedab01a6a2ed2">initBackwardDifference</a> ()</td></tr>
<tr class="separator:a192eec53d760d825b0eedab01a6a2ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac919a292dea182575c698495de0430b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac919a292dea182575c698495de0430b2">initBinomial</a> (int radius, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr class="separator:ac919a292dea182575c698495de0430b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c5f04a39f4a11736e787f7d27f6666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a01c5f04a39f4a11736e787f7d27f6666">initBinomial</a> (int radius)</td></tr>
<tr class="separator:a01c5f04a39f4a11736e787f7d27f6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406a301a1cc659b3098bbcc0a827228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a1406a301a1cc659b3098bbcc0a827228">initBurtFilter</a> (double a=0.04785)</td></tr>
<tr class="separator:a1406a301a1cc659b3098bbcc0a827228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80922d43665cec4f4378e8378997feb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a80922d43665cec4f4378e8378997feb0">initDiscreteGaussian</a> (double std_dev, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr class="separator:a80922d43665cec4f4378e8378997feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15901db2903a004e09e86ae5fbd66ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a15901db2903a004e09e86ae5fbd66ca2">initDiscreteGaussian</a> (double std_dev)</td></tr>
<tr class="separator:a15901db2903a004e09e86ae5fbd66ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1164e5b808619971ebc0e9783f972dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a> (int <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>, int <a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>)</td></tr>
<tr class="separator:a1164e5b808619971ebc0e9783f972dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8d30d2b69f8f6771d6804d15df5072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#acf8d30d2b69f8f6771d6804d15df5072">initForwardDifference</a> ()</td></tr>
<tr class="separator:acf8d30d2b69f8f6771d6804d15df5072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c46ac7770600ec38f55c1dc498244a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a48c46ac7770600ec38f55c1dc498244a">initGaussian</a> (double std_dev, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>, double windowRatio=0.0)</td></tr>
<tr class="separator:a48c46ac7770600ec38f55c1dc498244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba907ac90270c3dd8aac14af93f7b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#abba907ac90270c3dd8aac14af93f7b58">initGaussian</a> (double std_dev)</td></tr>
<tr class="separator:abba907ac90270c3dd8aac14af93f7b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825b69c78f7b71bc33dea8d461849161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a825b69c78f7b71bc33dea8d461849161">initGaussianDerivative</a> (double std_dev, int order, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>, double windowRatio=0.0)</td></tr>
<tr class="separator:a825b69c78f7b71bc33dea8d461849161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eec7322d05865b857efb1449888d918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a7eec7322d05865b857efb1449888d918">initGaussianDerivative</a> (double std_dev, int order)</td></tr>
<tr class="separator:a7eec7322d05865b857efb1449888d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeff31c2ffd35f352631fbe27d1dcdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5</a> ()</td></tr>
<tr class="separator:a1eeff31c2ffd35f352631fbe27d1dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5677b3c7ffdc1586c4e9e4a5394daac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#af5677b3c7ffdc1586c4e9e4a5394daac">initOptimalFirstDerivativeSmoothing3</a> ()</td></tr>
<tr class="separator:af5677b3c7ffdc1586c4e9e4a5394daac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068e7beed066f292a4ba8e777897526f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5</a> ()</td></tr>
<tr class="separator:a068e7beed066f292a4ba8e777897526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50c7edfcedf325996e21eb74a69a4d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5</a> ()</td></tr>
<tr class="separator:ab50c7edfcedf325996e21eb74a69a4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe353a930022de958b75e9e6311189e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a0fe353a930022de958b75e9e6311189e">initOptimalSecondDerivativeSmoothing3</a> ()</td></tr>
<tr class="separator:a0fe353a930022de958b75e9e6311189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe3a4b86ffdaf0e8e85d5ab7e75ed71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#abbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5</a> ()</td></tr>
<tr class="separator:abbe3a4b86ffdaf0e8e85d5ab7e75ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4902fcc6fe66ab6646cbe1fdc5e7121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#af4902fcc6fe66ab6646cbe1fdc5e7121">initOptimalSmoothing3</a> ()</td></tr>
<tr class="separator:af4902fcc6fe66ab6646cbe1fdc5e7121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b3593dd18b43b1d5f81532617d8010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a75b3593dd18b43b1d5f81532617d8010">initOptimalSmoothing5</a> ()</td></tr>
<tr class="separator:a75b3593dd18b43b1d5f81532617d8010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072b8efc06e0bd9c6f1fd395becebf17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3</a> ()</td></tr>
<tr class="separator:a072b8efc06e0bd9c6f1fd395becebf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feea4952f1c61fc8643bbcd23afe103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference</a> ()</td></tr>
<tr class="separator:a8feea4952f1c61fc8643bbcd23afe103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c9a9ebb3b89ac2c8aff5e985923d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab9c9a9ebb3b89ac2c8aff5e985923d18">initSymmetricGradient</a> (<a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr class="separator:ab9c9a9ebb3b89ac2c8aff5e985923d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d0fbcbdb93cbbdfa5d497d5afb5b13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a50d0fbcbdb93cbbdfa5d497d5afb5b13">initSymmetricGradient</a> ()</td></tr>
<tr class="separator:a50d0fbcbdb93cbbdfa5d497d5afb5b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc39b4e951c1da5c7d14e79774842b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac4bc39b4e951c1da5c7d14e79774842b">Kernel1D</a> ()</td></tr>
<tr class="separator:ac4bc39b4e951c1da5c7d14e79774842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb70f6879284a8f74ae53ab656094e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#aafb70f6879284a8f74ae53ab656094e6">Kernel1D</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> const &amp;k)</td></tr>
<tr class="separator:aafb70f6879284a8f74ae53ab656094e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4302a66e41af59782c71e1103e6ded00"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a4302a66e41af59782c71e1103e6ded00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a4302a66e41af59782c71e1103e6ded00">Kernel1D</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; U &gt; const &amp;k)</td></tr>
<tr class="separator:a4302a66e41af59782c71e1103e6ded00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265321ef4c7ad76f60e512fc09eef7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a> () const </td></tr>
<tr class="separator:a265321ef4c7ad76f60e512fc09eef7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac41cd63a48de00144dbd94e4c38ead6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a> () const </td></tr>
<tr class="separator:aac41cd63a48de00144dbd94e4c38ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f10c82d42dacf3b4c9b691fb0840e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a7f10c82d42dacf3b4c9b691fb0840e35">normalize</a> (<a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>, unsigned int derivativeOrder=0, double offset=0.0)</td></tr>
<tr class="separator:a7f10c82d42dacf3b4c9b691fb0840e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0de676568888d848beb97dcc53ae47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#acd0de676568888d848beb97dcc53ae47">normalize</a> ()</td></tr>
<tr class="separator:acd0de676568888d848beb97dcc53ae47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d661136561636b764e9689d41db9349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a4d661136561636b764e9689d41db9349">operator=</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> const &amp;k)</td></tr>
<tr class="separator:a4d661136561636b764e9689d41db9349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd821bdc684b1cdad02afe53dd043dc"><td class="memItemLeft" align="right" valign="top">InitProxy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a4fd821bdc684b1cdad02afe53dd043dc">operator=</a> (<a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> const &amp;v)</td></tr>
<tr class="separator:a4fd821bdc684b1cdad02afe53dd043dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bf8c098fec92f08714fdf0c72a66ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a42bf8c098fec92f08714fdf0c72a66ff">operator[]</a> (int location)</td></tr>
<tr class="separator:a42bf8c098fec92f08714fdf0c72a66ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04ec796f4e7db479575644d114974ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a> () const </td></tr>
<tr class="separator:ad04ec796f4e7db479575644d114974ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647df9e68cc4da54a5c9d2ba13768c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a647df9e68cc4da54a5c9d2ba13768c9a">setBorderTreatment</a> (BorderTreatmentMode new_mode)</td></tr>
<tr class="separator:a647df9e68cc4da54a5c9d2ba13768c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e4e3e2a7bf18888b71bdf9dda0770b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">size</a> () const </td></tr>
<tr class="separator:ab8e4e3e2a7bf18888b71bdf9dda0770b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dce5d31376d099a6f6a940dd1b1fa28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a8dce5d31376d099a6f6a940dd1b1fa28">~Kernel1D</a> ()</td></tr>
<tr class="separator:a8dce5d31376d099a6f6a940dd1b1fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ARITHTYPE&gt;<br/>
class vigra::Kernel1D&lt; ARITHTYPE &gt;</h3>

<p>Generic 1 dimensional convolution kernel. </p>
<p>This kernel may be used for convolution of 1 dimensional signals or for separable convolution of multidimensional signals.</p>
<p>Convolution functions access the kernel via a 1 dimensional random access iterator which they get by calling <a class="el" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center()</a>. This iterator points to the center of the kernel. The kernel's size is given by its <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left()</a> (&lt;=0) and <a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right()</a> (&gt;= 0) methods. The desired border treatment mode is returned by <a class="el" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment()</a>.</p>
<p>The different init functions create a kernel with the specified properties. The kernel's value_type must be a linear space, i.e. it must define multiplication with doubles and NumericTraits.</p>
<p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="separableconvolution_8hxx_source.html">vigra/separableconvolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// define Gaussian kernel with std. deviation 3.0</span></div>
<div class="line">Kernel1D kernel;</div>
<div class="line">kernel.initGaussian(3.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// apply 1D kernel along the x-axis</span></div>
<div class="line"><a class="code" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848" title="Performs a 1 dimensional convolution in x direction.">separableConvolveX</a>(src, dest, kernel);</div>
</div><!-- fragment --><p><a href="#" id="Kernel1D_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;Kernel1D_OldUsage&apos;, &apos;Kernel1D_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="Kernel1D_OldUsage" style="display:none"> The kernel defines a factory function kernel1d() to create an argument object (see <a class="el" href="KernelArgumentObjectFactories.html">Kernel Argument Object Factories</a>). </p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// define Gaussian kernel with std. deviation 3.0</span></div>
<div class="line">vigra::Kernel1D kernel;</div>
<div class="line">kernel.initGaussian(3.0);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848" title="Performs a 1 dimensional convolution in x direction.">vigra::separableConvolveX</a>(srcImageRange(src), destImage(dest), kernel1d(kernel));</div>
</div><!-- fragment --><p> <b> Required Interface:</b> </p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> v = vigra::NumericTraits&lt;value_type&gt;::one(); <span class="comment">// if norm is not</span></div>
<div class="line">                                                        <span class="comment">// given explicitly</span></div>
<div class="line"><span class="keywordtype">double</span> d;</div>
<div class="line"></div>
<div class="line">v = d * v;</div>
</div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="pyramid_8cxx-example.html#_a0">pyramid.cxx</a>, and <a class="el" href="smooth_convolve_8cxx-example.html#_a3">smooth_convolve.cxx</a>.</dd>
</dl></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a821b18fa86c2bc45ccf17716429d438b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::value_type <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the kernel's value type </p>

</div>
</div>
<a class="anchor" id="a130b31490ce7ba9051094274b190940d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::reference <a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the kernel's reference type </p>

</div>
</div>
<a class="anchor" id="ab6c87d7921339cc42075571aaf0c6534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::const_reference <a class="el" href="classvigra_1_1Kernel1D.html#ab6c87d7921339cc42075571aaf0c6534">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the kernel's const reference type </p>

</div>
</div>
<a class="anchor" id="adef84b9c9d4f014effcfecbca87629d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::iterator <a class="el" href="classvigra_1_1Kernel1D.html#adef84b9c9d4f014effcfecbca87629d2">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deprecated &ndash; use <a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">Kernel1D::iterator</a> </p>

</div>
</div>
<a class="anchor" id="a8c0b17e9965a56ba56cb5fedc7119a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::iterator <a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1D random access iterator over the kernel's values </p>

</div>
</div>
<a class="anchor" id="ab5a64d70f2934a8cb54eb8d81f059773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::const_iterator <a class="el" href="classvigra_1_1Kernel1D.html#ab5a64d70f2934a8cb54eb8d81f059773">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>const 1D random access iterator over the kernel's values </p>

</div>
</div>
<a class="anchor" id="a6c53fe234330a9d1604e0948fa47174b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a>&lt;ARITHTYPE&gt; <a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the kernel's accessor </p>

</div>
</div>
<a class="anchor" id="aa78445962f8673a1e2c1393dab7c7ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a>&lt;ARITHTYPE&gt; <a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the kernel's const accessor </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac4bc39b4e951c1da5c7d14e79774842b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Creates a kernel of size 1 which would copy the signal unchanged. </p>

</div>
</div>
<a class="anchor" id="aafb70f6879284a8f74ae53ab656094e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; ARITHTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a4302a66e41af59782c71e1103e6ded00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from kernel with different element type, e.g. double =&gt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>. </p>

</div>
</div>
<a class="anchor" id="a8dce5d31376d099a6f6a940dd1b1fa28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4d661136561636b764e9689d41db9349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; ARITHTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment. </p>

</div>
</div>
<a class="anchor" id="a4fd821bdc684b1cdad02afe53dd043dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InitProxy operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization. This initializes the kernel with the given constant. The norm becomes v*size().</p>
<p>Instead of a single value an initializer list of length <a class="el" href="classvigra_1_1Kernel1D.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">size()</a> can be used like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> roberts_gradient_x;</div>
<div class="line"></div>
<div class="line">roberts_gradient_x.<a class="code" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(0, 1) = 1.0, -1.0;</div>
</div><!-- fragment --><p>In this case, the norm will be set to the sum of the init values. An initializer list of wrong length will result in a run-time error. </p>

</div>
</div>
<a class="anchor" id="a48c46ac7770600ec38f55c1dc498244a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>windowRatio</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a sampled <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function. The radius of the kernel is always 3*std_dev. '<code>norm</code>' denotes the sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> to a finite interval). However, if <code>norm</code> is 0.0, the kernel is normalized to 1 by the analytic expression for the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>, and <b>no</b> correction for the windowing error is performed. If <code>windowRatio = 0.0</code>, the radius of the filter window is <code>radius = round(3.0 * std_dev)</code>, otherwise it is <code>radius = round(windowRatio * std_dev)</code> (where <code>windowRatio &gt; 0.0</code> is required).</p>
<p>Precondition: </p>
<div class="fragment"><div class="line">std_dev &gt;= 0.0</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5)</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5)</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abba907ac90270c3dd8aac14af93f7b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function with norm 1. </p>

</div>
</div>
<a class="anchor" id="a80922d43665cec4f4378e8378997feb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initDiscreteGaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as Lindeberg's discrete analog of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function. The radius of the kernel is always 3*std_dev. 'norm' denotes the sum of all bins of the kernel.</p>
<p>Precondition: </p>
<div class="fragment"><div class="line">std_dev &gt;= 0.0</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5)</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5)</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a15901db2903a004e09e86ae5fbd66ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initDiscreteGaussian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a Lindeberg's discrete analog of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function with norm 1. </p>

</div>
</div>
<a class="anchor" id="a825b69c78f7b71bc33dea8d461849161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussianDerivative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>windowRatio</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative of order '<code>order</code>'. The radius of the kernel is always <code>3*std_dev + 0.5*order</code>. '<code>norm</code>' denotes the norm of the kernel so that the following condition is fulfilled:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=left()}^{right()} \frac{(-i)^{order}kernel[i]}{order!} = norm \]" src="form_83.png"/>
</p>
<p>Thus, the kernel will be corrected for the error introduced by windowing the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> to a finite interval. However, if <code>norm</code> is 0.0, the kernel is normalized to 1 by the analytic expression for the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative, and <b>no</b> correction for the windowing error is performed. If <code>windowRatio = 0.0</code>, the radius of the filter window is <code>radius = round(3.0 * std_dev + 0.5 * order)</code>, otherwise it is <code>radius = round(windowRatio * std_dev)</code> (where <code>windowRatio &gt; 0.0</code> is required).</p>
<p>Preconditions: </p>
<div class="fragment"><div class="line">1. std_dev &gt;= 0.0</div>
<div class="line">2. order   &gt;= 1</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5*order + 0.5)</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5*order + 0.5)</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7eec7322d05865b857efb1449888d918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussianDerivative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative with norm 1. </p>

</div>
</div>
<a class="anchor" id="af4902fcc6fe66ab6646cbe1fdc5e7121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSmoothing3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 3-tap smoothing filter. The filter values are</p>
<div class="fragment"><div class="line">[0.216, 0.568, 0.216]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 3x3 filter obtained by separable application of this filter is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.680.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af5677b3c7ffdc1586c4e9e4a5394daac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalFirstDerivativeSmoothing3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 3-tap smoothing filter to be used in the context of first derivative computation. This filter must be used in conjunction with the symmetric difference filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a>), such that the difference filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><div class="line">[0.224365, 0.55127, 0.224365]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 3x3 filter obtained by combining this filter with the symmetric difference is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.675.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0fe353a930022de958b75e9e6311189e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSecondDerivativeSmoothing3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 3-tap smoothing filter to be used in the context of second derivative computation. This filter must be used in conjunction with the 3-tap second difference filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3()</a>), such that the difference filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><div class="line">[0.13, 0.74, 0.13]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 3x3 filter obtained by combining this filter with the 3-tap second difference is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.433.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a75b3593dd18b43b1d5f81532617d8010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSmoothing5 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 5-tap smoothing filter. The filter values are</p>
<div class="fragment"><div class="line">[0.03134, 0.24, 0.45732, 0.24, 0.03134]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 5x5 filter obtained by separable application of this filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.867.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a068e7beed066f292a4ba8e777897526f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalFirstDerivativeSmoothing5 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 5-tap smoothing filter to be used in the context of first derivative computation. This filter must be used in conjunction with the optimal 5-tap first derivative filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><div class="line">[0.04255, 0.241, 0.4329, 0.241, 0.04255]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the optimal 5-tap first derivative is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.906.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abbe3a4b86ffdaf0e8e85d5ab7e75ed71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSecondDerivativeSmoothing5 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 5-tap smoothing filter to be used in the context of second derivative computation. This filter must be used in conjunction with the optimal 5-tap second derivative filter (see <a class="el" href="classvigra_1_1Kernel1D.html#ab50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><div class="line">[0.0243, 0.23556, 0.48028, 0.23556, 0.0243]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the optimal 5-tap second derivative is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.817.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1406a301a1cc659b3098bbcc0a827228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBurtFilter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0.04785</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init a 5-tap filter as defined by Peter Burt in the context of pyramid creation. The filter values are</p>
<div class="fragment"><div class="line">[a, 0.25, 0.5-2*a, 0.25, a]</div>
</div><!-- fragment --><p>The default <code>a = 0.04785</code> is optimal in the sense that it minimizes the difference to a true <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter (which would have sigma = 0.975). For other values of <code>a</code>, the scale of the most similar <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> can be approximated by</p>
<div class="fragment"><div class="line">sigma = 5.1 * a + 0.731</div>
</div><!-- fragment --><p>Preconditions: </p>
<div class="fragment"><div class="line">0 &lt;= a &lt;= 0.125</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac919a292dea182575c698495de0430b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBinomial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a Binomial filter. 'norm' denotes the sum of all bins of the kernel.</p>
<p>Precondition: </p>
<div class="fragment"><div class="line">radius   &gt;= 0</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -radius</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  radius</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a01c5f04a39f4a11736e787f7d27f6666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBinomial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a Binomial filter with norm 1. </p>

</div>
</div>
<a class="anchor" id="ab7fe279fbc6c3e2ce60ec778109b9923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initAveraging </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as an Averaging filter. 'norm' denotes the sum of all bins of the kernel. The window size is (2*radius+1) * (2*radius+1)</p>
<p>Precondition: </p>
<div class="fragment"><div class="line">radius   &gt;= 0</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -radius</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  radius</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_CLIP</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a97c19fd629e175e9b97af74733b2bbd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initAveraging </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as an Averaging filter with norm 1. </p>

</div>
</div>
<a class="anchor" id="ab9c9a9ebb3b89ac2c8aff5e985923d18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a symmetric gradient filter of the form <code>[ 0.5 * norm, 0.0 * norm, -0.5 * norm]</code></p>
<p><b>Deprecated</b>. Use <a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a> instead.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REPEAT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a50d0fbcbdb93cbbdfa5d497d5afb5b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as a symmetric gradient filter with norm 1.</p>
<p><b>Deprecated</b>. Use <a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a> instead. </p>

</div>
</div>
<a class="anchor" id="acf8d30d2b69f8f6771d6804d15df5072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initForwardDifference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as the 2-tap forward difference filter. The filter values are</p>
<div class="fragment"><div class="line">[1.0, -1.0]</div>
</div><!-- fragment --><p>(note that filters are reflected by the convolution algorithm, and we get a forward difference after reflection).</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  0</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a192eec53d760d825b0eedab01a6a2ed2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBackwardDifference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as the 2-tap backward difference filter. The filter values are</p>
<div class="fragment"><div class="line">[1.0, -1.0]</div>
</div><!-- fragment --><p>(note that filters are reflected by the convolution algorithm, and we get a forward difference after reflection).</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == 0</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8feea4952f1c61fc8643bbcd23afe103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricDifference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init as the 3-tap symmetric difference filter The filter values are</p>
<div class="fragment"><div class="line">[0.5, 0, -0.5]</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a072b8efc06e0bd9c6f1fd395becebf17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSecondDifference3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init the 3-tap second difference filter. The filter values are</p>
<div class="fragment"><div class="line">[1, -2, 1]</div>
</div><!-- fragment --><p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1eeff31c2ffd35f352631fbe27d1dcdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalFirstDerivative5 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 5-tap first derivative filter. This filter must be used in conjunction with the corresponding 5-tap smoothing filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><div class="line">[0.1, 0.3, 0.0, -0.3, -0.1]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the corresponding 5-tap smoothing filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.906.</p>
<p>If the filter is instead separably combined with itself, an almost optimal approximation of the mixed second <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative at scale sigma = 0.899 results.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab50c7edfcedf325996e21eb74a69a4d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSecondDerivative5 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init an optimal 5-tap second derivative filter. This filter must be used in conjunction with the corresponding 5-tap smoothing filter (see <a class="el" href="classvigra_1_1Kernel1D.html#abbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><div class="line">[0.22075, 0.117, -0.6755, 0.117, 0.22075]</div>
</div><!-- fragment --><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the corresponding 5-tap smoothing filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.817.</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2</div>
<div class="line">3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT</div>
<div class="line">4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1164e5b808619971ebc0e9783f972dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&amp; initExplicitly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init the kernel by an explicit initializer list. The left and right boundaries of the kernel must be passed. A comma-separated initializer list is given after the assignment operator. This function is used like this:</p>
<div class="fragment"><div class="line"><span class="comment">// define horizontal Roberts filter</span></div>
<div class="line"><a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> roberts_gradient_x;</div>
<div class="line"></div>
<div class="line">roberts_gradient_x.<a class="code" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(0, 1) = 1.0, -1.0;</div>
</div><!-- fragment --><p>The norm is set to the sum of the initializer values. If the wrong number of values is given, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant:</p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> average5x1;</div>
<div class="line"></div>
<div class="line">average5x1.<a class="code" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(-2, 2) = 1.0/5.0;</div>
</div><!-- fragment --><p>Here, the norm is set to value*size().</p>
<p><b> Preconditions:</b></p>
<div class="fragment"><div class="line">1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a> &lt;= 0</div>
<div class="line">2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a> &gt;= 0</div>
<div class="line">3. the number of values in the initializer list</div>
<div class="line">   is 1 or equals the size of the kernel.</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afa906590f3f139cdfeb292a15add8e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a> center </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get iterator to center of kernel</p>
<p>Postconditions: </p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a>()[<a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()] ... <a class="code" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a>()[<a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>()] are valid kernel positions</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a42bf8c098fec92f08714fdf0c72a66ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access kernel value at specified location.</p>
<p>Preconditions: </p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>() &lt;= location &lt;= <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>()</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a265321ef4c7ad76f60e512fc09eef7c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>left border of kernel (inclusive), always &lt;= 0 </p>

</div>
</div>
<a class="anchor" id="ad04ec796f4e7db479575644d114974ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>right border of kernel (inclusive), always &gt;= 0 </p>

</div>
</div>
<a class="anchor" id="ab8e4e3e2a7bf18888b71bdf9dda0770b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>size of kernel (<a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right()</a> - <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left()</a> + 1) </p>

</div>
</div>
<a class="anchor" id="a69dbff83a4127cc415a7eb796d95051e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BorderTreatmentMode borderTreatment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current border treatment mode </p>

</div>
</div>
<a class="anchor" id="a647df9e68cc4da54a5c9d2ba13768c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBorderTreatment </td>
          <td>(</td>
          <td class="paramtype">BorderTreatmentMode&#160;</td>
          <td class="paramname"><em>new_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set border treatment mode. </p>

</div>
</div>
<a class="anchor" id="aac41cd63a48de00144dbd94e4c38ead6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>norm of kernel </p>

</div>
</div>
<a class="anchor" id="a7f10c82d42dacf3b4c9b691fb0840e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>derivativeOrder</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set a new norm and normalize kernel, use the normalization formula for the given <code>derivativeOrder</code>. </p>

</div>
</div>
<a class="anchor" id="acd0de676568888d848beb97dcc53ae47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normalize kernel to norm 1. </p>

</div>
</div>
<a class="anchor" id="a40e8567a7e13dacc22cadde2f9d1dcd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a> accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get a const accessor </p>

</div>
</div>
<a class="anchor" id="ac1e543db9ce291e86b9023cdb9202b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a> accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get an accessor </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vigra/<a class="el" href="separableconvolution_8hxx_source.html">separableconvolution.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Mon Nov 18 2013)
</i>
</tr>
</table>
</BODY>
</HTML>
