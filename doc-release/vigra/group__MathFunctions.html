<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Mathematical Functions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Mathematical Functions
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSpline.html">BSpline&lt; ORDER, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSplineBase.html">BSplineBase&lt; ORDER, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CatmullRomSpline.html">CatmullRomSpline&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoscotFunction.html">CoscotFunction&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Gaussian.html">Gaussian&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8686fee88c6f46f3e19a76f00826dc10"><td class="memTemplParams" colspan="2">template&lt;class IndexIterator , class InIterator , class OutIterator &gt; </td></tr>
<tr class="memitem:ga8686fee88c6f46f3e19a76f00826dc10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10">applyPermutation</a> (IndexIterator index_first, IndexIterator index_last, InIterator in, OutIterator out)</td></tr>
<tr class="memdesc:ga8686fee88c6f46f3e19a76f00826dc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array according to the given index permutation.  <a href="#ga8686fee88c6f46f3e19a76f00826dc10">More...</a><br/></td></tr>
<tr class="separator:ga8686fee88c6f46f3e19a76f00826dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf658d43400902a049a289c4e5ded84d9"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:gaf658d43400902a049a289c4e5ded84d9"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf658d43400902a049a289c4e5ded84d9">argMax</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:gaf658d43400902a049a289c4e5ded84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum element in a sequence.  <a href="#gaf658d43400902a049a289c4e5ded84d9">More...</a><br/></td></tr>
<tr class="separator:gaf658d43400902a049a289c4e5ded84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class UnaryFunctor &gt; </td></tr>
<tr class="memitem:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gafe67abfb62abdfc09a8e1e47a87485ea">argMaxIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>
<tr class="memdesc:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum element in a sequence conforming to a condition.  <a href="#gafe67abfb62abdfc09a8e1e47a87485ea">More...</a><br/></td></tr>
<tr class="separator:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad84c74edbd392ac2035df2a6d583fc05"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:gad84c74edbd392ac2035df2a6d583fc05"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad84c74edbd392ac2035df2a6d583fc05">argMin</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:gad84c74edbd392ac2035df2a6d583fc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum element in a sequence.  <a href="#gad84c74edbd392ac2035df2a6d583fc05">More...</a><br/></td></tr>
<tr class="separator:gad84c74edbd392ac2035df2a6d583fc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d791e8c9cac48509aa4e1557ecf676"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class UnaryFunctor &gt; </td></tr>
<tr class="memitem:ga45d791e8c9cac48509aa4e1557ecf676"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga45d791e8c9cac48509aa4e1557ecf676">argMinIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>
<tr class="memdesc:ga45d791e8c9cac48509aa4e1557ecf676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum element in a sequence conforming to a condition.  <a href="#ga45d791e8c9cac48509aa4e1557ecf676">More...</a><br/></td></tr>
<tr class="separator:ga45d791e8c9cac48509aa4e1557ecf676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf8d64d518f2d493bee81d886906cdf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga9cf8d64d518f2d493bee81d886906cdf">besselJ</a> (int n, double x)</td></tr>
<tr class="memdesc:ga9cf8d64d518f2d493bee81d886906cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of the first kind.  <a href="#ga9cf8d64d518f2d493bee81d886906cdf">More...</a><br/></td></tr>
<tr class="separator:ga9cf8d64d518f2d493bee81d886906cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d85515af4527b6922f14a853fe40d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga84d85515af4527b6922f14a853fe40d3">besselY</a> (int n, double x)</td></tr>
<tr class="memdesc:ga84d85515af4527b6922f14a853fe40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of the second kind.  <a href="#ga84d85515af4527b6922f14a853fe40d3">More...</a><br/></td></tr>
<tr class="separator:ga84d85515af4527b6922f14a853fe40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54aeb0113ef25c8a4f2e72a1acc794c5"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2</a> (UInt32 x)</td></tr>
<tr class="memdesc:ga54aeb0113ef25c8a4f2e72a1acc794c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to the nearest power of 2.  <a href="#ga54aeb0113ef25c8a4f2e72a1acc794c5">More...</a><br/></td></tr>
<tr class="separator:ga54aeb0113ef25c8a4f2e72a1acc794c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga482d2e82f374a8758cd516d19f4c3424"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga482d2e82f374a8758cd516d19f4c3424">checksum</a> (const char *data, unsigned int size)</td></tr>
<tr class="memdesc:ga482d2e82f374a8758cd516d19f4c3424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CRC-32 checksum of a byte array.  <a href="#ga482d2e82f374a8758cd516d19f4c3424">More...</a><br/></td></tr>
<tr class="separator:ga482d2e82f374a8758cd516d19f4c3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6a2804ceaf785495472fb9bf2dd5bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0f6a2804ceaf785495472fb9bf2dd5bc">chi2</a> (unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:ga0f6a2804ceaf785495472fb9bf2dd5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chi square distribution.  <a href="#ga0f6a2804ceaf785495472fb9bf2dd5bc">More...</a><br/></td></tr>
<tr class="separator:ga0f6a2804ceaf785495472fb9bf2dd5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94c7af27b4aecda8a764beb89dbc2a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaa94c7af27b4aecda8a764beb89dbc2a6">chi2CDF</a> (unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:gaa94c7af27b4aecda8a764beb89dbc2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative chi square distribution.  <a href="#gaa94c7af27b4aecda8a764beb89dbc2a6">More...</a><br/></td></tr>
<tr class="separator:gaa94c7af27b4aecda8a764beb89dbc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10235727f77f6dfa6af756ce20eec2f7"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga10235727f77f6dfa6af756ce20eec2f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7">closeAtTolerance</a> (T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)</td></tr>
<tr class="memdesc:ga10235727f77f6dfa6af756ce20eec2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance based floating-point comparison.  <a href="#ga10235727f77f6dfa6af756ce20eec2f7">More...</a><br/></td></tr>
<tr class="separator:ga10235727f77f6dfa6af756ce20eec2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46be68464b972df67e1396fd3a398de7"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga46be68464b972df67e1396fd3a398de7">concatenateChecksum</a> (UInt32 checksum, const char *data, unsigned int size)</td></tr>
<tr class="separator:ga46be68464b972df67e1396fd3a398de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba489a131e75016f32095b106659d22"><td class="memTemplParams" colspan="2">template&lt;class PointArray1 , class PointArray2 &gt; </td></tr>
<tr class="memitem:ga8ba489a131e75016f32095b106659d22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8ba489a131e75016f32095b106659d22">convexHull</a> (const PointArray1 &amp;points, PointArray2 &amp;convex_hull)</td></tr>
<tr class="memdesc:ga8ba489a131e75016f32095b106659d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull of a 2D polygon.  <a href="#ga8ba489a131e75016f32095b106659d22">More...</a><br/></td></tr>
<tr class="separator:ga8ba489a131e75016f32095b106659d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7ce9a27a70c7341a29c4637cddf26f8c">cos_pi</a> (REAL x)</td></tr>
<tr class="memdesc:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cos(pi*x).  <a href="#ga7ce9a27a70c7341a29c4637cddf26f8c">More...</a><br/></td></tr>
<tr class="separator:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d6193bd95ec54c5f25dd0470f58215"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga29d6193bd95ec54c5f25dd0470f58215">ellipticIntegralE</a> (double x, double k)</td></tr>
<tr class="memdesc:ga29d6193bd95ec54c5f25dd0470f58215"><td class="mdescLeft">&#160;</td><td class="mdescRight">The incomplete elliptic integral of the second kind.  <a href="#ga29d6193bd95ec54c5f25dd0470f58215">More...</a><br/></td></tr>
<tr class="separator:ga29d6193bd95ec54c5f25dd0470f58215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e909bd1d07e846d5d3ba78eaed7c520"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7e909bd1d07e846d5d3ba78eaed7c520">ellipticIntegralF</a> (double x, double k)</td></tr>
<tr class="memdesc:ga7e909bd1d07e846d5d3ba78eaed7c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">The incomplete elliptic integral of the first kind.  <a href="#ga7e909bd1d07e846d5d3ba78eaed7c520">More...</a><br/></td></tr>
<tr class="separator:ga7e909bd1d07e846d5d3ba78eaed7c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf86b8d2300cd08b69024eb89f90115"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115">even</a> (int t)</td></tr>
<tr class="memdesc:ga3cf86b8d2300cd08b69024eb89f90115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an integer is even.  <a href="#ga3cf86b8d2300cd08b69024eb89f90115">More...</a><br/></td></tr>
<tr class="separator:ga3cf86b8d2300cd08b69024eb89f90115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c914923c1c096cef574906d6169329"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329">floorPower2</a> (UInt32 x)</td></tr>
<tr class="memdesc:ga73c914923c1c096cef574906d6169329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round down to the nearest power of 2.  <a href="#ga73c914923c1c096cef574906d6169329">More...</a><br/></td></tr>
<tr class="separator:ga73c914923c1c096cef574906d6169329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441c9e4bf9f952c0fe94836634bcf976"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976">gamma</a> (double x)</td></tr>
<tr class="memdesc:ga441c9e4bf9f952c0fe94836634bcf976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gamma function.  <a href="#ga441c9e4bf9f952c0fe94836634bcf976">More...</a><br/></td></tr>
<tr class="separator:ga441c9e4bf9f952c0fe94836634bcf976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5825d3973169fc0c90404849a5906697"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga5825d3973169fc0c90404849a5906697"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga5825d3973169fc0c90404849a5906697">gcd</a> (IntType n, IntType m)</td></tr>
<tr class="separator:ga5825d3973169fc0c90404849a5906697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643a6681534ba7611545eecca201666a"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class IndexIterator , class Compare &gt; </td></tr>
<tr class="memitem:ga643a6681534ba7611545eecca201666a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort</a> (Iterator first, Iterator last, IndexIterator index_first, Compare c)</td></tr>
<tr class="memdesc:ga643a6681534ba7611545eecca201666a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index permutation that would sort the input array.  <a href="#ga643a6681534ba7611545eecca201666a">More...</a><br/></td></tr>
<tr class="separator:ga643a6681534ba7611545eecca201666a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26349c51c03a24f22baab0138374c77"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaf26349c51c03a24f22baab0138374c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77">inspectSequence</a> (...)</td></tr>
<tr class="memdesc:gaf26349c51c03a24f22baab0138374c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an analyzing functor at every element of a sequence.  <a href="#gaf26349c51c03a24f22baab0138374c77">More...</a><br/></td></tr>
<tr class="separator:gaf26349c51c03a24f22baab0138374c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c0801ae0f386bade8dbc77fa485301"><td class="memTemplParams" colspan="2">template&lt;class InIterator , class OutIterator &gt; </td></tr>
<tr class="memitem:ga89c0801ae0f386bade8dbc77fa485301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga89c0801ae0f386bade8dbc77fa485301">inversePermutation</a> (InIterator first, InIterator last, OutIterator out)</td></tr>
<tr class="memdesc:ga89c0801ae0f386bade8dbc77fa485301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a given permutation.  <a href="#ga89c0801ae0f386bade8dbc77fa485301">More...</a><br/></td></tr>
<tr class="separator:ga89c0801ae0f386bade8dbc77fa485301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa613671eda401daa90a686497c27da"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga1aa613671eda401daa90a686497c27da"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga1aa613671eda401daa90a686497c27da">lcm</a> (IntType n, IntType m)</td></tr>
<tr class="separator:ga1aa613671eda401daa90a686497c27da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53853aa76befa82637051ecbadc9a10b"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga53853aa76befa82637051ecbadc9a10b"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b">legendre</a> (unsigned int l, int m, REAL x)</td></tr>
<tr class="memdesc:ga53853aa76befa82637051ecbadc9a10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated Legendre polynomial.  <a href="#ga53853aa76befa82637051ecbadc9a10b">More...</a><br/></td></tr>
<tr class="separator:ga53853aa76befa82637051ecbadc9a10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0197e622433399bc9792bb1a884c0b8d"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga0197e622433399bc9792bb1a884c0b8d"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0197e622433399bc9792bb1a884c0b8d">legendre</a> (unsigned int l, REAL x)</td></tr>
<tr class="memdesc:ga0197e622433399bc9792bb1a884c0b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre polynomial.  <a href="#ga0197e622433399bc9792bb1a884c0b8d">More...</a><br/></td></tr>
<tr class="separator:ga0197e622433399bc9792bb1a884c0b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ed6110df5e4258d0a4541bcf85c762"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Value &gt; </td></tr>
<tr class="memitem:gad4ed6110df5e4258d0a4541bcf85c762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad4ed6110df5e4258d0a4541bcf85c762">linearSequence</a> (Iterator first, Iterator last, Value start, Value step)</td></tr>
<tr class="memdesc:gad4ed6110df5e4258d0a4541bcf85c762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with a sequence of numbers.  <a href="#gad4ed6110df5e4258d0a4541bcf85c762">More...</a><br/></td></tr>
<tr class="separator:gad4ed6110df5e4258d0a4541bcf85c762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0271fdd97b849704cded72b31cce3c83"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83">log2i</a> (UInt32 x)</td></tr>
<tr class="memdesc:ga0271fdd97b849704cded72b31cce3c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-2 logarithm of an integer.  <a href="#ga0271fdd97b849704cded72b31cce3c83">More...</a><br/></td></tr>
<tr class="separator:ga0271fdd97b849704cded72b31cce3c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5038616b325ecfd12b4ef51318aa26"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26">loggamma</a> (double x)</td></tr>
<tr class="memdesc:gafc5038616b325ecfd12b4ef51318aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the gamma function.  <a href="#gafc5038616b325ecfd12b4ef51318aa26">More...</a><br/></td></tr>
<tr class="separator:gafc5038616b325ecfd12b4ef51318aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074ace0a87d00243c85a52e5071a1ad4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga074ace0a87d00243c85a52e5071a1ad4">noncentralChi2</a> (unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:ga074ace0a87d00243c85a52e5071a1ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-central chi square distribution.  <a href="#ga074ace0a87d00243c85a52e5071a1ad4">More...</a><br/></td></tr>
<tr class="separator:ga074ace0a87d00243c85a52e5071a1ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e01fc59c3d8455e8ccbbd8824230226"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226">noncentralChi2CDF</a> (unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:ga4e01fc59c3d8455e8ccbbd8824230226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative non-central chi square distribution.  <a href="#ga4e01fc59c3d8455e8ccbbd8824230226">More...</a><br/></td></tr>
<tr class="separator:ga4e01fc59c3d8455e8ccbbd8824230226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddeff01bf2aa44ad74399a1888a6bbfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb">noncentralChi2CDFApprox</a> (unsigned int degreesOfFreedom, double noncentrality, double arg)</td></tr>
<tr class="memdesc:gaddeff01bf2aa44ad74399a1888a6bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative non-central chi square distribution (approximate).  <a href="#gaddeff01bf2aa44ad74399a1888a6bbfb">More...</a><br/></td></tr>
<tr class="separator:gaddeff01bf2aa44ad74399a1888a6bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="memTemplItemLeft" align="right" valign="top">NormTraits&lt; T &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga794eb2a920016363c5e9653b6b2b6eb2">norm</a> (T const &amp;t)</td></tr>
<tr class="memdesc:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The norm of a numerical object.  <a href="#ga794eb2a920016363c5e9653b6b2b6eb2">More...</a><br/></td></tr>
<tr class="separator:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f661149941ebaa90ddd99ee5eee145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145">odd</a> (int t)</td></tr>
<tr class="memdesc:ga48f661149941ebaa90ddd99ee5eee145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an integer is odd.  <a href="#ga48f661149941ebaa90ddd99ee5eee145">More...</a><br/></td></tr>
<tr class="separator:ga48f661149941ebaa90ddd99ee5eee145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd375194b3220beebe0a22e67d7a4e8"><td class="memItemLeft" align="right" valign="top">result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaebd375194b3220beebe0a22e67d7a4e8">operator()</a> (argument_type x) const </td></tr>
<tr class="separator:gaebd375194b3220beebe0a22e67d7a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203e71c46fd7f38f8139eed3072f6c78"><td class="memTemplParams" colspan="2">template&lt;unsigned n, class V &gt; </td></tr>
<tr class="memitem:ga203e71c46fd7f38f8139eed3072f6c78"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga203e71c46fd7f38f8139eed3072f6c78">power</a> (const V &amp;x)</td></tr>
<tr class="memdesc:ga203e71c46fd7f38f8139eed3072f6c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation to a positive integer power by squaring.  <a href="#ga203e71c46fd7f38f8139eed3072f6c78">More...</a><br/></td></tr>
<tr class="separator:ga203e71c46fd7f38f8139eed3072f6c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd73560e02ff2f241ebfdf38daf1740"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga3fd73560e02ff2f241ebfdf38daf1740">round</a> (REAL v)</td></tr>
<tr class="memdesc:ga3fd73560e02ff2f241ebfdf38daf1740"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rounding function.  <a href="#ga3fd73560e02ff2f241ebfdf38daf1740">More...</a><br/></td></tr>
<tr class="separator:ga3fd73560e02ff2f241ebfdf38daf1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97048e053a17edc953036936e59ce88e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga97048e053a17edc953036936e59ce88e">roundi</a> (double t)</td></tr>
<tr class="memdesc:ga97048e053a17edc953036936e59ce88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round and cast to integer.  <a href="#ga97048e053a17edc953036936e59ce88e">More...</a><br/></td></tr>
<tr class="separator:ga97048e053a17edc953036936e59ce88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99756ca23b738bdc82afba3b0e49df74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga99756ca23b738bdc82afba3b0e49df74"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74">sign</a> (T t)</td></tr>
<tr class="memdesc:ga99756ca23b738bdc82afba3b0e49df74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sign function.  <a href="#ga99756ca23b738bdc82afba3b0e49df74">More...</a><br/></td></tr>
<tr class="separator:ga99756ca23b738bdc82afba3b0e49df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97607c505b78dde9e45ce4f11ad20ea"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:gab97607c505b78dde9e45ce4f11ad20ea"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gab97607c505b78dde9e45ce4f11ad20ea">sign</a> (T1 t1, T2 t2)</td></tr>
<tr class="memdesc:gab97607c505b78dde9e45ce4f11ad20ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary sign function.  <a href="#gab97607c505b78dde9e45ce4f11ad20ea">More...</a><br/></td></tr>
<tr class="separator:gab97607c505b78dde9e45ce4f11ad20ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2d6f0e128653deb42a47a8f379b4b9a0">signi</a> (T t)</td></tr>
<tr class="memdesc:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer sign function.  <a href="#ga2d6f0e128653deb42a47a8f379b4b9a0">More...</a><br/></td></tr>
<tr class="separator:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0">sin_pi</a> (REAL x)</td></tr>
<tr class="memdesc:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sin(pi*x).  <a href="#ga8fe78db7b7769819568aeafbfbc2ffd0">More...</a><br/></td></tr>
<tr class="separator:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; T &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a> (T t)</td></tr>
<tr class="memdesc:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square function.  <a href="#ga5fe62e7b0dc6f379dd436c9c8338c93e">More...</a><br/></td></tr>
<tr class="separator:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540e54c778be63996a0f61f7117c2903"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903">sqrti</a> (Int32 v)</td></tr>
<tr class="memdesc:ga540e54c778be63996a0f61f7117c2903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer square root.  <a href="#ga540e54c778be63996a0f61f7117c2903">More...</a><br/></td></tr>
<tr class="separator:ga540e54c778be63996a0f61f7117c2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38870065d4c6e12602b9154c7e69df1f"><td class="memItemLeft" align="right" valign="top">NormTraits&lt; T &gt;::SquaredNormType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga38870065d4c6e12602b9154c7e69df1f">squaredNorm</a> (T const &amp;t)</td></tr>
<tr class="memdesc:ga38870065d4c6e12602b9154c7e69df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared norm of a numerical object.  <a href="#ga38870065d4c6e12602b9154c7e69df1f">More...</a><br/></td></tr>
<tr class="separator:ga38870065d4c6e12602b9154c7e69df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9210561d31f03b4fa1656bafc7182c0b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9210561d31f03b4fa1656bafc7182c0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga9210561d31f03b4fa1656bafc7182c0b">symmetric2x2Eigenvalues</a> (T a00, T a01, T a11, T *r0, T *r1)</td></tr>
<tr class="memdesc:ga9210561d31f03b4fa1656bafc7182c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues of a 2x2 real symmetric matrix.  <a href="#ga9210561d31f03b4fa1656bafc7182c0b">More...</a><br/></td></tr>
<tr class="separator:ga9210561d31f03b4fa1656bafc7182c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2c49eca66b2ba5c308d04fa324dcc230">symmetric3x3Eigenvalues</a> (T a00, T a01, T a02, T a11, T a12, T a22, T *r0, T *r1, T *r2)</td></tr>
<tr class="memdesc:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues of a 3x3 real symmetric matrix.  <a href="#ga2c49eca66b2ba5c308d04fa324dcc230">More...</a><br/></td></tr>
<tr class="separator:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>Useful mathematical functions and functors. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad84c74edbd392ac2035df2a6d583fc05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMin </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum element in a sequence. </p>
<p>The function returns the iterator referring to the minimum element. This is identical to the function <code>std::min_element()</code>.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool f = *first &lt; NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::max();</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaf658d43400902a049a289c4e5ded84d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMax </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the maximum element in a sequence. </p>
<p>The function returns the iterator referring to the maximum element. This is identical to the function <code>std::max_element()</code>.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool f = NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::min() &lt; *first;</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga45d791e8c9cac48509aa4e1557ecf676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMinIf </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum element in a sequence conforming to a condition. </p>
<p>The function returns the iterator referring to the minimum element, where only elements conforming to the condition (i.e. where <code>condition(*iterator)</code> evaluates to <code>true</code>) are considered. If no element conforms to the condition, or the sequence is empty, the end iterator <em>last</em> is returned.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool c = condition(*first);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> f = *first &lt; NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::max();</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gafe67abfb62abdfc09a8e1e47a87485ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMaxIf </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the maximum element in a sequence conforming to a condition. </p>
<p>The function returns the iterator referring to the maximum element, where only elements conforming to the condition (i.e. where <code>condition(*iterator)</code> evaluates to <code>true</code>) are considered. If no element conforms to the condition, or the sequence is empty, the end iterator <em>last</em> is returned.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool c = condition(*first);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> f = NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::min() &lt; *first;</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gad4ed6110df5e4258d0a4541bcf85c762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::linearSequence </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with a sequence of numbers. </p>
<p>The sequence starts at <em>start</em> and is incremented with <em>step</em>. Default start and stepsize are 0 and 1 respectively.</p>
<p><b> Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Value&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#gad4ed6110df5e4258d0a4541bcf85c762" title="Fill an array with a sequence of numbers.">linearSequence</a>(Iterator first, Iterator last, </div>
<div class="line">                  Value <span class="keyword">const</span> &amp; start = 0, Value <span class="keyword">const</span> &amp; step = 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">*first = start;</div>
<div class="line">start += step;</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaf26349c51c03a24f22baab0138374c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::inspectSequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an analyzing functor at every element of a sequence. </p>
<p>This function can be used to collect statistics of the sequence <code>[first, last)</code> defined by these two input interators. The results must be stored in the functor, which serves as a return value.</p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Functor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77" title="Call an analyzing functor at every element of a sequence.">inspectSequence</a>(InputIterator first, InputIterator last, Functor &amp; f);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">std::vector array(100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// init functor</span></div>
<div class="line"><a class="code" href="classvigra_1_1FindMinMax.html" title="Find the minimum and maximum pixel value in an image or ROI.">vigra::FindMinMax&lt;int&gt;</a> minmax;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77" title="Call an analyzing functor at every element of a sequence.">vigra::inspectSequence</a>(array.begin(), array.end(), minmax);</div>
<div class="line"></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Min: &quot;</span> &lt;&lt; minmax.<a class="code" href="classvigra_1_1FindMinMax.html#a0ae3408e83fa258f08ece61e194251a9">min</a> &lt;&lt; <span class="stringliteral">&quot; Max: &quot;</span> &lt;&lt; minmax.<a class="code" href="classvigra_1_1FindMinMax.html#a7a6d5ee26475974260562366c1a71b01">max</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga643a6681534ba7611545eecca201666a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::indexSort </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexIterator&#160;</td>
          <td class="paramname"><em>index_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index permutation that would sort the input array. </p>
<p>To actually sort an array according to the ordering thus determined, use <a class="el" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10">applyPermutation()</a>.</p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// compare using std::less</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> IndexIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a" title="Return the index permutation that would sort the input array.">indexSort</a>(Iterator first, Iterator last, IndexIterator index_first);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compare using functor Compare</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> IndexIterator, <span class="keyword">class</span> Compare&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a" title="Return the index permutation that would sort the input array.">indexSort</a>(Iterator first, Iterator last, IndexIterator index_first, Compare compare);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator and IndexIterators are random access iterators.</div>
<div class="line"></div>
<div class="line">bool res = compare(first[*index_first], first[*index_first]);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga8686fee88c6f46f3e19a76f00826dc10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::applyPermutation </td>
          <td>(</td>
          <td class="paramtype">IndexIterator&#160;</td>
          <td class="paramname"><em>index_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexIterator&#160;</td>
          <td class="paramname"><em>index_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an array according to the given index permutation. </p>
<p>The iterators <em>in</em> and <em>out</em> may not refer to the same array, as this would overwrite the input prematurely.</p>
<p><b> Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexIterator, <span class="keyword">class</span> InIterator, <span class="keyword">class</span> OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10" title="Sort an array according to the given index permutation.">applyPermutation</a>(IndexIterator index_first, IndexIterator index_last, </div>
<div class="line">                          InIterator in, OutIterator out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">OutIterator and IndexIterators are forward iterators.</div>
<div class="line">InIterator is a random access iterator.</div>
<div class="line"></div>
<div class="line">*out = in[*index_first];</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga89c0801ae0f386bade8dbc77fa485301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::inversePermutation </td>
          <td>(</td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse of a given permutation. </p>
<p>This is just another name for <a class="el" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort()</a>, referring to another semantics.</p>
<p><b> Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InIterator, <span class="keyword">class</span> OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga89c0801ae0f386bade8dbc77fa485301" title="Compute the inverse of a given permutation.">inversePermutation</a>(InIterator first, InIterator last, </div>
<div class="line">                            OutIterator out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">InIterator and OutIterator are random access iterators.</div>
<div class="line"></div>
<div class="line">*out = in[*index_first];</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga482d2e82f374a8758cd516d19f4c3424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::checksum </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the CRC-32 checksum of a byte array. </p>
<p>Implementation note: This function is slower on big-endian machines because the "4 bytes at a time" optimization is only implemented for little-endian. </p>

</div>
</div>
<a class="anchor" id="ga46be68464b972df67e1396fd3a398de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::concatenateChecksum </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate a byte array to an existing CRC-32 checksum. </p>

</div>
</div>
<a class="anchor" id="ga9cf8d64d518f2d493bee81d886906cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::besselJ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bessel function of the first kind. </p>
<p>Computes the value of BesselJ of integer order <code>n</code> and argument <code>x</code>. Negative <code>x</code> are unsupported and will result in a <code>std::domain_error</code>.</p>
<p>This function wraps a number of existing implementations and falls back to a rather slow algorithm if none of them is available. In particular, it uses boost::math when <code>HasBoostMath</code> is #defined, or native implementations on gcc and MSVC otherwise.</p>
<p><b>#include</b> &lt;<a class="el" href="bessel_8hxx_source.html">vigra/bessel.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga84d85515af4527b6922f14a853fe40d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::besselY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bessel function of the second kind. </p>
<p>Computes the value of BesselY of integer order <code>n</code> and argument <code>x</code>. Negative <code>x</code> are unsupported and will result in a <code>std::domain_error</code>.</p>
<p>This function wraps a number of existing implementations and falls back to a rather slow algorithm if none of them is available. In particular, it uses boost::math when <code>HasBoostMath</code> is #defined, or native implementations on gcc and MSVC otherwise.</p>
<p><b>#include</b> &lt;<a class="el" href="bessel_8hxx_source.html">vigra/bessel.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga3fd73560e02ff2f241ebfdf38daf1740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::round </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rounding function. </p>
<p>Defined for all floating point types. Rounds towards the nearest integer such that <code>abs(round(t)) == round(abs(t))</code> for all <code>t</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga97048e053a17edc953036936e59ce88e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vigra::roundi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round and cast to integer. </p>
<p>Rounds to the nearest integer like <a class="el" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544" title="rounding to the nearest integer.">round()</a>, but casts the result to <code>int</code> (this will be faster and is usually needed anyway).</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga54aeb0113ef25c8a4f2e72a1acc794c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::ceilPower2 </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round up to the nearest power of 2. </p>
<p>Efficient algorithm for finding the smallest power of 2 which is not smaller than <em>x</em> (function clp2() from Henry Warren: "Hacker's Delight", Addison-Wesley, 2003, see <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>). If <em>x</em> &gt; 2^31, the function will return 0 because integer arithmetic is defined modulo 2^32.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga73c914923c1c096cef574906d6169329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::floorPower2 </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round down to the nearest power of 2. </p>
<p>Efficient algorithm for finding the largest power of 2 which is not greater than <em>x</em> (function flp2() from Henry Warren: "Hacker's Delight", Addison-Wesley, 2003, see <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>).</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga0271fdd97b849704cded72b31cce3c83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 vigra::log2i </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the base-2 logarithm of an integer. </p>
<p>Returns the position of the left-most 1-bit in the given number <em>x</em>, or -1 if <em>x</em> == 0. That is,</p>
<div class="fragment"><div class="line">assert(k &gt;= 0 &amp;&amp; k &lt; 32 &amp;&amp; <a class="code" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83" title="Compute the base-2 logarithm of an integer.">log2i</a>(1 &lt;&lt; k) == k);</div>
</div><!-- fragment --><p>The function uses Robert Harley's algorithm to determine the number of leading zeros in <em>x</em> (algorithm nlz10() at <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>). But note that the functions <a class="el" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329">floorPower2()</a> or <a class="el" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2()</a> are more efficient and should be preferred when possible.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga5fe62e7b0dc6f379dd436c9c8338c93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NumericTraits&lt;T&gt;::Promote vigra::sq </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The square function. </p>
<p><code>sq(x) = x*x</code> is needed so often that it makes sense to define it as a function.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga203e71c46fd7f38f8139eed3072f6c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">V vigra::power </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponentiation to a positive integer power by squaring. </p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga540e54c778be63996a0f61f7117c2903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 sqrti </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer square root. </p>
<p>Unsigned integer square root.</p>
<p>Useful for fast fixed-point computations.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga99756ca23b738bdc82afba3b0e49df74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T vigra::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sign function. </p>
<p>Returns 1, 0, or -1 depending on the sign of <em>t</em>, but with the same type as <em>t</em>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga2d6f0e128653deb42a47a8f379b4b9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vigra::signi </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integer sign function. </p>
<p>Returns 1, 0, or -1 depending on the sign of <em>t</em>, converted to int.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gab97607c505b78dde9e45ce4f11ad20ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T1 vigra::sign </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary sign function. </p>
<p>Transfers the sign of <em>t2</em> to <em>t1</em>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga3cf86b8d2300cd08b69024eb89f90115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::even </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an integer is even. </p>
<p>Defined for all integral types. </p>

</div>
</div>
<a class="anchor" id="ga48f661149941ebaa90ddd99ee5eee145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::odd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an integer is odd. </p>
<p>Defined for all integral types. </p>

</div>
</div>
<a class="anchor" id="ga38870065d4c6e12602b9154c7e69df1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NormTraits&lt;T&gt;::SquaredNormType vigra::squaredNorm </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The squared norm of a numerical object. </p>
<ul>
<li>
For scalar types: equals <code>vigra::sq(t)</code>. </li>
<li>
For vectorial types (including <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a>): equals <code>vigra::dot(t, t)</code>. </li>
<li>
For complex number types: equals <code><a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">vigra::sq</a>(<a class="el" href="group__FFTWComplexOperators.html#gafa8d2d7496e4bdd96c42026a0ecbde1c" title="real part">t.real()</a>) + <a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">vigra::sq</a>(<a class="el" href="group__FFTWComplexOperators.html#ga8a3bba029e1ba026bd968786cfcf4546" title="imaginary part">t.imag()</a>)</code>. </li>
<li>
For array and matrix types: results in the squared Frobenius norm (sum of squares of the matrix elements). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga794eb2a920016363c5e9653b6b2b6eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NormTraits&lt;T&gt;::NormType vigra::norm </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The norm of a numerical object. </p>
<p>For scalar types: implemented as <code>abs(t)</code><br/>
 otherwise: implemented as <code>sqrt(squaredNorm(t))</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga9210561d31f03b4fa1656bafc7182c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::symmetric2x2Eigenvalues </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues of a 2x2 real symmetric matrix. </p>
<p>This uses the analytical eigenvalue formula </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \lambda_{1,2} = \frac{1}{2}\left(a_{00} + a_{11} \pm \sqrt{(a_{00} - a_{11})^2 + 4 a_{01}^2}\right) \]" src="form_54.png"/>
</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga2c49eca66b2ba5c308d04fa324dcc230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::symmetric3x3Eigenvalues </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues of a 3x3 real symmetric matrix. </p>
<p>This uses a numerically stable version of the analytical eigenvalue formula according to </p>
<p>David Eberly: <a href="http://www.geometrictools.com/Documentation/EigenSymmetric3x3.pdf"><em>"Eigensystems for 3  3 Symmetric Matrices (Revisited)"</em></a>, Geometric Tools Documentation, 2006</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga7e909bd1d07e846d5d3ba78eaed7c520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::ellipticIntegralF </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The incomplete elliptic integral of the first kind. </p>
<p>This function computes</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{F}(x, k) = \int_0^x \frac{1}{\sqrt{1 - k^2 \sin(t)^2}} dt \]" src="form_55.png"/>
</p>
<p>according to the algorithm given in Press et al. "Numerical Recipes".</p>
<p>Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral functions must be k^2 rather than k. Check the documentation when results disagree!</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga29d6193bd95ec54c5f25dd0470f58215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::ellipticIntegralE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The incomplete elliptic integral of the second kind. </p>
<p>This function computes</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{E}(x, k) = \int_0^x \sqrt{1 - k^2 \sin(t)^2} dt \]" src="form_56.png"/>
</p>
<p>according to the algorithm given in Press et al. "Numerical Recipes". The complete elliptic integral of the second kind is simply <code>ellipticIntegralE(M_PI/2, k)</code>.</p>
<p>Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral functions must be k^2 rather than k. Check the documentation when results disagree!</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga0f6a2804ceaf785495472fb9bf2dd5bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::chi2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chi square distribution. </p>
<p>Computes the density of a chi square distribution with <em>degreesOfFreedom</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em> by calling <code>noncentralChi2(degreesOfFreedom, 0.0, arg, accuracy)</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaa94c7af27b4aecda8a764beb89dbc2a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::chi2CDF </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative chi square distribution. </p>
<p>Computes the cumulative density of a chi square distribution with <em>degreesOfFreedom</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> by calling <code>noncentralChi2CDF(degreesOfFreedom, 0.0, arg, accuracy)</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga074ace0a87d00243c85a52e5071a1ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-central chi square distribution. </p>
<p>Computes the density of a non-central chi square distribution with <em>degreesOfFreedom</em>, noncentrality parameter <em>noncentrality</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>. It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from <a href="http://lib.stat.cmu.edu/apstat/231">http://lib.stat.cmu.edu/apstat/231</a>). The algorithm has linear complexity in the number of degrees of freedom.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga4e01fc59c3d8455e8ccbbd8824230226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2CDF </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative non-central chi square distribution. </p>
<p>Computes the cumulative density of a chi square distribution with <em>degreesOfFreedom</em>, noncentrality parameter <em>noncentrality</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from <a href="http://lib.stat.cmu.edu/apstat/231">http://lib.stat.cmu.edu/apstat/231</a>). The algorithm has linear complexity in the number of degrees of freedom (see <a class="el" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb" title="Cumulative non-central chi square distribution (approximate).">noncentralChi2CDFApprox()</a> for a constant-time algorithm).</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaddeff01bf2aa44ad74399a1888a6bbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2CDFApprox </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative non-central chi square distribution (approximate). </p>
<p>Computes approximate values of the cumulative density of a chi square distribution with <em>degreesOfFreedom</em>, and noncentrality parameter <em>noncentrality</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> It uses the approximate transform into a normal distribution due to Wilson and Hilferty (see Abramovitz, Stegun: "Handbook of Mathematical Functions", formula 26.3.32). The algorithm's running time is independent of the inputs, i.e. is should be used when <a class="el" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">noncentralChi2CDF()</a> is too slow, and approximate values are sufficient. The accuracy is only about 0.1 for few degrees of freedom, but reaches about 0.001 above dof = 5.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga53853aa76befa82637051ecbadc9a10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::legendre </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associated Legendre polynomial. </p>
<p>Computes the value of the associated Legendre polynomial of order <code>l, m</code> for argument <code>x</code>. <code>x</code> must be in the range <code>[-1.0, 1.0]</code>, otherwise an exception is thrown. The standard Legendre polynomials are the special case <code>m == 0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga0197e622433399bc9792bb1a884c0b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::legendre </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legendre polynomial. </p>
<p>Computes the value of the Legendre polynomial of order <code>l</code> for argument <code>x</code>. <code>x</code> must be in the range <code>[-1.0, 1.0]</code>, otherwise an exception is thrown.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga8fe78db7b7769819568aeafbfbc2ffd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::sin_pi </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sin(pi*x). </p>
<p>Essentially calls <code>std::sin(M_PI*x)</code> but uses a more accurate implementation to make sure that <code>sin_pi(1.0) == 0.0</code> (which does not hold for <code>std::sin(M_PI)</code> due to round-off error), and <code>sin_pi(0.5) == 1.0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga7ce9a27a70c7341a29c4637cddf26f8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::cos_pi </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cos(pi*x). </p>
<p>Essentially calls <code>std::cos(M_PI*x)</code> but uses a more accurate implementation to make sure that <code>cos_pi(1.0) == -1.0</code> and <code>cos_pi(0.5) == 0.0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga441c9e4bf9f952c0fe94836634bcf976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::gamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The gamma function. </p>
<p>This function implements the algorithm from<br/>
 Zhang and Jin: "Computation of Special Functions", John Wiley and Sons, 1996.</p>
<p>The argument must be &lt;= 171.0 and cannot be zero or a negative integer. An exception is thrown when these conditions are violated.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="total_variation_8cxx-example.html#a11">total_variation.cxx</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafc5038616b325ecfd12b4ef51318aa26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::loggamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of the gamma function. </p>
<p>This function is based on a free implementation by Sun Microsystems, Inc., see <a href="http://www.sourceware.org/cgi-bin/cvsweb.cgi/~checkout~/src/newlib/libm/mathfp/er_lgamma.c?rev=1.6&amp;content-type=text/plain&amp;cvsroot=src">sourceware.org</a> archive. It can be removed once all compilers support the new C99 math functions.</p>
<p>The argument must be positive and &lt; 1e30. An exception is thrown when these conditions are violated.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga10235727f77f6dfa6af756ce20eec2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::closeAtTolerance </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PromoteTraits&lt; T1, T2 &gt;::Promote&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tolerance based floating-point comparison. </p>
<p>Check whether two floating point numbers are equal within the given tolerance. This is useful because floating point numbers that should be equal in theory are rarely exactly equal in practice. If the tolerance <em>epsilon</em> is not given, twice the machine epsilon is used.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga8ba489a131e75016f32095b106659d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convexHull </td>
          <td>(</td>
          <td class="paramtype">const PointArray1 &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointArray2 &amp;&#160;</td>
          <td class="paramname"><em>convex_hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute convex hull of a 2D polygon. </p>
<p>The input array <em>points</em> contains a (not necessarily ordered) set of 2D points whose convex hull is to be computed. The array's <code>value_type</code> (i.e. the point type) must be compatible with std::vector (in particular, it must support indexing, copying, and have <code>size() == 2</code>). The points of the convex hull will be appended to the output array <em>convex_hull</em> (which must support <code>std::back_inserter(convex_hull)</code>). Since the convex hull is a closed polygon, the first and last point of the output will be the same (i.e. the first point will simply be inserted at the end again). The points of the convex hull will be ordered counter-clockwise, starting with the leftmost point of the input. The function implements Andrew's Monotone Chain algorithm. </p>

</div>
</div>
<a class="anchor" id="ga5825d3973169fc0c90404849a5906697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntType vigra::gcd </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the greatest common divisor.</p>
<p>This function works for arbitrary integer types, including user-defined (e.g. infinite precision) ones.</p>
<p><b>#include</b> &lt;<a class="el" href="rational_8hxx_source.html">vigra/rational.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga1aa613671eda401daa90a686497c27da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntType vigra::lcm </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the lowest common multiple.</p>
<p>This function works for arbitrary integer types, including user-defined (e.g. infinite precision) ones.</p>
<p><b>#include</b> &lt;<a class="el" href="rational_8hxx_source.html">vigra/rational.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaebd375194b3220beebe0a22e67d7a4e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CatmullRomSpline&lt; T &gt;::result_type operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1CatmullRomSpline.html#ae45326fbc1e2bb968bbb688bd8da81f1">argument_type</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function (functor) call </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Mon Nov 18 2013)
</i>
</tr>
</table>
</BODY>
</HTML>
