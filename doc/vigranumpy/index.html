

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vigranumpy Reference &mdash; vigranumpy 1.10.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/vigra-icon.ico"/>
    <link rel="top" title="vigranumpy 1.10.0 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">vigranumpy 1.10.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="vigranumpy-reference">
<h1><a class="toc-backref" href="#id62">Vigranumpy Reference</a><a class="headerlink" href="#vigranumpy-reference" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#vigranumpy-reference" id="id62">Vigranumpy Reference</a><ul>
<li><a class="reference internal" href="#introduction" id="id63">Introduction</a></li>
<li><a class="reference internal" href="#axistags-and-the-vigraarray-data-structure" id="id64">Axistags and the VigraArray Data Structure</a></li>
<li><a class="reference internal" href="#more-on-the-motivation-and-use-of-axistags" id="id65">More On the Motivation and Use of Axistags</a><ul>
<li><a class="reference internal" href="#history-of-the-problem" id="id66">History of the problem</a></li>
<li><a class="reference internal" href="#arrays-as-matrices" id="id67">Arrays as Matrices</a></li>
<li><a class="reference internal" href="#arrays-as-images" id="id68">Arrays as Images</a></li>
<li><a class="reference internal" href="#multi-dimensional-arrays" id="id69">Multi-Dimensional Arrays</a></li>
<li><a class="reference internal" href="#vigra-and-numpy" id="id70">VIGRA and numpy</a></li>
<li><a class="reference internal" href="#vigranumpy-axistags" id="id71">Vigranumpy Axistags</a></li>
<li><a class="reference internal" href="#vigranumpy-conventions" id="id72">Vigranumpy Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#axistag-reference" id="id73">Axistag Reference</a></li>
<li><a class="reference internal" href="#vigraarray-reference" id="id74">VigraArray Reference</a></li>
<li><a class="reference internal" href="#import-and-export-functions" id="id75">Import and Export Functions</a></li>
<li><a class="reference internal" href="#mathematical-functions-and-type-coercion" id="id76">Mathematical Functions and Type Coercion</a></li>
<li><a class="reference internal" href="#color-and-intensity-manipulation" id="id77">Color and Intensity Manipulation</a></li>
<li><a class="reference internal" href="#filters" id="id78">Filters</a></li>
<li><a class="reference internal" href="#sampling-image-resizing-and-image-pyramids" id="id79">Sampling: Image Resizing and Image Pyramids</a></li>
<li><a class="reference internal" href="#fourier-transforms" id="id80">Fourier Transforms</a></li>
<li><a class="reference internal" href="#image-analysis" id="id81">Image Analysis</a></li>
<li><a class="reference internal" href="#geometry" id="id82">Geometry</a></li>
<li><a class="reference internal" href="#optimization" id="id83">Optimization</a></li>
<li><a class="reference internal" href="#machine-learning" id="id84">Machine Learning</a></li>
<li><a class="reference internal" href="#noise-estimation-and-normalization" id="id85">Noise Estimation and Normalization</a></li>
<li><a class="reference internal" href="#writing-your-own-c-modules" id="id86">Writing Your Own C++ Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables" id="id87">Indices and tables</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id63">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Vigranumpy exports the functionality of the C++ image processing library <a class="reference external" href="../vigra/index.html">VIGRA</a> to Python. It can be invoked by importing the vigra module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vigra</span>
</pre></div>
</div>
<p>Vigranumpy is based on the popular <a class="reference external" href="http://numpy.scipy.org/">numpy</a> module and uses its ndarray data structure to represent image and volume data. It introduces the C++ wrapper class <a class="reference external" href="../../doc/vigra/classvigra_1_1NumpyArray.html">NumpyArray</a> to allow transparent execution of VIGRA C++ functions on numpy arrays. Thus, vigranumpy is fully interoperable with existing numpy functionality, including various tools for image display such as matplotlib. Since vigranumpy uses <a class="reference external" href="http://www.boost.org/doc/libs">boost_python</a>, it is able to support function overloading (which plain Python does not provide), so that calling syntax is largely uniform, regardless of the type and dimension of the input arguments.</p>
<p>Basic calling syntax is similar to C++, with one important difference: Arguments for output images are optional. If no output image is provided, vigranumpy will allocate it as appropriate. In either case, the output image will be returned by the function, for example:</p>
<div class="highlight-python"><pre># allocate new result image
&gt;&gt;&gt; smoothImage = vigra.gaussianSmoothing(inputImage, scale)

# reuse and overwrite existing result image
&gt;&gt;&gt; smoothImage = vigra.gaussianSmoothing(inputImage, scale, out=smoothImage)</pre>
</div>
<p>Unless otherwise noted, all functions expect and create arrays with dtype=numpy.float32.</p>
<p>Another important concern is the interpretation and ordering of the array axes. Numpy does not provide any means to attach semantics to axes, but relies purely on the convention that the most important axis is last, as in <tt class="docutils literal"><span class="pre">array[y,</span> <span class="pre">x]</span></tt> or <tt class="docutils literal"><span class="pre">array[z,</span> <span class="pre">y,</span> <span class="pre">x]</span></tt> (&#8220;C-order&#8221;). However, there is no way to enforce this convention in a program, since arrays can be transposed outside of the user&#8217;s control (e.g. when saving data to a file). Moreover, many imaging libraries (e.g. <a class="reference external" href="http://www.imagemagick.org/">Image Magick</a>, <a class="reference external" href="http://opencv.willowgarage.com/">OpenCV</a>, <a class="reference external" href="http://qt-project.org/">Qt</a> and the C++ version of VIGRA) use the opposite convention where the x-axis comes first, as in <tt class="docutils literal"><span class="pre">array[x,</span> <span class="pre">y]</span></tt> or <tt class="docutils literal"><span class="pre">array[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></tt>. This makes it very difficult to convert solutions developed in Python into a fast C++ version, because one has to reverse all indices without making mistakes. Matters become even more complicated when multi-channel (e.g. color) images are considered &#8211; should the color index now be first or last?</p>
<p>To solve these ambiguities in a clean way, vigranumpy introduces the concept of <strong>axistags</strong> which is realized in class <a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisTags</span></tt></a>. Every <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> (which is a subclass of numpy.ndarray) gets a new property <tt class="docutils literal"><span class="pre">array.axistags</span></tt> that describes axis semantics, and all vigranumpy functions account for and preserve axistag information. Unfortunately, this functionality cannot easily be retrofitted to numpy.ndarray itself. Therefore, we employ the following conversion rules between Python and C++ arrays:</p>
<ul>
<li><p class="first">When the Python array has <strong>no</strong> <tt class="docutils literal"><span class="pre">array.axistags</span></tt> property, it is mapped to the C++ NumpyArray
<strong>without</strong> any change in axis ordering. Since most VIGRA functions can work on arbitrarily
transposed arrays, you will get correct results, but execution may be slower because the
processor cache is poorly utilized in certain axis orders.</p>
<p>Moreover, this may lead to overload resolution ambiguities. For example, when the array has shape
<tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">60,</span> <span class="pre">40)</span></tt>, vigranumpy has no way to decide if this is a 2-dimensional RGB image or
a 3-dimensional array that happens to have only 3 slices. Thus, vigranumpy may not always
execute the function you actually intended to call.</p>
</li>
<li><p class="first">When the Python array <strong>has</strong> the <tt class="docutils literal"><span class="pre">array.axistags</span></tt> property, it is transposed into a
<strong>canonical</strong> axis ordering before vigranumpy executes a function, and the results are
transposed back into the original ordering. Likewise, functions that change axis ordering
(such as <tt class="docutils literal"><span class="pre">array.swapaxes(0,1)</span></tt>) or reduce the number of axes (such as <tt class="docutils literal"><span class="pre">array.max(axis=1)</span></tt>)
as well as array arithmetic operations preserve axistags (see section <a class="reference internal" href="#sec-dtype-coercion"><em>Mathematical Functions and Type Coercion</em></a>).
Thus, you can work in any desired axis order without loosing control. Overload ambiguities
can no longer occur because a function cannot be called when the axistags are unsuitable.</p>
</li>
</ul>
<p>Detailed information about the use of axistags is given in section <a class="reference internal" href="#sec-vigraarray"><em>Axistags and the VigraArray Data Structure</em></a> below. Section <a class="reference internal" href="#sec-own-modules"><em>Writing Your Own C++ Modules</em></a> describes how you can take advantage of the axistags mechanism in your own C++ code.</p>
</div>
<div class="section" id="axistags-and-the-vigraarray-data-structure">
<span id="sec-vigraarray"></span><h2><a class="toc-backref" href="#id64">Axistags and the VigraArray Data Structure</a><a class="headerlink" href="#axistags-and-the-vigraarray-data-structure" title="Permalink to this headline">¶</a></h2>
<p>While vigranumpy can directly work on numpy.ndarrays, this would not give us the advantages of axistags as described above. Therefore, vigranumpy introduces its own array class <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> which is a subclass of numpy.ndarray, but re-implements many of its methods so that axistags are respected. Arrays with a conforming <tt class="docutils literal"><span class="pre">axistags</span></tt> property are most easily constructed by one of the predefined <a class="reference internal" href="#subsec-array-factories"><em>array factories</em></a>. A <strong>view with axistags</strong> can be created from an existing numpy.ndarray by means of the function <a class="reference internal" href="#vigra.taggedView" title="vigra.taggedView"><tt class="xref py py-func docutils literal"><span class="pre">taggedView()</span></tt></a> (in contrast, factory functions create copies of the given arrays, not views). We illustrate the ideas by some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">3</span>

<span class="go"># create a 2-dimensional RGB image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 200, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span>             <span class="c"># short output: only axis keys</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span>       <span class="c"># long output</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) RGB</span>

<span class="go"># create a 3-dimensional scalar volume</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarVolume</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 200, 3)        # same shape as before</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y z                # but different semantic interpretation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">volume</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;z&#39; (type: Space)</span>
</pre></div>
</div>
<p>It is also possible to attach additional information to the axistags, in particular the resolution of the axis, and a text comment. The resolution will be correctly adjusted when the image is resized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.2</span>  <span class="c"># in some unit of length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.4</span>  <span class="c"># in some unit of length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">&#39;fluorescence microscopy, DAPI and GFP staining&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1.2)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=1.4)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) fluorescence microscopy, DAPI and GFP staining</span>

<span class="go"># interpolate the image to twice its original size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb2</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rgb2</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=0.6)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=0.7)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) fluorescence microscopy, DAPI and GFP staining</span>
</pre></div>
</div>
<p>When the array is transposed, the axistags are transposed accordingly. When axes are dropped from the array, the corresponding entries are dropped from the axistags property:</p>
<div class="highlight-python"><pre># transpose the volume into reverse axis order
&gt;&gt;&gt; transposed_volume = volume.transpose()
&gt;&gt;&gt; transposed_volume.shape
(3, 200, 300)
&gt;&gt;&gt; transposed_volume.axistags
z y x

# get a view to the first slice (z == 0)
&gt;&gt;&gt; first_slice = volume[..., 0]
&gt;&gt;&gt; first_slice.shape
(300, 200)
&gt;&gt;&gt; first_slice.axistags
x y

# get the maximum of each slice
&gt;&gt;&gt; volume.max(axis=0).max(axis=0)
VigraArray(shape=(3,), axistags=z, dtype=float32, data=
[ 0.  0.  0.])

# likewise, but specify axes by their keys
&gt;&gt;&gt; volume.max(axis='x').max(axis='y')
VigraArray(shape=(3,), axistags=z, dtype=float32, data=
[ 0.  0.  0.])</pre>
</div>
<p>The initial ordering of the axes is controlled by the argument <tt class="docutils literal"><span class="pre">order</span></tt> that can optionally be passed to the VigraArray constuctor or the factory functions. If <tt class="docutils literal"><span class="pre">order</span></tt> is not explicitly provided, it is determined by the static property <a class="reference internal" href="#VigraArray.defaultOrder" title="VigraArray.defaultOrder"><tt class="xref py py-attr docutils literal"><span class="pre">VigraArray.defaultOrder</span></tt></a> (which yields &#8216;V&#8217; order). The following orders are currently supported:</p>
<blockquote id="array-order-parameter">
<div><dl class="docutils">
<dt>&#8216;C&#8217; order:</dt>
<dd>Both strides and axes are arranged in descending order, as in a
plain numpy.ndarray. For example, axistags will be &#8216;y x c&#8217; or
&#8216;z y x c&#8217;. array.flags[&#8216;C_CONTIGUOUS&#8217;] will be true.</dd>
<dt>&#8216;F&#8217; order:</dt>
<dd>Both strides and axes are arranged in ascending order, i.e.
opposite to &#8216;C&#8217; order. For example, axistags will be &#8216;c x y&#8217;
or &#8216;c x y z&#8217;. array.flags[&#8216;F_CONTIGUOUS&#8217;] will be true.</dd>
<dt>&#8216;V&#8217; order:</dt>
<dd>VIGRA-order is an interleaved memory layout that simulates
vector-valued pixels or voxels: Channels will be the last axis
and have the smallest stride, whereas all other axes are arranged
in ascending order. For example, axistags will be &#8216;x y c&#8217; or
&#8216;x y z c&#8217;.</dd>
<dt>&#8216;A&#8217; order:</dt>
<dd>Defaults to &#8216;V&#8217; when a new array is created, and means
&#8216;preserve order&#8217; when an existing array is copied.</dd>
</dl>
</div></blockquote>
<p>The meaning of &#8216;ascending&#8217; or &#8216;descending&#8217; order is determined by two rules: the primary order is according to axis type (see <a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisType</span></tt></a>), where <tt class="docutils literal"><span class="pre">Channels</span> <span class="pre">&lt;</span> <span class="pre">Space</span> <span class="pre">&lt;</span> <span class="pre">Angle</span> <span class="pre">&lt;</span> <span class="pre">Time</span> <span class="pre">&lt;</span> <span class="pre">Frequency</span> <span class="pre">&lt;</span> <span class="pre">Unknown</span></tt>. The secondary order (between axes of the same type) is lexicographic, such that &#8216;x&#8217; &lt; &#8216;y&#8217; &lt; &#8216;z&#8217;. Usage examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgbv</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;V&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbv</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 200, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbv</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y c</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbc</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbc</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(200, 300, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbc</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">y x c</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbf</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbf</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 300, 200)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbf</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">c x y</span>
</pre></div>
</div>
<p>Functions that reduce the array to a one-dimensional shape (<tt class="docutils literal"><span class="pre">flatten()</span></tt>, <tt class="docutils literal"><span class="pre">flat</span></tt>, <tt class="docutils literal"><span class="pre">ravel()</span></tt>, <tt class="docutils literal"><span class="pre">take()</span></tt>) always transpose the array into &#8216;C&#8217; order before flattening.</p>
<p>Axistags are stored in a list-like class <a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisTags</span></tt></a>, whose individual entries are of type <a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisInfo</span></tt></a>. The simplest way to attach axistags to a plain numpy.ndarray (by creating a view of type VigraArray) is via the convenience function <a class="reference internal" href="#vigra.taggedView" title="vigra.taggedView"><tt class="xref py py-func docutils literal"><span class="pre">vigra.taggedView()</span></tt></a>.</p>
</div>
<div class="section" id="more-on-the-motivation-and-use-of-axistags">
<h2><a class="toc-backref" href="#id65">More On the Motivation and Use of Axistags</a><a class="headerlink" href="#more-on-the-motivation-and-use-of-axistags" title="Permalink to this headline">¶</a></h2>
<div class="section" id="history-of-the-problem">
<h3><a class="toc-backref" href="#id66">History of the problem</a><a class="headerlink" href="#history-of-the-problem" title="Permalink to this headline">¶</a></h3>
<p>A Fortran array declaration:</p>
<div class="highlight-python"><pre>real f(20,10)</pre>
</div>
<p>is compiled such that the elements of the first index are consecutive in memory. In contrast, a C array declaration:</p>
<div class="highlight-python"><pre>float c[20][10];</pre>
</div>
<p>places the elements of the last index consecutive in memory. The two possibilities are commonly referred to as &#8220;Fortran order&#8221; and &#8220;C order&#8221;, but we will see that these terms are actually ambiguous because their meaning depends on what the array is used for.</p>
</div>
<div class="section" id="arrays-as-matrices">
<h3><a class="toc-backref" href="#id67">Arrays as Matrices</a><a class="headerlink" href="#arrays-as-matrices" title="Permalink to this headline">¶</a></h3>
<p>When the array represents a matrix, users require the syntax to conform to the mathematical syntax conventions (in order to avoid bugs when typing formulas). In mathematics, m<sub>ij</sub> means that the first index i refers to rows, and the second index j refers to columns. Thus, Fortran&#8217;s <tt class="docutils literal"><span class="pre">f(i,</span> <span class="pre">j)</span></tt> and C&#8217;s <tt class="docutils literal"><span class="pre">c[i][j]</span></tt> have exactly the same meaning, but the memory layouts of the two matrices differ: Since in Fortran the first index changes quickest, this is referred to as the &#8220;column major&#8221; format (the elements of a column are consecutive in memory). In contrast, C uses the &#8220;row major&#8221; format (the elements of a row are consecutive in memory).</p>
<p>In short: When the array is a matrix, the syntax is the same, but the memory layouts differ.</p>
</div>
<div class="section" id="arrays-as-images">
<h3><a class="toc-backref" href="#id68">Arrays as Images</a><a class="headerlink" href="#arrays-as-images" title="Permalink to this headline">¶</a></h3>
<p>When the array represents an image, users require the memory layout to be the same as in the image files which store the data (in order to ensure fast I/O). All image formats (JPEG, TIFF, PNG, ...) follow the convention of analog television to scan an image left to right, then top to bottom. Consequently, the horizontal pixels are consecutive in memory, and therefore Fortran (where the first axis changes fastest) must use the syntax <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y)</span></tt>, whereas C (where the last axis changes fastest) must use <tt class="docutils literal"><span class="pre">c[y][x]</span></tt>.</p>
<p>In short: When the array is an image, the memory layout is the same, but the syntax differs.</p>
<p>Thus, we have four basic conventions: FM and CM for matrices, FI and CI for images. The meaning of the terms &#8220;Fortran order&#8221; and &#8220;C order&#8221; depends on whether we are talking about matrices (where they refer to FM and CM, i.e. a difference in memory layout) or images (where they refer to FI and CI, i.e. a difference in index order).</p>
</div>
<div class="section" id="multi-dimensional-arrays">
<h3><a class="toc-backref" href="#id69">Multi-Dimensional Arrays</a><a class="headerlink" href="#multi-dimensional-arrays" title="Permalink to this headline">¶</a></h3>
<p>When we add more dimensions, the confusion increases, because there are no universally accepted memory and indexing conventions. For example, an RGB image can be stored in &#8220;interleaved format&#8221;:</p>
<div class="highlight-python"><pre>RGB RGB RGB ...
RGB RGB RGB ...
:
:</pre>
</div>
<p>where the color values of each pixel are consecutive in memory, or in &#8220;banded format&#8221;:</p>
<div class="highlight-python"><pre>R R R ...
R R R ...
:
G G G ...
G G G ...
:
B B B ...
B B B ...
:</pre>
</div>
<p>where we have a separate scalar image for each color. In Fortran, interleaved and banded images must be indexed as <tt class="docutils literal"><span class="pre">f(color,</span> <span class="pre">x,</span> <span class="pre">y)</span></tt> and <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y,</span> <span class="pre">color)</span></tt> respectively, whereas in C we must use <tt class="docutils literal"><span class="pre">c[y][x][color]</span></tt> or <tt class="docutils literal"><span class="pre">c[color][y][x]</span></tt>.</p>
</div>
<div class="section" id="vigra-and-numpy">
<h3><a class="toc-backref" href="#id70">VIGRA and numpy</a><a class="headerlink" href="#vigra-and-numpy" title="Permalink to this headline">¶</a></h3>
<p>From the beginning, VIGRA adopted Fortran conventions, i.e. its default behavior is according to FM and FI (this is possible because VIGRA uses array classes, where the mapping from indices to memory is encapsulated in the appropriate way).</p>
<p>In contrast, numpy adopted C conventions, i.e. its default behavior is CM and CI.</p>
<p>In addition, both packages provide array views which keep the memory layout intact, but change the index order. Thus, VIGRA also supports the CI convention, and numpy also supports FI. Note that changing the index order is only allowed for images. Matrices always use the fixed index order dictated by mathematics where transpose(m) is a well-defined mathematical operation (which just happens to revert the index order). Therefore, the existence of array views does not imply that VIGRA supports CM or numpy supports FM.</p>
<p>However, numpy&#8217;s array constructor provides an argument &#8216;order&#8217; which can take the values &#8216;C&#8217; (default) and &#8216;F&#8217; to construct arrays with C or Fortran memory order. By this mechanism, numpy also supports the FM convention (and thus all four basic possibilities).</p>
<p>But here is the catch: When you get a numpy array view, you have no way to tell which convention it adheres to. It simply doesn&#8217;t contain this information.</p>
<p>The usual solution to this problem is to enforce a fixed axis order in the entire application, but this workaround breaks down when the application must simultaneously handle arrays with different meaning (e.g. sequences &#8216;xyt&#8217; vs. volumes &#8216;xyz&#8217; vs. multi-spectral images &#8216;xyc&#8217;) or when the application uses modules with conflicting requirements (e.g. numpy&#8217;s &#8216;yx&#8217; vs. PyQt&#8217;s &#8216;xy&#8217;).</p>
</div>
<div class="section" id="vigranumpy-axistags">
<h3><a class="toc-backref" href="#id71">Vigranumpy Axistags</a><a class="headerlink" href="#vigranumpy-axistags" title="Permalink to this headline">¶</a></h3>
<p>This is precisely where axistags enter: They attach information to array views that allows the user to figure out which convention applies to a given view. Thus, the primary purpose of axistags is entirely passive - they just keep track of how users manipulate the axis order when creating new array views. The main use case of axistags is therefore to re-adjust the axis order whenever an algorithm has specific order requirements. Using axistags, one can easily ensure that arrays conform to the desired order at the beginning of every algorithm. Consider the following example: Let &#8216;image&#8217; be a scalar 2D image with axistags. Then we can ask for the image&#8217;s width and height independently of the current axis order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">width</span>  <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span>    <span class="c"># this works for any axis order!</span>
<span class="n">height</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span>
</pre></div>
</div>
<p>Now suppose we want to execute a numpy algorithm which expects the [y, x] ordering. We simply transpose the array before calling the algorithm like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># adjust the axis order</span>
<span class="n">numpy_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transposeToNumpyOrder</span><span class="p">()</span>

<span class="c"># execute the algorithm</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">numpy_image</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>   <span class="c"># note the index order</span>
</pre></div>
</div>
<p>When we want to execute a VIGRA algorithm which expects the [x, y] ordering, we do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># adjust the axis order</span>
<span class="n">vigra_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transposeToVigraOrder</span><span class="p">()</span>

<span class="c"># execute the algorithm</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">vigra_image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>   <span class="c"># note the index order</span>
</pre></div>
</div>
<p>Notice that the order of the loops (the inner loop runs over x) is the same in both cases: To maximize cache locality and therefore speed, the inner loop should operate on consecutive memory cells. Since image memory order derives from file memory order (where the x-axis is consecutive), and array views can never change the memory order, this loop ordering is always preferable, regardless of the index order.</p>
</div>
<div class="section" id="vigranumpy-conventions">
<h3><a class="toc-backref" href="#id72">Vigranumpy Conventions</a><a class="headerlink" href="#vigranumpy-conventions" title="Permalink to this headline">¶</a></h3>
<p>To handle axis meaning in a well-defined way, vigranumpy adopts the following conventions, which are designed such that The Right Thing (TM) should happen automatically, at least most of the time:</p>
<ol class="arabic">
<li><p class="first">When the array represents a matrix, no axistags are allowed because the index order has a fixed semantic meaning and must not be messed around with. In vigranumpy, this requirement is enforced by an assertion:</p>
<div class="highlight-python"><pre>vigra_precondition( !matrix.axistags(), "matrix must not have axistags");</pre>
</div>
<p>in the C++ gluecode functions. This applies, for example, to the feature matrices passed to a random forest and to unsupervised learning algorithms. If desired, we can introduce additional axistags for features and samples in the future because this is a common use case.</p>
</li>
<li><p class="first">When arrays represent image data with up to five dimensions, axistags should be used. To sort indices according to the requirements of the next algorithm to be executed, the appropriate convenience function should be called (many more convenience functions are documented in <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">vigra.VigraArray</span></tt></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numpy_array</span>   <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">transposeToNumpyOrder</span><span class="p">()</span>    <span class="c"># gives &#39;yx&#39;, &#39;zyx&#39; etc.</span>
<span class="n">vigra_array</span>   <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">transposeToVigraOrder</span><span class="p">()</span>    <span class="c"># gives &#39;xy&#39;, &#39;xyz&#39; etc.</span>
<span class="n">ilastik_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">view5D</span><span class="p">()</span>                   <span class="c"># gives &#39;txyzc&#39; (inserts singleton axes if necessary)</span>
<span class="n">user_defined</span>  <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;t&#39;</span><span class="p">)</span>    <span class="c"># specify order explicitly (inserts singleton axes if necessary)</span>
</pre></div>
</div>
<p>Algorithms with special order requirements can then check for the correct order in an assertion.</p>
</li>
<li><p class="first">The function <tt class="docutils literal"><span class="pre">vigra.taggedView()</span></tt> allows to attach axistags to an array very conveniently. For example, when you know from the context that the axes of a given array are to be interpreted as &#8216;xyzt&#8217; in that order, you can make this knowledge explicit by calling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tagged_array</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">taggedView</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s">&#39;xyzt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">When you call a vigranumpy function that executes a C++ VIGRA function, <tt class="docutils literal"><span class="pre">image.transposeToVigraOrder()</span></tt> will be invoked automatically on the input arrays, and the original axis order will be restored in the output arrays.</p>
</li>
<li><p class="first">When you call a vigranumpy function that is forwarded to a numpy function (in particular, a ufunc like <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">sqrt</span></tt> etc.), <tt class="docutils literal"><span class="pre">image.transposeToNumpyOrder()</span></tt> will be invoked automatically on the input arrays, and the original axis order will be restored in the output arrays.</p>
</li>
<li><p class="first">When vigranumpy writes arrays to a file, it will always order the axes such that the memory order conforms to the established file conventions (e.g. values along the x-axis are consecutive). In particular, when you use <tt class="docutils literal"><span class="pre">vigra.impex.writeHDF5()</span></tt> to create HDF5 datasets, <tt class="docutils literal"><span class="pre">array.transposeToNumpyOrder()</span></tt> will be called before writing the data (this is a consequence of item 5, because <tt class="docutils literal"><span class="pre">writeHDF5()</span></tt> eventually forwards the actual work to h5py). In addition, the axistags (in numpy order) will be stored in a dataset attribute <tt class="docutils literal"><span class="pre">axistags</span></tt>.</p>
</li>
<li><p class="first">When vigranumpy reads data from a file, it preserves the file&#8217;s memory order and attaches the appropriate axistags. In case of images, the axis order follows from the usual file conventions. If you call <tt class="docutils literal"><span class="pre">vigra.impex.readHDF5()</span></tt> to read HDF5, the axistags will be read from the attribute <tt class="docutils literal"><span class="pre">axistags</span></tt> (if present). Upon return, the read functions automatically call <tt class="docutils literal"><span class="pre">array.transposeToVigraOrder()</span></tt>, but this only changes the index order, not the memory layout. This latter convention was adopted to ensure that the default index order is the same in the Python and C++ versions of VIGRA.</p>
</li>
<li><p class="first">When you display an image via <tt class="docutils literal"><span class="pre">image.imshow()</span></tt> or <tt class="docutils literal"><span class="pre">image.show()</span></tt>, the axes are re-ordered automatically such that the image is displayed upright (i.e. x goes to the right, y goes down). If you want to override this (i.e. want to enforce transposed display), you can remove the axistags by calling <tt class="docutils literal"><span class="pre">image.view(numpy.ndarray)</span></tt>.</p>
</li>
</ol>
<p>Item 4. has two important consequences one should be aware of:</p>
<ul class="simple">
<li>When a function needs parameters that depend on the axis order (such as the new shape in <tt class="docutils literal"><span class="pre">vigra.sampling.resize()</span></tt> or axis-dependent sigmas in <tt class="docutils literal"><span class="pre">vigra.filters.gaussianSmoothing()</span></tt>), these parameters must be re-ordered on the C++ side in the same way as the axes. This is achieved by a call to <tt class="docutils literal"><span class="pre">NumpyArray::permuteLikewise()</span></tt> in the C++ gluecode functions.</li>
<li>When a vigranumpy function computes a gradient image, the gradient vector elements will always be stored in the order (dx, dy, dz), regardless of the array&#8217;s original axis ordering. The same applies to any function producing vector-valued elements whose interpretation depends on the axis meaning (e.g. the Hessian matrix and the structure tensor). For example, the output of the Hessian is ordered as (dxx, dxy, dxz, dyy, dyz, dzz).</li>
</ul>
</div>
</div>
<div class="section" id="axistag-reference">
<h2><a class="toc-backref" href="#id73">Axistag Reference</a><a class="headerlink" href="#axistag-reference" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vigra.AxisType">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">AxisType</tt><a class="headerlink" href="#vigra.AxisType" title="Permalink to this definition">¶</a></dt>
<dd><p>Enum to encode the type of an axis described by an
<a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">AxisInfo</span></tt></a> object. Possible values:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">AxisType.Channels:</span></tt></dt>
<dd>a channel axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Space:</span></tt></dt>
<dd>a spatial axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Angle:</span></tt></dt>
<dd>an axis encoding angles (e.g. polar coordinates)</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Time:</span></tt></dt>
<dd>a temporal axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Frequency:</span></tt></dt>
<dd>an axis in the Fourier domain</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.UnknownAxisType:</span></tt></dt>
<dd>type not specified</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.NonChannel:</span></tt></dt>
<dd>any type except Channels</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.AllAxes:</span></tt></dt>
<dd>any type</dd>
</dl>
</div></blockquote>
<p>Types can be combined by the bitwise &#8216;or&#8217; operator. For example,
<tt class="docutils literal"><span class="pre">Space</span> <span class="pre">|</span> <span class="pre">Frequency</span></tt> denotes a spatial axis in the Fourier domain.</p>
</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.AxisInfo">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">AxisInfo</tt><a class="headerlink" href="#vigra.AxisInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>An object describing a single axis.</p>
<p>Constructor:</p>
<dl class="method">
<dt id="AxisInfo.AxisInfo">
<tt class="descname">AxisInfo</tt><big>(</big><em>key='?'</em>, <em>typeFlags=AxisType.UnknownAxisType</em>, <em>resolution=0.0</em>, <em>description=''</em><big>)</big><a class="headerlink" href="#AxisInfo.AxisInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>string</em>) &#8211; the key of the axis,
e.g. &#8216;x&#8217; (x-axis), &#8216;c&#8217; (channel axis), &#8216;?&#8217; (unknown)</li>
<li><strong>typeFlags</strong> (<a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">AxisType</span></tt></a>) &#8211; the type of the axis,
e.g. AxisType.Space or AxisType.Time</li>
<li><strong>resolution</strong> &#8211; the resolution (step size) of the axis
(e.g. 0.0 means &#8216;unknown&#8217;)</li>
<li><strong>description</strong> &#8211; an arbitrary string giving additional information 
about the axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>In addition, AxisInfo defines the following factories for the most common
cases:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">AxisInfo.c</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.c(description='a</span> <span class="pre">description')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;c&#8217; (channel) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.x</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.x(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;x&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.y</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.y(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;y&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.z</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.z(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;z&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.t</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.t(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;t&#8217; (time) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.fx</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.fx(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;x&#8217; axis
in the Fourier domain.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.fy</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.fy(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;y&#8217; axis
in the Fourier domain.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.fz</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.fz(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;z&#8217; axis
in the Fourier domain.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.ft</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.ft(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;t&#8217; axis
in the Fourier domain.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="vigra.AxisInfo.key">
<tt class="descname">key</tt><a class="headerlink" href="#vigra.AxisInfo.key" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type &#8216;string&#8217;) the key of the axis.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.typeFlags">
<tt class="descname">typeFlags</tt><a class="headerlink" href="#vigra.AxisInfo.typeFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type <a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">AxisType</span></tt></a>) the type of the axis .</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.resolution">
<tt class="descname">resolution</tt><a class="headerlink" href="#vigra.AxisInfo.resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>(read/write property, type &#8216;float&#8217;) the resolution of the axis. The resolution
will be automatically adjusted whenever the image size changes, e.g. due to a call
to <a class="reference internal" href="#vigra.sampling.resize" title="vigra.sampling.resize"><tt class="xref py py-func docutils literal"><span class="pre">resize()</span></tt></a> or slicing with non-unit step size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=1.2)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) RGB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">b</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=2)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=4.8)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) RGB</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.description">
<tt class="descname">description</tt><a class="headerlink" href="#vigra.AxisInfo.description" title="Permalink to this definition">¶</a></dt>
<dd><p>(read/write property, type &#8216;string&#8217;) the string description of the axis.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isSpatial">
<tt class="descname">isSpatial</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isSpatial" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isSSpactial() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Space</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isTemporal">
<tt class="descname">isTemporal</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isTemporal" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isTemporal() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Time</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isChannel">
<tt class="descname">isChannel</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isChannel() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Channels</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isFrequency">
<tt class="descname">isFrequency</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isFrequency() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Frequency</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isAngular">
<tt class="descname">isAngular</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isAngular" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isAngular() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Angle</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isType">
<tt class="descname">isType</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isType" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isType(axistype) yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains the given axistype.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.compatible">
<tt class="descname">compatible</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo1.compatible(axisinfo2) yields True when the two axisinfo objects have the same keys and types, or either of the two is &#8216;unknown&#8217;.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.AxisTags">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">AxisTags</tt><a class="headerlink" href="#vigra.AxisTags" title="Permalink to this definition">¶</a></dt>
<dd><p>Object to describe axis properties and axis ordering in a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a>.</p>
<p>Constructor:</p>
<dl class="method">
<dt id="AxisTags.AxisTags">
<tt class="descname">AxisTags</tt><big>(</big><em>i1=None</em>, <em>i2=None</em>, <em>i3=None</em>, <em>i4=None</em>, <em>i5=None</em><big>)</big><a class="headerlink" href="#AxisTags.AxisTags" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters &#8216;i1&#8217;...&#8217;i5&#8217; are the <a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">AxisInfo</span></tt></a> objects
describing the axes. If all are None, an empty AxisTags object is
created. Alternatively, &#8216;i1&#8217; can also be a Python sequence of
<a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">AxisInfo</span></tt></a> objects, or an integer (in which case an
AxisTags object with that many &#8216;?&#8217; entries is created).</p>
</dd></dl>

<p>Most AxisTags methods should not be called directly, but via the
corresponding array methods, because this ensures that arrays and
their axistags are always kept in sync (rule of thumb: if an axistags
function is not documented, you call it on your own risk).</p>
<p>The entries of an axistags object (i.e. the individual axisinfo objects)
can be accessed via the index operator, where the argument can either be
the axis index or the axis key:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1.2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1.2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=2)</span>
</pre></div>
</div>
<dl class="method">
<dt id="vigra.AxisTags.index">
<tt class="descname">index</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the axis index of a given axis key:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">axistags</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In this example, the &#8216;x&#8217;-axis corresponds to index 0 (i.e. the first index).</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisTags.channelIndex">
<tt class="descname">channelIndex</tt><a class="headerlink" href="#vigra.AxisTags.channelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type &#8216;int&#8217;) the index of the channel axis, or <tt class="docutils literal"><span class="pre">len(axistags)</span></tt>
when no channel axis exists (i.e. <tt class="docutils literal"><span class="pre">axistags.channelIndex</span></tt> is similar to
<tt class="docutils literal"><span class="pre">axistags.index('c')</span></tt>, but doesn&#8217;t throw an exception when there
is no &#8216;c&#8217; axis.)</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisTags.innerNonchannelIndex">
<tt class="descname">innerNonchannelIndex</tt><a class="headerlink" href="#vigra.AxisTags.innerNonchannelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type &#8216;int&#8217;) the index of the innermost non-channel axis.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisTags.axisTypeCount">
<tt class="descname">axisTypeCount</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.axisTypeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>How many axes of the given type(s) are in this axistags object?:</p>
<div class="highlight-python"><pre>axistags.axisTypeCount(types) -&gt; int</pre>
</div>
<p>The &#8216;types&#8217; of the query must be single <a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">AxisType</span></tt></a> instances
or a combination of them. Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="s">&#39;txyc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Space</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Space</span> <span class="o">|</span> <span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Time</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">NonChannel</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisTags.setChannelDescription">
<tt class="descname">setChannelDescription</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.setChannelDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a description for the channel axis, if one exists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">axistags</span><span class="o">.</span><span class="n">setChannelDescription</span><span class="p">(</span><span class="s">&#39;colors are in Lab color space&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It is similar to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">&#39;colors are in Lab color space&#39;</span>
</pre></div>
</div>
<p>except when the axistags contain no channel axis, in which case
setChannelDescription() is simply ignored, whereas axistags[&#8216;c&#8217;]
would cause an exception.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisTags.toJSON">
<tt class="descname">toJSON</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.toJSON" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a string representation of this axistags in JSON format.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="vigra.AxisTags.fromJSON">
<em class="property">static </em><tt class="descname">fromJSON</tt><big>(</big><em>json_rep</em><big>)</big><a class="headerlink" href="#vigra.AxisTags.fromJSON" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new AxisTags object from the given JSON representation.
This is mainly used to reconstruct arrays from HDF5 datasets with
a suitable axistags attribute (see <a class="reference internal" href="#vigra.impex.readHDF5" title="vigra.impex.readHDF5"><tt class="xref py py-func docutils literal"><span class="pre">readHDF5()</span></tt></a>).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="vigraarray-reference">
<h2><a class="toc-backref" href="#id74">VigraArray Reference</a><a class="headerlink" href="#vigraarray-reference" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vigra.VigraArray">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">VigraArray</tt><a class="headerlink" href="#vigra.VigraArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt></p>
<p>This class extends numpy.ndarray with the concept of <strong>axistags</strong> 
which encode the semantics of the array&#8217;s axes. VigraArray overrides all
numpy.ndarray methods in order to handle axistags in a sensible way.
In particular, operations acting on two arrays simultaneously (e.g.
addition) will first transpose the arguments such that their axis 
ordering matches.</p>
<p>Constructor:</p>
<dl class="method">
<dt id="VigraArray.VigraArray">
<tt class="descname">VigraArray</tt><big>(</big><em>obj</em>, <em>dtype=numpy.float32</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#VigraArray.VigraArray" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> &#8211; an array or shape object (see below)</li>
<li><strong>dtype</strong> &#8211; desired element type</li>
<li><strong>order</strong> &#8211; desired memory layout (see below)</li>
<li><strong>init</strong> (<em>boolean</em>) &#8211; True: initialize the image with zeros; False: do not 
initialize the image</li>
<li><strong>value</strong> (<em>convertible to dtype</em>) &#8211; initialize the image with this value (overrides init)</li>
<li><strong>axistags</strong> &#8211; the AxisTags object of the new array. The length of 
axistags must match the array&#8217;s shape. It axistags=None, 
obj.axistags is used if it exists. Otherwise, a new 
axistags object is created by a call to 
<a class="reference internal" href="#vigra.VigraArray.defaultAxistags" title="vigra.VigraArray.defaultAxistags"><tt class="xref py py-meth docutils literal"><span class="pre">defaultAxistags()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>obj</strong> may be one of the following</p>
<ul class="simple">
<li>If obj is a numpy.ndarray or a subtype, a copy of obj with the given 
dtype, order and resulting class VigraArray is created. If obj.axistags
exists, the new array will have these axistags as well, unless new
axistags are explicitly passed to the constructor.</li>
<li>If obj is a sequence, it is interpreted as a shape.</li>
<li>Otherwise, or if shape and axistags are incompatible, an exception
is raised.</li>
</ul>
<p><strong>order</strong> can be &#8216;C&#8217; (C order), &#8216;F&#8217; (Fortran order), &#8216;V&#8217; (VIGRA
order), &#8216;A&#8217; (any), or None. This parameter controls the order of strides 
and axistags (unless axistags are explicit passed into the constructor). 
See the <a class="reference internal" href="#array-order-parameter"><em>order definitions</em></a> for details. If 
&#8216;order=None&#8217;, the order is determined by <a class="reference internal" href="#VigraArray.defaultOrder" title="VigraArray.defaultOrder"><tt class="xref py py-attr docutils literal"><span class="pre">VigraArray.defaultOrder</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="VigraArray.axistags">
<tt class="descname">axistags</tt><a class="headerlink" href="#VigraArray.axistags" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">AxisTags</span></tt></a> object of this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="VigraArray.defaultOrder">
<tt class="descname">defaultOrder</tt><a class="headerlink" href="#VigraArray.defaultOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the default axis ordering, currently &#8216;V&#8217; (<a class="reference internal" href="#array-order-parameter"><em>VIGRA order</em></a>).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="vigra.VigraArray.defaultAxistags">
<em class="property">static </em><tt class="descname">defaultAxistags</tt><big>(</big><em>tagSpec</em>, <em>order=None</em>, <em>noChannels=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.defaultAxistags" title="Permalink to this definition">¶</a></dt>
<dd><p>Get default axistags for the given specification &#8216;tagSpec&#8217;. TagSpec can be the 
number of dimensions of the array (<tt class="docutils literal"><span class="pre">array.ndim</span></tt>, must be &lt;= 5) or a string 
containing a sequence of axis keys (only the default keys &#8216;x&#8217;, &#8216;y&#8217;, &#8216;z&#8217;, &#8216;t&#8217;, 
and &#8216;c&#8217; are currently supported). The &#8216;order&#8217; parameter determines the axis 
ordering, see the <a class="reference internal" href="#array-order-parameter"><em>order definitions</em></a> for details.
If &#8216;noChannels&#8217; is True, there will be no channel axis. Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x y z c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">x y z t c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="go">y x c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x y z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x y z t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="s">&#39;xty&#39;</span><span class="p">)</span>
<span class="go">x t y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="s">&#39;xty&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;V&#39;</span><span class="p">)</span>
<span class="go">x y t</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.channelIndex">
<tt class="descname">channelIndex</tt><a class="headerlink" href="#vigra.VigraArray.channelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the channel axis according to the axistags.        
For example, when axistags are &#8216;x y c&#8217;, the channel index is 2. 
If the axistags contain no channel axis, self.ndim is returned.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.innerNonchannelIndex">
<tt class="descname">innerNonchannelIndex</tt><a class="headerlink" href="#vigra.VigraArray.innerNonchannelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the innermost non-channel axis according to the axistags.
The innermost axis is determined by the AxisInfo sorting rules (see 
the <a class="reference internal" href="#array-order-parameter"><em>order definitions</em></a> for details).
For example, when axistags are &#8216;x y c&#8217;, the innerNonchannelIndex is 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.channels">
<tt class="descname">channels</tt><a class="headerlink" href="#vigra.VigraArray.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of channels in this array (shape of the &#8216;c&#8217; axis).
If the axistags contain no channel axis, the number of channels is implicitly 1.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.spatialDimensions">
<tt class="descname">spatialDimensions</tt><a class="headerlink" href="#vigra.VigraArray.spatialDimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of spatial axes in the array.
That is, the number of entries in the axistags where the flag &#8216;AxisType.Space&#8217;
is set.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.width">
<tt class="descname">width</tt><a class="headerlink" href="#vigra.VigraArray.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the array (shape of the &#8216;x&#8217; axis).
If the axistags contain no &#8216;x&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.height">
<tt class="descname">height</tt><a class="headerlink" href="#vigra.VigraArray.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the array (shape of the &#8216;y&#8217; axis).
If the axistags contain no &#8216;y&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.depth">
<tt class="descname">depth</tt><a class="headerlink" href="#vigra.VigraArray.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of the array (shape of the &#8216;z&#8217; axis).
If the axistags contain no &#8216;z&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.duration">
<tt class="descname">duration</tt><a class="headerlink" href="#vigra.VigraArray.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of time steps in the array (shape of the &#8216;t&#8217; axis).
If the axistags contain no &#8216;t&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.dropChannelAxis">
<tt class="descname">dropChannelAxis</tt><big>(</big><em>ignoreMultiChannel=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.dropChannelAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop the channel axis when it is a singleton.
This function is for easy transformation of an array shaped 
(width, height, 1) into (width, height). A RuntimeError
is raised when there is more than one channel, unless ignoreMultiChannel=True,
in which case &#8216;self&#8217; is returned.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.insertChannelAxis">
<tt class="descname">insertChannelAxis</tt><big>(</big><em>order=None</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.insertChannelAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a singleton channel axis.
This function is for easy transformation of an array shaped 
(width, height) into (width, height, 1). The &#8216;order&#8217; parameter
determines the position of the new axis: when order is &#8216;F&#8217;, it
will become the first axis, otherwise it will become the last
one. A RuntimeError is raised when the array already contains a
channel axis.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.withAxes">
<tt class="descname">withAxes</tt><big>(</big><em>*axiskeys</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.withAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a view containing the desired axis keys in the given  
order. When the array contains an axis not listed, the axis
will be dropped if it is a singfleton (otherwise, an exception
is raised). If a requested key is not present in this array,
a singleton axis will be inserted at that position, if the 
missing key is among the known standard keys (otherwise, an 
exception is raised). The function fails if this array contains
axes of unknown type (key &#8216;?&#8217;). If &#8216;self&#8217; is already suitable, 
it is simply retured without generating a new view.</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarVolume</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(200, 100)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">y x c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 200, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.view5D">
<tt class="descname">view5D</tt><big>(</big><em>order='C'</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.view5D" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 5-dimensional view containing the standard tags 
&#8216;x&#8217;, &#8216;y&#8217;, &#8216;z&#8217;, &#8216;t&#8217;, &#8216;c&#8217; in the desired &#8216;order&#8217; (which can be 
&#8216;C&#8217;, &#8216;F&#8217;, and &#8216;V&#8217; with the usual meaning). If &#8216;self&#8217; has an 
axis key that is not among the five admissible keys, an 
exception is raised. Axes missing in &#8216;self&#8217; are added as 
singleton axes with the appropriate tags.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.asRGB">
<tt class="descname">asRGB</tt><big>(</big><em>normalize=True</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.asRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a scalar array (i.e. an array with a single channel) into an RGB array with
three identical color channels. This is useful when you want to paste color
annotations (e.g. user labels) into the array.</p>
<p>The parameter <cite>normalize</cite> can be used to normalize the array&#8217;s
value range to 0..255:</p>
<dl class="docutils">
<dt><cite>normalize</cite> = (nmin, nmax):</dt>
<dd>scale &amp; clip array values from nmin..nmax to 0..255</dd>
<dt><cite>normalize</cite> = True: (default)</dt>
<dd>scale the array&#8217;s actual range min()..max() to 0..255</dd>
<dt><cite>normalize</cite> = False:</dt>
<dd>don&#8217;t scale the array&#8217;s values</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">array.__getitem__(index)</span></tt> implements the indexing operator <tt class="docutils literal"><span class="pre">array[index]</span></tt>.
In addition to the usual numpy.ndarray indexing functionality, this function
also updates the axistags of the result array. There are three cases:</p>
<blockquote>
<div><ul class="simple">
<li>getitem creates a scalar value =&gt; no axistags are required</li>
<li>getitem creates an array view =&gt; axistags are transferred from the
corresponding axes of the base array</li>
<li>getitem creates a copy of an array (fancy indexing) =&gt; all axistags are &#8216;?&#8217;</li>
</ul>
</div></blockquote>
<p>If the index contains &#8216;numpy.newaxis&#8217;, a new singleton axis is inserted at the 
appropriate position, whose axisinfo is set to &#8216;?&#8217; (unknown). If the index contains
&#8216;vigra.newaxis(axisinfo)&#8217;, the singleton axis will get the given axisinfo.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.subarray">
<tt class="descname">subarray</tt><big>(</big><em>p1</em>, <em>p2=None</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.subarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a subarray view from a pair of points. The first point denotes the start
of the subarray (inclusive), the second its end (exclusive). For example,</p>
<blockquote>
<div>a.subarray((1,2,3), (4,5,6))  # equivalent to a[1:4, 2:5, 3:6]</div></blockquote>
<p>The given points must have the same dimension, otherwise an IndexError is raised. 
If only one point is given, it refers to the subarray&#8217;s end, and the start is set 
to the point (0, 0, ...) with appropriate dimension, for example</p>
<blockquote>
<div>a.subarray((4,5,6))           # equivalent to a[:4, :5, :6]</div></blockquote>
<p>The function transforms the given point pair into a tuple of slices and calls 
self.__getitem__() in it. If the points have lower dimension than the array, an 
Ellipsis (&#8216;...&#8217;) is implicitly appended to the slicing, so that missing axes 
are left unaltered.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.bindAxis">
<tt class="descname">bindAxis</tt><big>(</big><em>which</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.bindAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the axis identified by &#8216;which&#8217; to the given &#8216;index&#8217;.
This is similar to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">array</span><span class="p">[:,</span> <span class="n">index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>but you do not need to know the position of the axis when you use the 
axis key (according to axistags). For example, to get the green channel
of an RGBImage, you write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">green</span> <span class="o">=</span> <span class="n">rgb</span><span class="o">.</span><span class="n">bindAxis</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This gives the correct result irrespective of the axis ordering.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.channelIter">
<tt class="descname">channelIter</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.channelIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over the channels of the array.
In each iteration, you get the array corresponding to a single channel.
If the axistags contain no channel axis, there is only one iteration
which yields the entire array. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">rgb</span><span class="o">.</span><span class="n">channelIter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(200, 100)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.sliceIter">
<tt class="descname">sliceIter</tt><big>(</big><em>key='z'</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.sliceIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over a single spatial axis of the array.
In each iteration, you get the array corresponding to one coordinate
along the axis given by &#8216;key&#8217;. For example, to iterate along the z-axis
to get all x-y-slices in turn, you write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">Volume</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="nb">slice</span> <span class="ow">in</span> <span class="n">volume</span><span class="o">.</span><span class="n">sliceIter</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">processSlice</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.spaceIter">
<tt class="descname">spaceIter</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.spaceIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over all the spatial coordinates in the array.
In each iteration, you get the value corresponding to a single 
coordinate location. If the axistags contain no spatial axes, 
there is only one iteration which yields the entire array. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarImage</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">spaceIter</span><span class="p">():</span>
<span class="go">....    print p</span>
<span class="go">0.0</span>
<span class="go">1.0</span>
<span class="go">2.0</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.timeIter">
<tt class="descname">timeIter</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.timeIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over the time points of the array.
In each iteration, you get the array corresponding to a single time point.
If the axistags contain no time axis, there is only one iteration
which yields the entire array. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">vigra</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axistags</span> <span class="o">=</span> <span class="n">AxisTags</span><span class="p">(</span><span class="n">AxisInfo</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">AxisInfo</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">AxisInfo</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timesteps</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_sequence</span> <span class="o">=</span> <span class="n">Image</span><span class="p">((</span><span class="n">timesteps</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">axistags</span><span class="o">=</span><span class="n">axistags</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">step1</span><span class="p">,</span> <span class="n">step2</span> <span class="o">=</span> <span class="n">image_sequence</span><span class="o">.</span><span class="n">timeIter</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.copyValues">
<tt class="descname">copyValues</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.copyValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of an array to another one. This is similar to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span>
</pre></div>
</div>
<p>but will first transpose both arrays so that axistags are aligned. If
there is no valid alignment, RuntimeError will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.swapaxes">
<tt class="descname">swapaxes</tt><big>(</big><em>axis1</em>, <em>axis2</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p>
<p>Refer to <cite>numpy.swapaxes</cite> for full documentation.</p>
<p>numpy.swapaxes : equivalent function</p>
<blockquote>
<div><p>Parameters &#8216;i&#8217; and &#8216;j&#8217; can also be ints (axis positions) or strings (axis keys).</p>
<p>If &#8216;keepsTags&#8217; is False, axistags are swapped like the axes, otherwise they remain
unchanged such that the swapped axes aquire a new meaning.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transpose">
<tt class="descname">transpose</tt><big>(</big><em>*axes</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array, this has no effect. (To change between column and
row vectors, first cast the 1-D array into a matrix object.)
For a 2-D array, this is the usual matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<tt class="docutils literal"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...</span> <span class="pre">i[n-2],</span> <span class="pre">i[n-1])</span></tt>, then
<tt class="docutils literal"><span class="pre">a.transpose().shape</span> <span class="pre">=</span> <span class="pre">(i[n-1],</span> <span class="pre">i[n-2],</span> <span class="pre">...</span> <span class="pre">i[1],</span> <span class="pre">i[0])</span></tt>.</p>
<p>axes : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li>None or no argument: reverses the order of the axes.</li>
<li>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>&#8216;s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>&#8216;s <cite>j</cite>-th axis.</li>
<li><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a &#8220;convenience&#8221; alternative to the tuple form)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>View of <cite>a</cite>, with axes suitably permuted.</dd>
</dl>
<p>ndarray.T : Array property returning the array transposed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
</pre></div>
</div>
<blockquote>
<div>An additional keyword parameter &#8216;keepTags&#8217; can be provided (it has to be passed as an explicit
keyword parameter). If it is True, the axistags will remain unchanged such that the transposed 
axes aquire a new meaning.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.T">
<tt class="descname">T</tt><a class="headerlink" href="#vigra.VigraArray.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transpose()</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToOrder">
<tt class="descname">transposeToOrder</tt><big>(</big><em>order</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transposed view onto this array according to the given &#8216;order&#8217;.
Possible orders are:</p>
<dl class="docutils">
<dt>&#8216;A&#8217;:</dt>
<dd>return the array unchanged</dd>
<dt>&#8216;C&#8217;:</dt>
<dd>transpose to descending axis order (e.g. &#8216;z y x c&#8217;)</dd>
<dt>&#8216;F&#8217;:</dt>
<dd>transpose to ascending axis order (e.g. &#8216;c x y z&#8217;)</dd>
<dt>&#8216;V&#8217;:</dt>
<dd>transpose to VIGRA order, i.e. ascending spatial axes, but
the channel axis is last (e.g. &#8216;x y z c&#8217;)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToDefaultOrder">
<tt class="descname">transposeToDefaultOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToDefaultOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(VigraArray.defaultOrder).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToNormalOrder">
<tt class="descname">transposeToNormalOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToNormalOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(&#8216;F&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToNumpyOrder">
<tt class="descname">transposeToNumpyOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToNumpyOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(&#8216;C&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToVigraOrder">
<tt class="descname">transposeToVigraOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToVigraOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(&#8216;V&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToOrder">
<tt class="descname">permutationToOrder</tt><big>(</big><em>order</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array into
an array view with the given order (where order can be &#8216;A&#8217;,
&#8216;C&#8217;, &#8216;F&#8217;, &#8216;V&#8217; with the usual meaning).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToNormalOrder">
<tt class="descname">permutationToNormalOrder</tt><big>(</big><em>types=vigra.vigranumpycore.AxisType.AllAxes</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToNormalOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array to 
normal order (that is, from the current axis order into 
ascending order, e.g. &#8216;x y c&#8217; into &#8216;c x y&#8217;). 
If &#8216;types&#8217; is not &#8216;AxisType.AllAxes&#8217;, only the axes with the
desired types are considered.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationFromNormalOrder">
<tt class="descname">permutationFromNormalOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationFromNormalOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose an array that is 
in normal (ascending) order into the axis order of this array.
(e.g. &#8216;c x y&#8217; into &#8216;x y c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToNumpyOrder">
<tt class="descname">permutationToNumpyOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToNumpyOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array to 
numpy order (that is, from the current axis order into 
descending order, e.g. &#8216;x y c&#8217; into &#8216;y x c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationFromNumpyOrder">
<tt class="descname">permutationFromNumpyOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationFromNumpyOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose an array that is 
in numpy (descending) order into the axis order of this array.
(e.g.  &#8216;y x c&#8217; into &#8216;x y c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToVigraOrder">
<tt class="descname">permutationToVigraOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToVigraOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array to 
VIGRA order (that is, from the current axis order into 
ascending spatial order, but with the channel axis at the 
last position, e.g. &#8216;c x y&#8217; into &#8216;x y c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationFromVigraOrder">
<tt class="descname">permutationFromVigraOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationFromVigraOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose an array that is 
in VIGRA order (ascending spatial order, but with the channel 
axis at the last position) into the axis order of this array.
(e.g.  &#8216;x y c&#8217; into &#8216;c x y&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.writeHDF5">
<tt class="descname">writeHDF5</tt><big>(</big><em>filenameOurGroup</em>, <em>pathInFile</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.writeHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the array to a HDF5 file. 
This is just a shortcut for <a class="reference internal" href="#vigra.impex.writeHDF5" title="vigra.impex.writeHDF5"><tt class="xref py py-func docutils literal"><span class="pre">vigra.impex.writeHDF5()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.writeImage">
<tt class="descname">writeImage</tt><big>(</big><em>filename</em>, <em>dtype=''</em>, <em>compression=''</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.writeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image to a file. 
Consult <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">vigra.impex.writeImage()</span></tt></a> for detailed documentation</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.writeSlices">
<tt class="descname">writeSlices</tt><big>(</big><em>filename_base</em>, <em>filename_ext</em>, <em>dtype=''</em>, <em>compression=''</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.writeSlices" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a volume to a sequence of files.         
Consult <a class="reference internal" href="#vigra.impex.writeVolume" title="vigra.impex.writeVolume"><tt class="xref py py-func docutils literal"><span class="pre">vigra.impex.writeVolume()</span></tt></a> for detailed documentation.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="vigra.VigraArray.receiveSocket">
<em class="property">static </em><tt class="descname">receiveSocket</tt><big>(</big><em>socket</em>, <em>flags=0</em>, <em>copy=True</em>, <em>track=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.receiveSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct an array that has been transferred via a ZMQ socket by a call to 
VigraArray.sendSocket(). This only works when the &#8216;zmq&#8217; module is available.
The meaning of the arguments is described in zmq.Socket.recv().</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.sendSocket">
<tt class="descname">sendSocket</tt><big>(</big><em>socket</em>, <em>flags=0</em>, <em>copy=True</em>, <em>track=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.sendSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>Send array and metadata over a ZMQ socket. Only works if the &#8216;zmq&#8217; module is available.
The meaning of the arguments is described in zmq.Socket.send().</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.qimage">
<tt class="descname">qimage</tt><big>(</big><em>normalize=True</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.qimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this image to a Qt QImage (mainly for display purposes).
The present image must have 1, 2, 3, or 4 channels, and the resulting
QImage will have QImage.Format_Indexed8 iff there was only one
channel and QImage.Format_[A]RGB32 otherwise (with the last of
2/4 channels being used as alpha channel).</p>
<p>The parameter <cite>normalize</cite> can be used to normalize an image&#8217;s
value range to 0..255:</p>
<dl class="docutils">
<dt><cite>normalize</cite> = (nmin, nmax):</dt>
<dd>scale &amp; clip image values from nmin..nmax to 0..255</dd>
<dt><cite>normalize</cite> = nmax:</dt>
<dd>lets nmin default to zero, i.e. scale &amp; clip the range 0..nmax
to 0..255</dd>
<dt><cite>normalize</cite> = True: (default)</dt>
<dd>scale the image&#8217;s actual range min()..max() to 0..255</dd>
<dt><cite>normalize</cite> = False:</dt>
<dd>don&#8217;t scale the image&#8217;s values</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.show">
<tt class="descname">show</tt><big>(</big><em>normalize=True</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display this image in a vigra.pyqt.ImageWindow.</p>
<p>The channels are intepreted as follows: 1 channel = gray image, 
2 channels = gray + alpha, 3 channels = RGB, 4 channels = RGB + alpha.</p>
<p>The parameter <cite>normalize</cite> can be used to normalize an image&#8217;s
value range to 0..255:</p>
<dl class="docutils">
<dt><cite>normalize</cite> = (nmin, nmax):</dt>
<dd>scale &amp; clip image values from nmin..nmax to 0..255</dd>
<dt><cite>normalize</cite> = nmax:</dt>
<dd>lets nmin default to zero, i.e. scale &amp; clip the range 0..nmax
to 0..255</dd>
<dt><cite>normalize</cite> = True: (default)</dt>
<dd>scale the image&#8217;s actual range min()..max() to 0..255</dd>
<dt><cite>normalize</cite> = False:</dt>
<dd>don&#8217;t scale the image&#8217;s values</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="vigra.newaxis">
<tt class="descclassname">vigra.</tt><tt class="descname">newaxis</tt><big>(</big><em>axisinfo=vigra.AxisInfo()</em><big>)</big><a class="headerlink" href="#vigra.newaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new singleton axis via the indexing operator. This works similar to 
<cite>numpy.newaxis</cite>, but allows to provide an AxisInfo object for the new axis. 
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">axistags</span>  <span class="c"># no channel axis</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">axistags</span>  <span class="c"># with unknown axis type</span>
<span class="go">x y ?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">vigra</span><span class="o">.</span><span class="n">newaxis</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisInfo</span><span class="o">.</span><span class="n">c</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">axistags</span>  <span class="c"># with channel axis </span>
<span class="go">x y c</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.taggedView">
<tt class="descclassname">vigra.</tt><tt class="descname">taggedView</tt><big>(</big><em>array</em>, <em>axistags</em><big>)</big><a class="headerlink" href="#vigra.taggedView" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a view to the given array with type <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> and the 
given axistags. This is essentially a shorthand for:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">axistags</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axistags</span><span class="p">)</span>
</pre></div>
</div>
<p>if axistags is an instance of AxisTags. Otherwise, the function first attempts
to convert the input to that type by calling VigraArray.defaultAxistags()</p>
</dd></dl>

<dl class="function">
<dt id="vigra.dropChannelAxis">
<tt class="descclassname">vigra.</tt><tt class="descname">dropChannelAxis</tt><big>(</big><em>array</em><big>)</big><a class="headerlink" href="#vigra.dropChannelAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the view created by <tt class="docutils literal"><span class="pre">array.</span></tt><a class="reference internal" href="#vigra.VigraArray.dropChannelAxis" title="vigra.VigraArray.dropChannelAxis"><tt class="xref py py-meth docutils literal"><span class="pre">dropChannelAxis()</span></tt></a> if 
the given array supports that function, or return <tt class="docutils literal"><span class="pre">array</span></tt> unchanged otherwise.</p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="subsec-array-factories"></span><dl class="function">
<dt id="vigra.Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing an image (i.e. an array with 
two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and optionally a channel axis &#8216;c&#8217;). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are not image-like.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ScalarImage">
<tt class="descclassname">vigra.</tt><tt class="descname">ScalarImage</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.ScalarImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a single-band image (i.e. an 
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and no channel axis). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a single-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector2Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector2Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector2Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 2-band image (i.e. an 
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 2 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 2-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector3Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector3Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector3Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 3-band image (i.e. an 
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 3 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 3-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector4Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector4Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector4Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 4-band image (i.e. an 
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 4 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 4-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.RGBImage">
<tt class="descclassname">vigra.</tt><tt class="descname">RGBImage</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.RGBImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a RGB image (i.e. an 
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 3 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for an RGB image.</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="vigra.Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a volume (i.e. an array with 
three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and optionally a channel axis &#8216;c&#8217;). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are not volume-like.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ScalarVolume">
<tt class="descclassname">vigra.</tt><tt class="descname">ScalarVolume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.ScalarVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a single-band volume (i.e. an 
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and no channel axis). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a single-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector2Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector2Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector2Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 2-band volume (i.e. an 
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 2 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 2-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector3Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector3Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector3Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 3-band volume (i.e. an 
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 3 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 3-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector4Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector4Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector4Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 4-band volume (i.e. an 
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 4 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 4-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector6Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector6Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector6Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 6-band volume (i.e. an 
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 6 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 6-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.RGBVolume">
<tt class="descclassname">vigra.</tt><tt class="descname">RGBVolume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.RGBVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing an RGB volume (i.e. an 
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 3 channels). 
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for an RGB volume.</p>
</dd></dl>

</div>
<div class="section" id="import-and-export-functions">
<h2><a class="toc-backref" href="#id75">Import and Export Functions</a><a class="headerlink" href="#import-and-export-functions" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.impex defines read and write functions for image and volume data. Note
that the contents of this module are automatically imported into the vigra module, so
you may call &#8216;vigra.readImage(...)&#8217; instead of &#8216;vigra.impex.readImage(...)&#8217; etc.</p>
<span class="target" id="module-vigra.impex"></span><dl class="function">
<dt id="vigra.impex.isImage">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">isImage</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.isImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the given file name contains image data:</p>
<div class="highlight-python"><pre>isImage(filename) -&gt; bool</pre>
</div>
<p>This function tests whether a file has a supported image format. It checks the first few bytes of the file and compares them with the &#8220;magic strings&#8221; of each recognized image format. If the image format is supported it returns True otherwise False.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.listExtensions">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">listExtensions</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.listExtensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask for the image file extensions that vigra.impex understands:</p>
<div class="highlight-python"><pre>listExtensions() -&gt; string</pre>
</div>
<p>This function returns a string containing the supported image file extensions for reading and writing with the functions <a class="reference internal" href="#vigra.impex.readImage" title="vigra.impex.readImage"><tt class="xref py py-func docutils literal"><span class="pre">readImage()</span></tt></a> and <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">writeImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.listFormats">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">listFormats</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.listFormats" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask for the image file formats that vigra.impex understands:</p>
<div class="highlight-python"><pre>listFormats() -&gt; string</pre>
</div>
<p>This function returns a string containing the supported image file formats for reading and writing with the functions <a class="reference internal" href="#vigra.impex.readImage" title="vigra.impex.readImage"><tt class="xref py py-func docutils literal"><span class="pre">readImage()</span></tt></a> and <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">writeImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.numberImages">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">numberImages</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.numberImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Check how many images the given file contains:</p>
<div class="highlight-python"><pre>numberImages(filename) -&gt; int</pre>
</div>
<p>This function tests how many images an image file contains(Values &gt; 1 are only expected for the TIFF format to support multi-image TIFF).</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.readHDF5">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">readHDF5</tt><big>(</big><em>filenameOrGroup</em>, <em>pathInFile</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#vigra.impex.readHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an array from an HDF5 file.</p>
<p>&#8216;filenameOrGroup&#8217; can contain a filename or a group object
referring to an already open HDF5 file. &#8216;pathInFile&#8217; is the name 
of the dataset to be read, including intermediate groups. If the 
first argument is a group object, the path is relative to this 
group, otherwise it is relative to the file&#8217;s root group.</p>
<p>If the dataset has an attribute &#8216;axistags&#8217;, the returned array
will have type <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> and will be transposed 
into the given &#8216;order&#8217; (&#8216;vigra.VigraArray.defaultOrder&#8217;
will be used if no order is given).  Otherwise, the returned 
array is a plain &#8216;numpy.ndarray&#8217;. In this case, order=&#8217;F&#8217; will 
return the array transposed into Fortran order.</p>
<p>Requirements: the &#8216;h5py&#8217; module must be installed.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.readImage">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">readImage</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.readImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an image from a file:</p>
<div class="highlight-python"><pre>readImage(filename, dtype='FLOAT', index=0, order='') -&gt; Image</pre>
</div>
<p>When &#8216;dtype&#8217; is &#8216;UINT8&#8217;, &#8216;INT16&#8217;, &#8216;UINT16&#8217;, &#8216;INT32&#8217;, &#8216;UINT32&#8217;,
&#8216;FLOAT&#8217;, &#8216;DOUBLE&#8217;, or one of the corresponding numpy dtypes (numpy.uint8
etc.), the returned image will have the requested pixel type. If
dtype is &#8216;NATIVE&#8217; or &#8216;&#8217; (empty string), the image is imported with
the original type of the data in the file. By default, image data are
returned as &#8216;FLOAT&#8217; (i.e. numpy.float32). Caution: If the requested 
dtype is smaller than the original type in the file, values will be
clipped at the bounds of the representable range, which may not be the
desired behavior.</p>
<p>Individual images of sequential formats such as multi-image TIFF can be 
accessed via &#8216;index&#8217;. The number of images in a file can be checked with the 
function <a class="reference internal" href="#vigra.impex.numberImages" title="vigra.impex.numberImages"><tt class="xref py py-func docutils literal"><span class="pre">numberImages()</span></tt></a>. Alternatively, <a class="reference internal" href="#vigra.impex.readVolume" title="vigra.impex.readVolume"><tt class="xref py py-func docutils literal"><span class="pre">readVolume()</span></tt></a> can read 
an entire multi-page TIFF in one go.</p>
<p>The &#8216;order&#8217; parameter determines the axis ordering of the resulting array
(allowed values: &#8216;C&#8217;, &#8216;F&#8217;, &#8216;V&#8217;). When order == &#8216;&#8217; (the default), 
&#8216;vigra.VigraArray.defaultOrder&#8217; is used.</p>
<p>Supported file formats are listed by the function <a class="reference internal" href="#vigra.impex.listFormats" title="vigra.impex.listFormats"><tt class="xref py py-func docutils literal"><span class="pre">listFormats()</span></tt></a>.
When &#8216;filename&#8217; does not refer to a recognized image file format, an
exception is raised. The file can be checked beforehand with the function
<a class="reference internal" href="#vigra.impex.isImage" title="vigra.impex.isImage"><tt class="xref py py-func docutils literal"><span class="pre">isImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.readVolume">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">readVolume</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.readVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a 3D volume from a directory:</p>
<div class="highlight-python"><pre>readVolume(filename, dtype='FLOAT', order='') -&gt; Volume</pre>
</div>
<p>If the filename refers to a multi-page TIFF file, the images in the file are
interpreted as the z-slices of the volume.</p>
<p>If the volume is stored in a by-slice manner (e.g. one file per
z-slice), the &#8216;filename&#8217; can refer to an arbitrary image from the set.
readVolume() then assumes that the slices are enumerated like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">name_base</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="n">name_ext</span>
</pre></div>
</div>
<p>where name_base, the index, and name_ext
are determined automatically. All slice files with the same name base
and extension are considered part of the same volume. Slice numbers
must be non-negative, but can otherwise start anywhere and need not
be successive. Slices will be read in ascending numerical (not
lexicographic) order. All slices must have the same size.</p>
<p>Otherwise, readVolume() will try to read &#8216;filename&#8217; as an info text
file with the following key-value pairs:</p>
<div class="highlight-python"><pre>name = [short descriptive name of the volume] (optional)
filename = [absolute or relative path to raw voxel data file] (required)
gradfile =  [abs. or rel. path to gradient data file] (currently ignored)
description =  [arbitrary description of the data set] (optional)
width = [positive integer] (required)
height = [positive integer] (required)
depth = [positive integer] (required)
datatype = [UNSIGNED_CHAR | UNSIGNED_BYTE] (default: UNSIGNED_CHAR)</pre>
</div>
<p>Lines starting with # are ignored.
When import_type is &#8216;UINT8&#8217;, &#8216;INT16&#8217;, &#8216;UINT16&#8217;, &#8216;INT32&#8217;, &#8216;UINT32&#8217;,
&#8216;FLOAT&#8217;, &#8216;DOUBLE&#8217;, or one of the corresponding numpy dtypes (numpy.uint8
etc.), the returned volume will have the requested pixel type.</p>
<p>The order parameter determines the axis ordering of the resulting array
(allowed values: &#8216;C&#8217;, &#8216;F&#8217;, &#8216;V&#8217;). When order == &#8216;&#8217; (the default), vigra.VigraArray.defaultOrder is used.</p>
<p>For details see the help for <a class="reference internal" href="#vigra.impex.readImage" title="vigra.impex.readImage"><tt class="xref py py-func docutils literal"><span class="pre">readImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.writeHDF5">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">writeHDF5</tt><big>(</big><em>data</em>, <em>filenameOrGroup</em>, <em>pathInFile</em>, <em>compression=None</em><big>)</big><a class="headerlink" href="#vigra.impex.writeHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an array to an HDF5 file.</p>
<p>&#8216;filenameOrGroup&#8217; can contain a filename or a group object
referring to an already open HDF5 file. &#8216;pathInFile&#8217; is the name of the
dataset to be written, including intermediate groups. If the first
argument is a group object, the path is relative to this group,
otherwise it is relative to the file&#8217;s root group. If the dataset already
exists, it will be replaced without warning.</p>
<p>If &#8216;data&#8217; has an attribute &#8216;axistags&#8217;, the array is transposed to
numpy order before writing. Moreover, the axistags will be
stored along with the data in an attribute &#8216;axistags&#8217;.</p>
<p>&#8216;compression&#8217; can be set to &#8216;gzip&#8217;, &#8216;szip&#8217; or &#8216;lzf&#8217;
gzip (standard compression),
szip (available if HDF5 is compiled with szip. Faster compression, limited types),
lzf (very fast compression, all types).
The &#8216;lzf&#8217; compression filter is many times faster than &#8216;gzip&#8217; 
at the cost of a lower compresion ratio.</p>
<p>Requirements: the &#8216;h5py&#8217; module must be installed.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.writeImage">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">writeImage</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.writeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an image to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">writeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>image:</dt>
<dd>the image to be saved</dd>
<dt>filename:</dt>
<dd>the file name to save to. The file type will be deduced
from the file name extension (see vigra.impexListExtensions()
for a list of supported extensions).</dd>
<dt>dtype:</dt>
<dd><p class="first">the pixel type written to the file. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;&#8217; or &#8216;NATIVE&#8217;:</dt>
<dd>save with original pixel type, or convert automatically
when this type is unsupported by the target file format</dd>
<dt>&#8216;UINT8&#8217;, &#8216;INT16&#8217;, &#8216;UINT16&#8217;, &#8216;INT32&#8217;, &#8216;UINT32&#8217;, &#8216;FLOAT&#8217;, &#8216;DOUBLE&#8217;:</dt>
<dd>save as specified, or raise exception when this type is not 
supported by the target file format (see list below)</dd>
<dt>&#8216;NBYTE&#8217;:</dt>
<dd>normalize to range 0...255 and then save as &#8216;UINT8&#8217;</dd>
<dt>numpy.uint8, numpy.int16 etc.:</dt>
<dd>behaves like the corresponding string argument</dd>
</dl>
</div></blockquote>
</dd>
<dt>compression:</dt>
<dd><p class="first">how to compress the data (ignored when compression type is unsupported 
by the file format). Possible values:</p>
<dl class="last docutils">
<dt>&#8216;&#8217; or not given:</dt>
<dd>save with the native compression of the target file format</dd>
<dt>&#8216;RLE&#8217;, &#8216;RunLength&#8217;:</dt>
<dd>use run length encoding (native in BMP, supported by TIFF)</dd>
<dt>&#8216;DEFLATE&#8217;:</dt>
<dd>use deflate encoding (only supported by TIFF)</dd>
<dt>&#8216;LZW&#8217;:</dt>
<dd>use LZW algorithm (only supported by TIFF with LZW enabled)</dd>
<dt>&#8216;ASCII&#8217;:</dt>
<dd>write as ASCII rather than binary file (only supported by PNM)</dd>
<dt>&#8216;1&#8217; ... &#8216;100&#8217;:</dt>
<dd>use this JPEG compression level (only supported by JPEG and TIFF)</dd>
</dl>
</dd>
<dt>mode:</dt>
<dd><p class="first">support for sequential file formats such as multi-image TIFF. 
Possible values:</p>
<dl class="last docutils">
<dt>&#8216;w&#8217;:</dt>
<dd>create a new file (default)</dd>
<dt>&#8216;a&#8217;:</dt>
<dd>append an image to a file or create a new one if the file does 
not exist (only supported by TIFF to create multi-page TIFF files)</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Supported file formats are listed by the function vigra.impexListFormats().
The different file formats support the following pixel types:</p>
<blockquote>
<div><dl class="docutils">
<dt>BMP:</dt>
<dd>Microsoft Windows bitmap image file (pixel type: UINT8 as gray and RGB).</dd>
<dt>GIF:</dt>
<dd>CompuServe graphics interchange format; 8-bit color
(pixel type: UINT8 as gray and RGB).</dd>
<dt>JPEG:</dt>
<dd>Joint Photographic Experts Group JFIF format; compressed 24-bit color
(pixel types: UINT8 as gray and RGB). Only available if libjpeg is
installed.</dd>
<dt>PNG:</dt>
<dd>Portable Network Graphic (pixel types: UINT8 and UINT16 with
up to 4 channels). (only available if libpng is installed)</dd>
<dt>PBM:</dt>
<dd>Portable bitmap format (black and white).</dd>
<dt>PGM:</dt>
<dd>Portable graymap format (pixel types: UINT8, INT16, INT32 as gray scale).</dd>
<dt>PNM:</dt>
<dd>Portable anymap (pixel types: UINT8, INT16, INT32, gray and RGB)</dd>
<dt>PPM:</dt>
<dd>Portable pixmap format (pixel types: UINT8, INT16, INT32 as RGB)</dd>
<dt>SUN:</dt>
<dd>SUN Rasterfile (pixel types: UINT8 as gray and RGB).</dd>
<dt>TIFF:</dt>
<dd>Tagged Image File Format (pixel types: UINT8, INT16, INT32, FLOAT, DOUBLE
with up to 4 channels). Only available if libtiff is installed.</dd>
<dt>VIFF:</dt>
<dd>Khoros Visualization image file (pixel types: UINT8, INT16
INT32, FLOAT, DOUBLE with arbitrary many channels).</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.writeVolume">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">writeVolume</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.writeVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a volume as a sequence of images:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">writeVolume</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">filename_base</span><span class="p">,</span> <span class="n">filename_ext</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image sequence will be enumerated in the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">filename_base</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="n">filename_ext</span>
</pre></div>
</div>
<p>Write a volume as a multi-page tiff (filename_ext must be an empty string):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">writeVolume</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters &#8216;dtype&#8217; and &#8216;compression&#8217; will be handled as in <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">writeImage()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="mathematical-functions-and-type-coercion">
<span id="sec-dtype-coercion"></span><h2><a class="toc-backref" href="#id76">Mathematical Functions and Type Coercion</a><a class="headerlink" href="#mathematical-functions-and-type-coercion" title="Permalink to this headline">¶</a></h2>
<p>vigranumpy supports all arithmetic and algebraic functions defined in
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">numpy.ufunc</a>, but re-implements them in module <cite>vigra.ufunc</cite> to take full advantage of axistags.</p>
<span class="target" id="module-vigra.ufunc"></span><p>The following mathematical functions are available in this module
(refer to numpy for detailed documentation):</p>
<div class="highlight-python"><pre>absolute   absolute   add   arccos   arccosh   arcsin   arcsinh   arctan
arctan2   arctanh   bitwise_and   bitwise_or   bitwise_xor   ceil
conjugate   conjugate   copysign   cos   cosh   deg2rad   degrees   divide
equal   exp   exp2   expm1   fabs   floor   floor_divide   fmax
fmin   fmod   frexp   greater   greater_equal   hypot   invert   invert
isfinite   isinf   isnan   ldexp   left_shift   less   less_equal   log
log10   log1p   log2   logaddexp   logaddexp2   logical_and   logical_not
logical_or   logical_xor   maximum   minimum   modf   multiply   negative
nextafter   not_equal   power   rad2deg   radians   reciprocal   remainder
remainder   right_shift   rint   sign   signbit   sin   sinh   spacing
sqrt   square   subtract   tan   tanh   true_divide   trunc</pre>
</div>
<p>Some of these functions are also provided as member functions of 
VigraArray:</p>
<div class="highlight-python"><pre>__abs__   __add__   __and__   __div__   __divmod__   __eq__
__floordiv__   __ge__   __gt__   __invert__   __le__   __lshift__
__lt__   __mod__   __mul__   __ne__   __neg__   __or__   __pos__
__pow__   __radd__   __radd__   __rand__   __rdiv__   __rdivmod__
__rfloordiv__   __rlshift__   __rmod__   __rmul__   __ror__   __rpow__
__rrshift__   __rshift__   __rsub__   __rtruediv__   __rxor__   __sub__
__truediv__   __xor__</pre>
</div>
<p>As usual, these functions are applied independently at each pixel.</p>
<p>Vigranumpy overloads the numpy-versions of these functions in order to make their
behavior more suitable for image analysis. In particular, we changed two aspects:</p>
<ul class="simple">
<li>Axistag consistency is checked, and the order of axes and strides is 
preserved in the result array. (In contrast, plain numpy functions 
always create C-order arrays, disregarding the stride order of the 
inputs.)</li>
<li>Typecasting rules are changed such that (i) data are represented with 
at most 32 bits, when possible, (ii) the number of types that occur as 
results of mixed expressions is reduced, and (iii) the chance of bad 
surprises is minimized.</li>
</ul>
<p>Default output types are thus determined according to the following rules:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The output type does not depend on the order of the arguments:</p>
<div class="highlight-python"><pre>a + b results in the same type as b + a</pre>
</div>
</li>
</ol>
<dl class="docutils">
<dt>2.a With exception of logical functions and abs(), the output type </dt>
<dd>does not depend on the function to be executed.</dd>
</dl>
<p>2.b The output type of logical functions is bool.</p>
<dl class="docutils">
<dt>2.c The output type of abs() follows general rules unless the </dt>
<dd><p class="first">input contains complex numbers, in which case the output type 
is the corresponding float number type:</p>
<div class="last highlight-python"><pre>a + b results in the same type as a / b
a == b =&gt; bool
abs(complex128) =&gt; float64</pre>
</div>
</dd>
</dl>
<ol class="arabic" start="3">
<li><p class="first">If the inputs have the same type, the type is preserved:</p>
<div class="highlight-python"><pre>uint8 + uint8 =&gt; uint8</pre>
</div>
</li>
<li><p class="first">If (and only if) one of the inputs has at least 64 bits, the output 
will also have at least 64 bits:</p>
<div class="highlight-python"><pre>int64 + uint32 =&gt; int64
int64 + 1.0    =&gt; float64</pre>
</div>
</li>
<li><p class="first">If an array is combined with a scalar of the same kind (integer,
float, or complex), the array type is preserved. If an integer 
array with at most 32 bits is combined with a float scalar, the 
result is float32 (and rule 4 kicks in if the array has 64 bits):</p>
<div class="highlight-python"><pre>uint8   + 1   =&gt; uint8
uint8   + 1.0 =&gt; float32
float32 + 1.0 =&gt; float32
float64 + 1.0 =&gt; float64</pre>
</div>
</li>
<li><p class="first">Integer expressions with mixed types always produce signed results.
If the arguments have at most 32 bits, the result will be int32, 
otherwise it will be int64 (cf. rule 4):</p>
<div class="highlight-python"><pre>int8  + uint8  =&gt; int32
int32 + uint8  =&gt; int32
int32 + uint32 =&gt; int32
int32 + int64  =&gt; int64
int64 + uint64 =&gt; int64</pre>
</div>
</li>
<li><p class="first">In all other cases, the output type is equal to the highest input 
type:</p>
<div class="highlight-python"><pre>int32   + float32    =&gt; float32
float32 + complex128 =&gt; complex128</pre>
</div>
</li>
<li><p class="first">All defaults can be overridden by providing an explicit output array:</p>
<div class="highlight-python"><pre>ufunc.add(uint8, uint8, uint16) =&gt; uint16</pre>
</div>
</li>
</ol>
</div></blockquote>
<p>In order to prevent overflow, necessary upcasting is performed before 
the function is executed.</p>
</div>
<div class="section" id="color-and-intensity-manipulation">
<h2><a class="toc-backref" href="#id77">Color and Intensity Manipulation</a><a class="headerlink" href="#color-and-intensity-manipulation" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.colors provides functions to adjust image brightness and contrast,
and to transform between different color spaces.
See <a class="reference external" href="../vigra/group__ColorConversions.html">Color Conversions</a> in the C++ documentation
for more information.</p>
<span class="target" id="module-vigra.colors"></span><dl class="function">
<dt id="vigra.colors.alphamodulated2qimage_ARGB32Premultiplied">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">alphamodulated2qimage_ARGB32Premultiplied</tt><big>(</big><em>(object)image</em>, <em>(object)qimage</em>, <em>(object)tintColor</em>, <em>(object)normalize</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.colors.alphamodulated2qimage_ARGB32Premultiplied" title="Permalink to this definition">¶</a></dt>
<dd><p>alphamodulated2qimage_ARGB32Premultiplied( (object)image, (object)qimage, (object)tintColor, (object)normalize) -&gt; None</p>
<p>alphamodulated2qimage_ARGB32Premultiplied( (object)image, (object)qimage, (object)tintColor, (object)normalize) -&gt; None</p>
<p>alphamodulated2qimage_ARGB32Premultiplied( (object)image, (object)qimage, (object)tintColor, (object)normalize) -&gt; None</p>
<p>alphamodulated2qimage_ARGB32Premultiplied( (object)image, (object)qimage, (object)tintColor, (object)normalize) -&gt; None</p>
<p>alphamodulated2qimage_ARGB32Premultiplied( (object)image, (object)qimage, (object)tintColor, (object)normalize) -&gt; None</p>
<dl class="docutils">
<dt>alphamodulated2qimage_ARGB32Premultiplied( (object)image, (object)qimage, (object)tintColor, (object)normalize) -&gt; None :</dt>
<dd><p class="first">Convert the image (single-band) into a QImage of format Format_ARGB32_Premultiplied.</p>
<p class="last">import qimage2ndarray
qimg = QImage(a.shape[0], a.shape[1], QImage.Format_ARGB32_Premultiplied)
normalize = numpy.asarray([10, 217], dtype=image.dtype)
tintColor = numpy.asarray([1.0, 0.0, 0.0], dtype=numpy.float32) #RGB
vigra.colors.alphamodulated2qimage_ARGB32Premultiplied(a, qimage2ndarray.byte_view(qimg), tintColor, normalize)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.applyColortable">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">applyColortable</tt><big>(</big><em>(object)valueImage</em>, <em>(object)colortable</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.colors.applyColortable" title="Permalink to this definition">¶</a></dt>
<dd><p>applyColortable( (object)valueImage, (object)colortable [, (object)out=None]) -&gt; object</p>
<p>applyColortable( (object)valueImage, (object)colortable [, (object)out=None]) -&gt; object</p>
<p>applyColortable( (object)valueImage, (object)colortable [, (object)out=None]) -&gt; object</p>
<dl class="docutils">
<dt>applyColortable( (object)valueImage, (object)colortable [, (object)out=None]) -&gt; object :</dt>
<dd><p class="first">Applies a colortable to the given 2D valueImage.</p>
<p>Colortable must have 4 columns, each row represents a color (for example, RGBA).
Values in valueImage are first taken module the length of the colortable.</p>
<p class="last">Returns: uint8 image with 4 channels</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.brightness">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">brightness</tt><big>(</big><em>(object)image</em>, <em>(float)factor</em><span class="optional">[</span>, <em>(object)range=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.brightness" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adjust the brightness of a 2D scalar or multiband image. The function applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">image</span> <span class="o">+</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;factor&#8217; and &#8216;range[1] - range[0]&#8217; must be positive. Elements outside the given range are clipped at the range borders. If &#8216;range&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>brightness( (object)volume, (float)factor [, (object)range=(0.0, 255.0) [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.contrast">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">contrast</tt><big>(</big><em>(object)image</em>, <em>(float)factor</em><span class="optional">[</span>, <em>(object)range=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.contrast" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adjust the contrast of an image or volume. The function applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">image</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">factor</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;factor&#8217; and &#8216;range[1] - range[0]&#8217; must be positive. Elements outside the given range are clipped at the range borders. If &#8216;range&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>contrast( (object)volume, (float)factor [, (object)range=(0.0, 255.0) [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.gammaCorrection">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">gammaCorrection</tt><big>(</big><em>(object)image</em>, <em>(float)gamma</em><span class="optional">[</span>, <em>(object)range=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.gammaCorrection" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adjust gamma correction to an image or volume. The function applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">diff</span> <span class="o">=</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">out</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">((</span><span class="n">image</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">diff</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">+</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;gamma&#8217; and &#8216;range[1] - range[0]&#8217; must be positive. Elements outside the given range are clipped at the range borders. If &#8216;range&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>gammaCorrection( (object)volume, (float)gamma [, (object)range=(0.0, 255.0) [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.gray2qimage_ARGB32Premultiplied">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">gray2qimage_ARGB32Premultiplied</tt><big>(</big><em>(object)image</em>, <em>(object)qimage</em><span class="optional">[</span>, <em>(object)normalize=None</em><span class="optional">]</span><big>)</big> &rarr; None<a class="headerlink" href="#vigra.colors.gray2qimage_ARGB32Premultiplied" title="Permalink to this definition">¶</a></dt>
<dd><p>gray2qimage_ARGB32Premultiplied( (object)image, (object)qimage [, (object)normalize=None]) -&gt; None</p>
<p>gray2qimage_ARGB32Premultiplied( (object)image, (object)qimage [, (object)normalize=None]) -&gt; None</p>
<p>gray2qimage_ARGB32Premultiplied( (object)image, (object)qimage [, (object)normalize=None]) -&gt; None</p>
<p>gray2qimage_ARGB32Premultiplied( (object)image, (object)qimage [, (object)normalize=None]) -&gt; None</p>
<p>gray2qimage_ARGB32Premultiplied( (object)image, (object)qimage [, (object)normalize=None]) -&gt; None</p>
<dl class="docutils">
<dt>gray2qimage_ARGB32Premultiplied( (object)image, (object)qimage [, (object)normalize=None]) -&gt; None :</dt>
<dd><p class="first">Convert the image (single-band) into a QImage of format Format_ARGB32_Premultiplied.</p>
<p class="last">import qimage2ndarray
qimg = QImage(a.shape[0], a.shape[1], QImage.Format_ARGB32_Premultiplied)
normalize = numpy.asarray([10, 217], dtype=image.dtype)
vigra.colors.gray2qimage_ARGB32Premultiplied(a, qimage2ndarray.byte_view(qimg), normalize)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.linearRangeMapping">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">linearRangeMapping</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)oldRange='auto'</em><span class="optional">[</span>, <em>(object)newRange=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.linearRangeMapping" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Convert the intensity range of a 2D scalar or multiband image. The function applies a linear transformation to the intensities such that the value oldRange[0] is mapped onto newRange[0], and oldRange[1] is mapped onto newRange[1]. That is, the algorithm applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">oldDiff</span> <span class="o">=</span> <span class="n">oldRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">oldRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">newDiff</span> <span class="o">=</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">oldRange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">oldDiff</span> <span class="o">*</span> <span class="n">newDiff</span> <span class="o">+</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;oldDiff&#8217; and &#8216;newDiff&#8217; must be positive. If &#8216;oldRange&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221; (the default), the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>If &#8216;newRange&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, it is set to (0, 255.0). If &#8216;out&#8217; is explicitly passed, it must be a uin8 image.</p>
</div></blockquote>
<dl class="docutils">
<dt>linearRangeMapping( (object)image [, (object)oldRange=&#8217;auto&#8217; [, (object)newRange=(0.0, 255.0) [, (object)out=None]]]) -&gt; object :</dt>
<dd>Likewise, but &#8216;out&#8217; is a float32 image.</dd>
<dt>linearRangeMapping( (object)volume [, (object)oldRange=&#8217;auto&#8217; [, (object)newRange=(0.0, 255.0) [, (object)out=None]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume, when &#8216;out&#8217; is a unit8 volume.</dd>
<dt>linearRangeMapping( (object)volume [, (object)oldRange=&#8217;auto&#8217; [, (object)newRange=(0.0, 255.0) [, (object)out=None]]]) -&gt; object :</dt>
<dd>Likewise, but &#8216;out&#8217; is a float32 volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Lab2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Lab2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Lab2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Lab2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Lab2RGBFunctor.html">Lab2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Lab2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Lab2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Lab2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Lab2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Lab2RGBPrimeFunctor.html">Lab2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Lab2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Lab2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Lab2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Lab2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Lab2XYZFunctor.html">Lab2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Luv2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Luv2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Luv2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Luv2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Luv2RGBFunctor.html">Luv2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Luv2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Luv2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Luv2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Luv2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Luv2RGBPrimeFunctor.html">Luv2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Luv2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Luv2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Luv2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Luv2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Luv2XYZFunctor.html">Luv2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2Lab">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2Lab</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2Lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2LabFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2LabFunctor.html">RGB2LabFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2Luv">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2Luv</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2Luv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2LuvFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2LuvFunctor.html">RGB2LuvFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2RGBPrimeFunctor.html">RGB2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2XYZFunctor.html">RGB2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2sRGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2sRGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2sRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2sRGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2sRGBFunctor.html">RGB2sRGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2Lab">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2Lab</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2Lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2LabFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2LabFunctor.html">RGBPrime2LabFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2Luv">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2Luv</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2Luv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2LuvFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2LuvFunctor.html">RGBPrime2LuvFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2RGBFunctor.html">RGBPrime2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2XYZFunctor.html">RGBPrime2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimeCbCr">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimeCbCr</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimeCbCr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimeCbCrFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimeCbCrFunctor.html">RGBPrime2YPrimeCbCrFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimeIQ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimeIQ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimeIQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimeIQFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimeIQFunctor.html">RGBPrime2YPrimeIQFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimePbPr">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimePbPr</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimePbPr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimePbPrFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimePbPrFunctor.html">RGBPrime2YPrimePbPrFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimeUV">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimeUV</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimeUV" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimeUVFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimeUVFunctor.html">RGBPrime2YPrimeUVFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2Lab">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2Lab</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2Lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2LabFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2LabFunctor.html">XYZ2LabFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2Luv">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2Luv</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2Luv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2LuvFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2LuvFunctor.html">XYZ2LuvFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2RGBFunctor.html">XYZ2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2RGBPrimeFunctor.html">XYZ2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimeCbCr2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimeCbCr2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimeCbCr2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimeCbCr2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimeCbCr2RGBPrimeFunctor.html">YPrimeCbCr2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimeIQ2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimeIQ2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimeIQ2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimeIQ2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimeIQ2RGBPrimeFunctor.html">YPrimeIQ2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimePbPr2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimePbPr2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimePbPr2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimePbPr2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimePbPr2RGBPrimeFunctor.html">YPrimePbPr2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimeUV2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimeUV2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimeUV2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimeUV2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimeUV2RGBPrimeFunctor.html">YPrimeUV2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_sRGB2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_sRGB2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_sRGB2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using sRGB2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1sRGB2RGBFunctor.html">sRGB2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

</div>
<div class="section" id="filters">
<h2><a class="toc-backref" href="#id78">Filters</a><a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.filters provides operators that consider a window around each pixel, compute
one or several numbers from the values in the window, and store the results in the
corresponding pixel of the output image. This includes convolution, non-linear diffusion,
morphological operators, feature detectors (such as the structure tensor) etc.</p>
<span class="target" id="module-vigra.filters"></span><dl class="class">
<dt id="vigra.filters.Kernel1D">
<em class="property">class </em><tt class="descclassname">vigra.filters.</tt><tt class="descname">Kernel1D</tt><a class="headerlink" href="#vigra.filters.Kernel1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic 1 dimensional convolution kernel.</p>
<p>This kernel may be used for convolution of 1 dimensional signals or for separable convolution of multidimensional signals. The kernel&#8217;s size is given by its left() and right() methods. The desired border treatment mode is returned by getBorderTreatment(). The different init functions create a kernel with the specified properties. For more details, see <a class="reference external" href="../../doc/vigra/classvigra_1_1Kernel1D.html">Kernel1D</a> in the C++ documentation.</p>
<dl class="docutils">
<dt>__init__( (object)arg1) -&gt; None :</dt>
<dd><p class="first">Standard constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Kernel1D</span><span class="p">()</span>
</pre></div>
</div>
<p class="last">Creates an identity kernel.</p>
</dd>
<dt>__init__( (object)arg1, (Kernel1D)kernel) -&gt; None :</dt>
<dd><p class="first">Copy constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Kernel1D</span><span class="p">(</span><span class="n">other_kernel</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="vigra.filters.Kernel1D.borderTreatment">
<tt class="descname">borderTreatment</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; BorderTreatmentMode :<a class="headerlink" href="#vigra.filters.Kernel1D.borderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initAveraging">
<tt class="descname">initAveraging</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initAveraging" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as an averaging filter with given radius (i.e. window size 2*radius+1). &#8216;norm&#8217; denotes the sum of all bins of the kernel.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;averagingKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initBinomial">
<tt class="descname">initBinomial</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initBinomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a binomial filter with given radius (i.e. window size 2*radius+1). &#8216;norm&#8217; denotes the sum of all bins of the kernel.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;binomialKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initBurtFilter">
<tt class="descname">initBurtFilter</tt><big>(</big><em>(Kernel1D)arg1</em><span class="optional">[</span>, <em>(float)a=0.04785</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initBurtFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a 5-tap smoothing filter of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="n">a</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;burtFilterKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initDiscreteGaussian">
<tt class="descname">initDiscreteGaussian</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initDiscreteGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as Lindeberg&#8217;s discrete analog of the Gaussian function. The radius of the kernel is always 3*std_dev. &#8216;norm&#8217; denotes the desired sum of all bins of the kernel.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;discreteGaussianKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initExplicitly">
<tt class="descname">initExplicitly</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(int)left</em>, <em>(int)right</em>, <em>(object)contents</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initExplicitly" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the kernel with explicit values from &#8216;contents&#8217;, which must be a 1D numpy.ndarray. &#8216;left&#8217; and &#8216;right&#8217; are the boundaries of the kernel (inclusive). If &#8216;contents&#8217; contains the wrong number of values, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant. The norm is set to the sum of the initializer values.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;explicitlyKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initGaussian">
<tt class="descname">initGaussian</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a sampled Gaussian function. The radius of the kernel is always 3*std_dev. &#8216;norm&#8217; denotes the desired sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the Gaussian to a finite interval). However, if norm is 0.0, the kernel is normalized to 1 by the analytic expression for the Gaussian, and no correction for the windowing error is performed.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;gaussianKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initGaussianDerivative">
<tt class="descname">initGaussianDerivative</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(float)scale</em>, <em>(int)order</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initGaussianDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a Gaussian derivative of order &#8216;order&#8217;. The radius of the kernel is always 3*std_dev + 0.5*order. &#8216;norm&#8217; denotes the norm of the kernel. Thus, the kernel will be corrected for the error introduced by windowing the Gaussian to a finite interval. However, if norm is 0.0, the kernel is normalized to 1 by the analytic expression for the Gaussian derivative, and no correction for the windowing error is performed.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;gaussianDerivativeKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalFirstDerivative5">
<tt class="descname">initOptimalFirstDerivative5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalFirstDerivative5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing3">
<tt class="descname">initOptimalFirstDerivativeSmoothing3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing5">
<tt class="descname">initOptimalFirstDerivativeSmoothing5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSecondDerivative5">
<tt class="descname">initOptimalSecondDerivative5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSecondDerivative5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing3">
<tt class="descname">initOptimalSecondDerivativeSmoothing3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing5">
<tt class="descname">initOptimalSecondDerivativeSmoothing5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSmoothing3">
<tt class="descname">initOptimalSmoothing3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSmoothing3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSmoothing5">
<tt class="descname">initOptimalSmoothing5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSmoothing5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initSecondDifference3">
<tt class="descname">initSecondDifference3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initSecondDifference3" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a 3-tap second difference filter of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;secondDifference3Kernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initSymmetricDifference">
<tt class="descname">initSymmetricDifference</tt><big>(</big><em>(Kernel1D)arg1</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initSymmetricDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a symmetric difference filter of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">norm</span><span class="p">]</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;symmetricDifferenceKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.left">
<tt class="descname">left</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel1D.left" title="Permalink to this definition">¶</a></dt>
<dd><p>Left border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.norm">
<tt class="descname">norm</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.filters.Kernel1D.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the norm of kernel.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.normalize">
<tt class="descname">normalize</tt><big>(</big><em>(Kernel1D)arg1</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">[</span>, <em>(int)derivativeOrder=0</em><span class="optional">[</span>, <em>(float)offset=0.0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new norm and normalize kernel, use the normalization formula for the given derivativeOrder.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.right">
<tt class="descname">right</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel1D.right" title="Permalink to this definition">¶</a></dt>
<dd><p>Right border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.setBorderTreatment">
<tt class="descname">setBorderTreatment</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(BorderTreatmentMode)borderTreatment</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.setBorderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.size">
<tt class="descname">size</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel1D.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of kernel elements (right() - left() + 1).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.filters.Kernel2D">
<em class="property">class </em><tt class="descclassname">vigra.filters.</tt><tt class="descname">Kernel2D</tt><a class="headerlink" href="#vigra.filters.Kernel2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic 2 dimensional convolution kernel.</p>
<p>This kernel may be used for convolution of 2 dimensional signals. The desired border treatment mode is returned by borderTreatment().(Note that the 2D convolution functions don&#8217;t currently support all modes.) The different init functions create a kernel with the specified properties. For more details, see <a class="reference external" href="../../doc/vigra/classvigra_1_1Kernel2D.html">Kernel2D</a> in the C++ documentation.</p>
<dl class="docutils">
<dt>__init__( (object)arg1) -&gt; None :</dt>
<dd><p class="first">Standard constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Kernel2D</span><span class="p">()</span>
</pre></div>
</div>
<p class="last">Creates an identity kernel.</p>
</dd>
<dt>__init__( (object)arg1, (Kernel2D)kernel) -&gt; None :</dt>
<dd><p class="first">Copy constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Kernel2D</span><span class="p">(</span><span class="n">other_kernel</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="vigra.filters.Kernel2D.borderTreatment">
<tt class="descname">borderTreatment</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; BorderTreatmentMode :<a class="headerlink" href="#vigra.filters.Kernel2D.borderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.height">
<tt class="descname">height</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel2D.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertical kernel size (lowerRight()[1] - upperLeft()[1] + 1).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initDisk">
<tt class="descname">initDisk</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(int)radius</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initDisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the 2D kernel as a circular averaging filter. The norm will be calculated as 1 / (number of non-zero kernel values).</p>
<p>Precondition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;diskKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initExplicitly">
<tt class="descname">initExplicitly</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(object)upperLeft</em>, <em>(object)lowerRight</em>, <em>(object)contents</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initExplicitly" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the kernel with explicit values from &#8216;contents&#8217;, which must be a 2D numpy.ndarray. &#8216;upperLeft&#8217; and &#8216;lowerRight&#8217; are the boundaries of the kernel (inclusive), and  must be 2D tuples. If &#8216;contents&#8217; contains the wrong number of values, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant. The norm is set to the sum of the initializer values.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;explicitlyKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initGaussian">
<tt class="descname">initGaussian</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a sampled 2D Gaussian function. The radius of the kernel is always 3*std_dev. &#8216;norm&#8217; denotes the desired sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the Gaussian to a finite interval). However, if norm is 0.0, the kernel is normalized to 1 by the analytic expression for the Gaussian, and no correction for the windowing error is performed.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;gaussianKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initSeparable">
<tt class="descname">initSeparable</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(Kernel1D)kernelX</em>, <em>(Kernel1D)kernelY</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initSeparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the 2D kernel as the cartesian product of two 1D kernels of type Kernel1D. The norm becomes the product of the two original norms.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;separableKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.lowerRight">
<tt class="descname">lowerRight</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.Kernel2D.lowerRight" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower right border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.norm">
<tt class="descname">norm</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.filters.Kernel2D.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the norm of the kernel.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.normalize">
<tt class="descname">normalize</tt><big>(</big><em>(Kernel2D)arg1</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the kernel&#8217;s norm and renormalize the values.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.setBorderTreatment">
<tt class="descname">setBorderTreatment</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(BorderTreatmentMode)borderTreatment</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.setBorderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.upperLeft">
<tt class="descname">upperLeft</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.Kernel2D.upperLeft" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper left border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.width">
<tt class="descname">width</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel2D.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Horizontal kernel size (lowerRight()[0] - upperLeft()[0] + 1).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="vigra.filters.boundaryTensor2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">boundaryTensor2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.boundaryTensor2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the boundary tensor for a scalar valued 2D image.For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gab4ee0f19130a109119cc9cbc594ed1b7">boundaryTensor</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.convolve">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">convolve</tt><big>(</big><em>(object)image</em>, <em>(Kernel1D)kernel</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.convolve" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Convolve an image with the given &#8216;kernel&#8217; (or kernels).
If the input has multiple channels, the filter is applied to each channel
independently. The function can be used in 3 different ways:</p>
<ul class="simple">
<li>When &#8216;kernel&#8217; is a single object of type <a class="reference internal" href="#vigra.filters.Kernel1D" title="vigra.filters.Kernel1D"><tt class="xref py py-class docutils literal"><span class="pre">Kernel1D</span></tt></a>, this kernel
is applied along all spatial dimensions of the data (separable filtering).</li>
<li>When &#8216;kernel&#8217; is a tuple of <a class="reference internal" href="#vigra.filters.Kernel1D" title="vigra.filters.Kernel1D"><tt class="xref py py-class docutils literal"><span class="pre">Kernel1D</span></tt></a> objects, one different kernel
is used for each spatial dimension (separable filtering). The number of
kernels must equal the number of dimensions).</li>
<li>When &#8216;kernel&#8217; is an instance of <a class="reference internal" href="#vigra.filters.Kernel2D" title="vigra.filters.Kernel2D"><tt class="xref py py-class docutils literal"><span class="pre">Kernel2D</span></tt></a>, a 2-dimensional convolution
is performed (non-separable filtering). This is only applicable to 2D images.</li>
</ul>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a> and <a class="reference external" href="../../doc/vigra/group__CommonConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>convolve( (object)volume, (Kernel1D)kernel [, (object)out=None]) -&gt; object :</dt>
<dd>Convolve a volume with the same 1D kernel along all dimensions.</dd>
<dt>convolve( (object)image, (tuple)kernels [, (object)out=None]) -&gt; object :</dt>
<dd>Convolve an image with a different 1D kernel along each dimensions.</dd>
<dt>convolve( (object)volume, (tuple)kernels [, (object)out=None]) -&gt; object :</dt>
<dd>Convolve a volume with a different 1D kernel along each dimensions.</dd>
<dt>convolve( (object)image, (Kernel2D)kernel [, (object)out=None]) -&gt; object :</dt>
<dd>Convolve an image with a 2D kernel.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.convolveOneDimension">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">convolveOneDimension</tt><big>(</big><em>(object)image</em>, <em>(int)dim</em>, <em>(Kernel1D)kernel</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.convolveOneDimension" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Convolution along a single dimension of a 2D scalar or multiband image. &#8216;kernel&#8217; must be an instance of Kernel1D.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>convolveOneDimension( (object)volume, (int)dim, (Kernel1D)kernel [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discClosing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discClosing</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discClosing" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a closing filter with disc of given radius to image.</p>
<p>This is an abbreviation for applying a dilation and an erosion  filter in sequence. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discDilation">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discDilation</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discDilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply dilation (maximum) filter with disc of given radius to image.</p>
<p>This is an abbreviation for the rank order filter with rank = 1.0. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gaa6b2b4e1d0fab80e25aa7bb349ac3da3">discDilation</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discErosion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discErosion</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discErosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply erosion (minimum) filter with disc of given radius to image.</p>
<p>This is an abbreviation for the rank order filter with rank = 0.0. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gaeaa85e48818f2026b07cbac969cc2390">discErosion</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discMedian">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discMedian</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discMedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply median filter with disc of given radius to image.</p>
<p>This is an abbreviation for the rank order filter with rank = 0.5. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#ga6f7f27916f6f43016aa268e8730be59b">discMedian</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discOpening">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discOpening</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discOpening" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a opening filter with disc of given radius to image.</p>
<p>This is an abbreviation for applying an erosion and a dilation filter in sequence. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discRankOrderFilter">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discRankOrderFilter</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em>, <em>(float)rank</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discRankOrderFilter" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Apply rank order filter with disc structuring function to a float image.</p>
<p>The pixel values of the source image  must be in the range 0...255. Radius must be &gt;= 0. Rank must be in the range 0.0 &lt;= rank &lt;= 1.0. The filter acts as a minimum filter if rank = 0.0, as a median if rank = 0.5, and as a maximum filter if rank = 1.0. This function also works for multiband images, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>discRankOrderFilter( (object)image, (int)radius, (float)rank [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a uint8 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discRankOrderFilterWithMask">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discRankOrderFilterWithMask</tt><big>(</big><em>(object)image</em>, <em>(object)mask</em>, <em>(int)radius</em>, <em>(float)rank</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discRankOrderFilterWithMask" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Apply rank order filter with disc structuring function to a float image using a mask.</p>
<p>The pixel values of the source image must be in the range 0...255. Radius must be &gt;= 0.Rank must be in the range 0.0 &lt;= rank &lt;= 1.0. The filter acts as a minimum filter if rank = 0.0,as a median if rank = 0.5, and as a maximum filter if rank = 1.0.</p>
<p>The mask is only applied to the input image, i.e. the function generates an output wherever the current disc contains at least one pixel with non-zero mask value. Source pixels with mask value zero are ignored during the calculation of the rank order.</p>
<p>This function also works for multiband images, it is then executed on every band. If the mask has only one band, it is used for every image band. If the mask has the same number of bands, as the image the bands are used for the corresponding image bands.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Morphology.html#gad40782f8126b8b9b4a009fe8d8ddaaa3">discRankOrderFilterWithMask</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>discRankOrderFilterWithMask( (object)image, (object)mask, (int)radius, (float)rank [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a uint8 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.distanceTransform2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">distanceTransform2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)background=True</em><span class="optional">[</span>, <em>(int)norm=2</em><span class="optional">[</span>, <em>(object)pixel_pitch=()</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.distanceTransform2D" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute the distance transform of a 2D scalar float image.
All pixels with a value of 0.0 are considered to be background pixels,
while all pixels with a nonzero value are considered to be foreground pixels.
The parameter &#8216;background&#8217; is a Boolean scalar that specifies whether to
compute the distance of all background pixels to the nearest foreground pixels
(if it is &#8216;True&#8217;, default) or vice versa (if it is &#8216;False&#8217;).
Hence in the destination image, for background==True all background pixels
will be assigned their distance value, while all foreground pixels will be assigned 0.
For background==False, it is exactly the other way around.</p>
<p>The &#8216;norm&#8217; parameter gives the distance norm to use
(0: infinity norm, 1: L1 norm, 2: Euclidean norm).</p>
<p>If &#8216;pixel_pitch&#8217; is given, it must contain the pixel distance along the two axes.
They are then used to compute the distance anisotropically. If no &#8216;pixel_pitch&#8217; is
given, the data is treated isotropically with unit distance between pixels.
The anisotropic distance transform is only supported for norm =2 (Euclidean).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#gad481d272471bfa808196959dffca524b">distanceTransform</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>distanceTransform2D( (object)image [, (bool)background=True [, (int)norm=2 [, (object)pixel_pitch=() [, (object)out=None]]]]) -&gt; object :</dt>
<dd>Likewise for a 2D uint8 input array.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.distanceTransform3D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">distanceTransform3D</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(bool)background=True</em><span class="optional">[</span>, <em>(object)pixel_pitch=()</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.distanceTransform3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Euclidean distance transform of a 3D scalar float volume.
All voxels with a value of 0.0 are considered to be background voxels,
while all voxels with a nonzero value are considered to be foreground voxels.
The parameter &#8216;background&#8217; is a Boolean scalar that specifies whether to
compute the distance of all background voxels to the nearest foreground voxel
(if it is &#8216;True&#8217;, default) or vice versa (if it is &#8216;False&#8217;).
Hence in the destination volume, for background==True all background voxels
will be assigned their distance value, while all foreground voxels will be assigned 0.
For background==False, it is exactly the other way around.</p>
<p>If &#8216;pixel_pitch&#8217; is given, it must contain the pixel distance along the three axes.
They are then used to compute the distance anisotropically. If no &#8216;pixel_pitch&#8217; is
given, the data is treated isotropically with unit distance between pixels.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/group__MultiArrayDistanceTransform.html#gac5b055757926655498f70c6253761e27">separableMultiDistance</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianDivergence">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianDivergence</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)scale=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianDivergence" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute the divergence of a 2D vector field with a first derivative of Gaussian at the given scale.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is applied (i.e., each dimension is filtered in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>gaussianDivergence( (object)array [, (object)scale=1.0 [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]]) -&gt; object :</dt>
<dd>Likewise for a 3D vector field.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianGradient">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianGradient</tt><big>(</big><em>(object)image</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianGradient" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the gradient vector by means of a 1st derivative of Gaussian filter at the given scale for a 2D scalar image.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is applied (i.e., each dimension is filtered in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>gaussianGradient( (object)volume, (object)sigma [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianGradientMagnitude">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianGradientMagnitude</tt><big>(</big><em>(object)image</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(bool)accumulate=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianGradientMagnitude" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the gradient magnitude by means of a 1st derivative of Gaussian filter at the given scale for a 2D scalar or multiband image.
If &#8216;accumulate&#8217; is True (the default), the gradients are accumulated (in the L2-norm sense) over all  channels of a multi-channel array. Otherwise, a separate gradient magnitude is computed for each channel.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is applied (i.e., each dimension is filtered in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>gaussianGradientMagnitude( (object)volume, (object)sigma [, (bool)accumulate=True [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianSharpening2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianSharpening2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)sharpeningFactor=1.0</em><span class="optional">[</span>, <em>(float)scale=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianSharpening2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sharpening function with gaussian filter.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CommonConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianSmoothing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianSmoothing</tt><big>(</big><em>(object)array</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianSmoothing" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Perform Gaussian smoothing of a 2D or 3D scalar or multiband array.</p>
<p>Each channel of the array is smoothed independently. If &#8216;sigma&#8217; is a single value, an isotropic Gaussian filter at this scale is applied (i.e. each dimension is smoothed in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; specifies the ratio between the effective filter scale and the size of the filter window. Use a value around 2.0 to speed-up the computation by increasing the error resulting from cutting off the Gaussian. For the default 0.0, the window size is automatically determined.</p>
<p>If &#8216;roi&#8217; is not None, it must specify the desired region-of-interest as a pair &#8216;(first_point, beyond_last_point)&#8217; (e.g. &#8216;roi=((10,20), (200,250))&#8217;). As usual, the second point is the first point outside the ROI, and the ROI must not be outside the input array dimensions. The coordinates refer only to non-channel axes - if your array has an explicit channel axis, the ROI dimension must be one less than the array dimension. If you pass in an explicit &#8216;out&#8217; array and specify an ROI, the &#8216;out&#8217; array must have the shape of the ROI.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CommonConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>gaussianSmoothing( (object)array, (object)sigma [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]) -&gt; object :</dt>
<dd>Smooth volume with Gaussian.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hessianOfGaussian">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hessianOfGaussian</tt><big>(</big><em>(object)image</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.hessianOfGaussian" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the Hessian matrix by means of a derivative of Gaussian filters at the given scale for a 2D scalar image.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is applied (i.e., each dimension is filtered in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>hessianOfGaussian( (object)volume, (object)sigma [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hessianOfGaussian2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hessianOfGaussian2D</tt><big>(</big><em>(object)image</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.hessianOfGaussian2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Hessian matrix by means of a derivative of Gaussian filters at the given scale for a 2D scalar image.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is applied (i.e., each dimension is filtered in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hessianOfGaussian3D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hessianOfGaussian3D</tt><big>(</big><em>(object)volume</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.hessianOfGaussian3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Hessian matrix by means of a derivative of Gaussian filters at the given scale for a 3D scalar image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hessianOfGaussianEigenvalues">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hessianOfGaussianEigenvalues</tt><big>(</big><em>image</em>, <em>scale</em>, <em>out=None</em>, <em>sigma_d=0.0</em>, <em>step_size=1.0</em>, <em>window_size=0.0</em>, <em>roi=None</em><big>)</big><a class="headerlink" href="#vigra.filters.hessianOfGaussianEigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eigenvalues of the Hessian of Gaussian at the given scale
for a scalar image or volume.</p>
<p>Calls <a class="reference internal" href="#vigra.filters.hessianOfGaussian" title="vigra.filters.hessianOfGaussian"><tt class="xref py py-func docutils literal"><span class="pre">hessianOfGaussian()</span></tt></a> and <a class="reference internal" href="#vigra.filters.tensorEigenvalues" title="vigra.filters.tensorEigenvalues"><tt class="xref py py-func docutils literal"><span class="pre">tensorEigenvalues()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hourGlassFilter2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hourGlassFilter2D</tt><big>(</big><em>(object)image</em>, <em>(float)sigma</em>, <em>(float)rho</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.hourGlassFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Anisotropic tensor smoothing with the hourglass filter.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gae34b2f441aa2b256574ae43dc2991294">hourGlassFilter</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.laplacianOfGaussian">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">laplacianOfGaussian</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)scale=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.laplacianOfGaussian" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Filter 2D or 3D scalar array with the Laplacian of Gaussian operator at the given scale.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is applied (i.e., each dimension is filtered in the same way). If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>laplacianOfGaussian( (object)array [, (object)scale=1.0 [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]]) -&gt; object :</dt>
<dd>Likewise for a scalar volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryClosing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryClosing</tt><big>(</big><em>(object)volume</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryClosing" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Binary closing on a 3D scalar or multiband uint8 array.</p>
<p>This function applies a flat circular opening operator (sequential dilation and erosion) with a given radius. The operation is isotropic. The input is a uint8 or boolean multi-dimensional array where non-zero pixels represent foreground and zero pixels represent background. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see vigra C++ documentation (<a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a>).</p>
</div></blockquote>
<dl class="docutils">
<dt>multiBinaryClosing( (object)volume, (float)radius [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a bool array.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryDilation">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryDilation</tt><big>(</big><em>(object)volume</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryDilation" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Binary dilation on a 3D scalar or multiband uint8 array.</p>
<p>This function applies a flat circular dilation operator with a given radius. The operation is isotropic. The input is a uint8 or boolean multi-dimensional array where non-zero pixels represent foreground and zero pixels represent background. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>multiBinaryDilation( (object)volume, (float)radius [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for bool arrays.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryErosion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryErosion</tt><big>(</big><em>(object)volume</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryErosion" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Binary erosion on a 3D scalar or multiband uint8 array.</p>
<p>This function applies a flat circular erosion operator with a given radius. The operation is isotropic. The input is a uint8 or boolean multi-dimensional array where non-zero pixels represent foreground and zero pixels represent background. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>multiBinaryErosion( (object)volume, (float)radius [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a bool array.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryOpening">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryOpening</tt><big>(</big><em>(object)volume</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryOpening" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Binary opening on a 3D scalar or multiband uint8 array.</p>
<p>This function applies a flat circular opening operator (sequential erosion and dilation) with a given radius. The operation is isotropic. The input is a uint8 or boolean multi-dimensional array where non-zero pixels represent foreground and zero pixels represent background. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see vigra C++ documentation (<a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a>).</p>
</div></blockquote>
<dl class="docutils">
<dt>multiBinaryOpening( (object)volume, (float)radius [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a bool array.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleClosing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleClosing</tt><big>(</big><em>(object)volume</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleClosing" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Parabolic grayscale closing on multi-dimensional arrays.</p>
<p>This function applies a parabolic closing (sequential dilation and erosion) operator with a given spread &#8216;sigma&#8217; on a grayscale array. The operation is isotropic. The input is a grayscale multi-dimensional array. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>multiGrayscaleClosing( (object)volume, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D float array.</dd>
<dt>multiGrayscaleClosing( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D uint8 array.</dd>
</dl>
<p>multiGrayscaleClosing( (object)image, (float)sigma [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleDilation">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleDilation</tt><big>(</big><em>(object)volume</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleDilation" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Parabolic grayscale dilation on multi-dimensional arrays.</p>
<p>This function applies a parabolic dilation operator with a given spread &#8216;sigma&#8217; on a grayscale array. The operation is isotropic. The input is a grayscale multi-dimensional array. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>multiGrayscaleDilation( (object)volume, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D float array.</dd>
<dt>multiGrayscaleDilation( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D uint8 array.</dd>
</dl>
<p>multiGrayscaleDilation( (object)image, (float)sigma [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleErosion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleErosion</tt><big>(</big><em>(object)volume</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleErosion" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Parabolic grayscale erosion on a 3D scalar or multiband uint8 array.</p>
<p>This function applies a parabolic erosion operator with a given spread &#8216;sigma&#8217; on a grayscale array. The operation is isotropic. The input is a grayscale multi-dimensional array. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>multiGrayscaleErosion( (object)volume, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D float array.</dd>
<dt>multiGrayscaleErosion( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D uint8 array.</dd>
<dt>multiGrayscaleErosion( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D float array.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleOpening">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleOpening</tt><big>(</big><em>(object)volume</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleOpening" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Parabolic grayscale opening on multi-dimensional arrays.</p>
<p>This function applies a parabolic opening (sequential erosion and dilation) operator with a given spread &#8216;sigma&#8217; on a grayscale array. The operation is isotropic. The input is a grayscale multi-dimensional array. This function also works for multiband arrays, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>multiGrayscaleOpening( (object)volume, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D float array.</dd>
<dt>multiGrayscaleOpening( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D uint8 array.</dd>
</dl>
<p>multiGrayscaleOpening( (object)image, (float)sigma [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.nonlinearDiffusion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">nonlinearDiffusion</tt><big>(</big><em>(object)image</em>, <em>(float)edgeThreshold</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.nonlinearDiffusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform edge-preserving smoothing at the given scale.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NonLinearDiffusion.html#ga682a281ec8f2abbf2e3b18aaa7753c60">nonlinearDiffusion</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.normalizedConvolveImage">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">normalizedConvolveImage</tt><big>(</big><em>(object)image</em>, <em>(object)mask</em>, <em>(Kernel2D)kernel</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.normalizedConvolveImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform normalized convolution of an image. If the image has multiple channels, every channel is convolved independently. The &#8216;mask&#8217; tells the algorithm whether input pixels are valid (non-zero mask value) or not. Invalid pixels are ignored in the convolution. The mask must have one channel (which is then used for all channels input channels) or as many channels as the input image.</p>
<p>For details, see <a class="reference external" href="../../doc/vigra/group__CommonConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.radialSymmetryTransform2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">radialSymmetryTransform2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.radialSymmetryTransform2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find centers of radial symmetry in an 2D image.</p>
<p>This algorithm implements the Fast Radial Symmetry Transform according to [G. Loy, A. Zelinsky: &#8220;A Fast Radial Symmetry Transform for Detecting Points of Interest&#8221;, in: A. Heyden et al. (Eds.): Proc. of 7th European Conf. on Computer Vision, Part 1, pp. 358-368, Springer LNCS 2350, 2002]</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__SymmetryDetection.html#ga5ea9947261f0d49f92521e9f3ca38ee0">radialSymmetryTransform</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveFilter2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveFilter2D</tt><big>(</big><em>(object)image</em>, <em>(float)b</em><span class="optional">[</span>, <em>(BorderTreatmentMode)borderTreament=vigra.filters.BorderTreatmentMode.BORDER_TREATMENT_REFLECT</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Perform 2D convolution with a first-order recursive filter with parameter &#8216;b&#8217; and given &#8216;borderTreatment&#8217;. &#8216;b&#8217; must be between -1 and 1.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaf634b87803c602b9f3f34e670119f035">recursiveFilterX</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaa2197533a4dc993998f89641f61015cb">recursiveFilterY</a> (which this function calls in succession) in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>recursiveFilter2D( (object)image, (float)b1, (float)b2 [, (object)out=None]) -&gt; object :</dt>
<dd><p class="first">Perform 2D convolution with a second-order recursive filter with parameters &#8216;b1&#8217; and &#8216;b2&#8217;. Border treatment is always BORDER_TREATMENT_REFLECT.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaf634b87803c602b9f3f34e670119f035">recursiveFilterX</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaa2197533a4dc993998f89641f61015cb">recursiveFilterY</a> (which this function calls in succession) in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveGaussianSmoothing2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveGaussianSmoothing2D</tt><big>(</big><em>(object)image</em>, <em>(tuple)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveGaussianSmoothing2D" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute a fast approximate Gaussian smoothing of a 2D scalar or multiband image.</p>
<p>This function uses the third-order recursive filter approximation to the Gaussian filter proposed by Young and van Vliet. Each channel of the array is smoothed independently. If &#8216;sigma&#8217; is a single value, an isotropic Gaussian filter at this scale is applied (i.e. each dimension is smoothed in the same way). If &#8216;sigma&#8217; is a tuple of values, the amount of smoothing will be different for each spatial dimension. The length of the tuple must be equal to the number of spatial dimensions.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gac3b0b8f9de1d4349523c013e86f7d87b">recursiveGaussianFilterLine</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>recursiveGaussianSmoothing2D( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Compute isotropic fast approximate Gaussian smoothing.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveGradient2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveGradient2D</tt><big>(</big><em>(object)arg1</em>, <em>(float)image</em>, <em>(BorderTreatmentMode)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveGradient2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of a scalar image using a recursive (exponential) filter at the given &#8216;scale&#8217;. The output image (if given) must have two channels.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#ga60a94e16526f93f19d0cee9cf6bb9343">recursiveFirstDerivativeLine</a> (which this function calls internally) in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveLaplacian2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveLaplacian2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveLaplacian2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of a 2D scalar or multiband image using a recursive (exponential) filter at the given &#8216;scale&#8217;. The output image (if given) must have as many channels as the input.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#ga514cd0d70fc617cfea89b9dcb779ea18">recursiveSecondDerivativeLine</a> (which this function calls internally) in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveSmooth2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveSmooth2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(BorderTreatmentMode)borderTreament=vigra.filters.BorderTreatmentMode.BORDER_TREATMENT_REFLECT</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveSmooth2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls recursiveFilter2D() with b = exp(-1/scale), which corresponds to smoothing with an exponential filter exp(-abs(x)/scale).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.rieszTransformOfLOG2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">rieszTransformOfLOG2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(int)xorder</em>, <em>(int)yorder</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.rieszTransformOfLOG2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Riesz transforms of the Laplacian of Gaussian.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CommonConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.simpleSharpening2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">simpleSharpening2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)sharpeningFactor=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.simpleSharpening2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform simple sharpening function.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CommonConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.structureTensor">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">structureTensor</tt><big>(</big><em>(object)image</em>, <em>(object)innerScale</em>, <em>(object)outerScale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.structureTensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the structure tensor of an image by means of Gaussian (derivative) filters at the given scales. If the input has multiple channels, the structure tensors of each channel are added to get the result.</p>
<p>If &#8216;innerScale&#8217; and &#8216;outerScale&#8217; are single values, isotropic filters at these scales are applied (i.e., each dimension is filtered in the same way). If &#8216;innerScale&#8217; and / or &#8216;outerScale&#8217; are are tuples or lists of values, the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the resolution standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the distance between two adjacent pixels for each dimension. The length of the tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>structureTensor( (object)volume, (object)innerScale, (object)outerScale [, (object)out=None [, (object)sigma_d=0.0 [, (object)step_size=1.0 [, (float)window_size=0.0 [, (object)roi=None]]]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.structureTensorEigenvalues">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">structureTensorEigenvalues</tt><big>(</big><em>image</em>, <em>innerScale</em>, <em>outerScale</em>, <em>out=None</em>, <em>sigma_d=0.0</em>, <em>step_size=1.0</em>, <em>window_size=0.0</em>, <em>roi=None</em><big>)</big><a class="headerlink" href="#vigra.filters.structureTensorEigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eigenvalues of the structure tensor at the given scales
for a scalar or multi-channel image or volume.</p>
<p>Calls <a class="reference internal" href="#vigra.filters.structureTensor" title="vigra.filters.structureTensor"><tt class="xref py py-func docutils literal"><span class="pre">structureTensor()</span></tt></a> and <a class="reference internal" href="#vigra.filters.tensorEigenvalues" title="vigra.filters.tensorEigenvalues"><tt class="xref py py-func docutils literal"><span class="pre">tensorEigenvalues()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.symmetricGradient">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">symmetricGradient</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.symmetricGradient" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate gradient of a scalar 2D image using symmetric difference filters.
The optional tuple or list &#8216;step_size&#8217; denotes the distance between two adjacent pixels for each dimension; its length must be equal to the number of spatial dimensions.</p>
<p>&#8216;roi&#8217; has the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>symmetricGradient( (object)volume [, (object)out=None [, (object)step_size=1.0 [, (object)roi=None]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorDeterminant">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorDeterminant</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorDeterminant" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the determinant of a 2x2 tensor image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#ga50a97001588cdbec053d23d1d99079eb">tensorDeterminantMultiArray</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>tensorDeterminant( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3x3 tensor volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorEigenRepresentation2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorEigenRepresentation2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorEigenRepresentation2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate eigen representation of a symmetric 2x2 tensor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gac6c6ac6dbf29130be5337bb4d4c4c250">tensorEigenRepresentation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorEigenvalues">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorEigenvalues</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorEigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the eigenvalues in each pixel/voxel of a 2x2 tensor image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#gacc06f88a0cd7dcdb73f0c4af5b0e0312">tensorEigenvaluesMultiArray</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>tensorEigenvalues( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3x3 tensor volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorTrace">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorTrace</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorTrace" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the trace of a 2x2 tensor image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#ga0e407a39a189369be86f6e2a9a4a1415">tensorTraceMultiArray</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>tensorTrace( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3x3 tensor volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.vectorToTensor">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">vectorToTensor</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.vectorToTensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Turn a 2D vector valued image (e.g. the gradient image) into a tensor image by computing the outer product in every pixel.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80">vectorToTensorMultiArray</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>vectorToTensor( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D vector-valued volume.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="sampling-image-resizing-and-image-pyramids">
<h2><a class="toc-backref" href="#id79">Sampling: Image Resizing and Image Pyramids</a><a class="headerlink" href="#sampling-image-resizing-and-image-pyramids" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.sampling contains methods to change the number and/or location of
the image sampling points, such as resizing, rotation, and interpolation.</p>
<span class="target" id="module-vigra.sampling"></span><dl class="function">
<dt id="vigra.sampling.resampleImage">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resampleImage</tt><big>(</big><em>(object)image</em>, <em>(float)factor</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resampleImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample an image by the given &#8216;factor&#8217;</p>
<p>The &#8216;out&#8217; parameter must have, if given, the according dimensions.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga823eb2815225a1fc8771c4138a5ccb1b">resampleImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resamplingGaussian">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resamplingGaussian</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)sigmaX=1.0</em><span class="optional">[</span>, <em>(int)derivativeOrderX=0</em><span class="optional">[</span>, <em>(float)samplingRatioX=2.0</em><span class="optional">[</span>, <em>(float)offsetX=0.0</em><span class="optional">[</span>, <em>(float)sigmaY=1.0</em><span class="optional">[</span>, <em>(int)derivativeOrderY=0</em><span class="optional">[</span>, <em>(float)samplingRatioY=2.0</em><span class="optional">[</span>, <em>(float)offsetY=0.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resamplingGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample image using a gaussian filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">resamplingGaussian</span><span class="p">(</span><span class="n">image</span><span class="p">,</span>
                   <span class="n">sigmaX</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">derivativeOrderX</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">samplingRatioX</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">offsetX</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">sigmaY</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">derivativeOrderY</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">samplingRatioY</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">offsetY</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>This function utilizes <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#gac820754f8e34277afa6f098a2d51303a">resamplingConvolveImage</a> with a Gaussianfilter
(see the vigra C++ documentation for details).</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resize">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resize</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(int)order=3</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resize" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Resize image or volume using B-spline interpolation.</p>
<p>The spline order is given in the parameter &#8216;order&#8217;.
The desired shape of the output array is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree. This function also works for multi-channel data, it is then executed on every channel independently.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga7c1095b357ec19b9edefa849a0a4d178">resizeImageSplineInterpolation</a> and <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305">resizeMultiArraySplineInterpolation</a> in the vigra C++ documentation.</p>
</div></blockquote>
<p>resize( (object)image [, (object)shape=None [, (int)order=3 [, (object)out=None]]]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageCatmullRomInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageCatmullRomInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageCatmullRomInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using the Catmull/Rom interpolation function.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga8c2f8475feaeaf94dcb5df8fd4679d30">resizeImageCatmullRomInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageCoscotInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageCoscotInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageCoscotInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using the Coscot interpolation function.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga725f478e6b802647d77f19c528273947">resizeImageCoscotInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageLinearInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageLinearInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageLinearInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using linear interpolation.
The function uses the standard separable bilinear interpolation algorithm to obtain a good compromise between quality and speed.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga5269b1cd9d82b394fa7cda279a42423b">resizeImageLinearInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageNoInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageNoInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageNoInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image by repeating the nearest pixel values.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#gaad7f1a2f1e089f2e29b486d81741c9f6">resizeImageNoInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageSplineInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageSplineInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(int)order=3</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageSplineInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using B-spline interpolation.</p>
<p>The spline order is given in the parameter &#8216;order&#8217;.
The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga7c1095b357ec19b9edefa849a0a4d178">resizeImageSplineInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeVolumeSplineInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeVolumeSplineInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(int)order=3</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeVolumeSplineInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize volume using B-spline interpolation.</p>
<p>The spline order is given in the parameter &#8216;order&#8217;.
The dimensions of the output volume is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband volumes, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305">resizeMultiArraySplineInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.rotateImageDegree">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">rotateImageDegree</tt><big>(</big><em>(object)image</em>, <em>(float)degree</em><span class="optional">[</span>, <em>(RotationDirection)direction=vigra.sampling.RotationDirection.CLOCKWISE</em><span class="optional">[</span>, <em>(int)splineOrder=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.rotateImageDegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an image by an arbitrary angle using splines for interpolation around its center.</p>
<p>The angle may be given in degree (parameter degree).
The parameter &#8216;splineOrder&#8217; indicates the order of the splines used for interpolation.
If the &#8216;out&#8217; parameter is given, the image is cropped for it&#8217;s dimensions. If the &#8216;out&#8217;
parameter is not given, an output image with the same dimensions as the input image is created.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#gacc7041b192dfb4a79de8d168abd495c9">GeometricTransformations.rotationMatrix2DDegrees</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.rotateImageRadiant">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">rotateImageRadiant</tt><big>(</big><em>(object)image</em>, <em>(float)radiant</em><span class="optional">[</span>, <em>(RotationDirection)direction=vigra.sampling.RotationDirection.CLOCKWISE</em><span class="optional">[</span>, <em>(int)splineOrder=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.rotateImageRadiant" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an image by an arbitrary angle around its center using splines for interpolation.</p>
<p>The angle may be given in radiant (parameter radiant).
The parameter &#8216;splineOrder&#8217; indicates the order of the splines used for interpolation.
If the &#8216;out&#8217; parameter is given, the image is cropped for it&#8217;s dimensions. If the &#8216;out&#8217;
parameter is not given, an output image with the same dimensions as the input image is created.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga814c2b60d8b8579e159e939a76cd6db3">GeometricTransformations.rotationMatrix2DRadians</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.rotateImageSimple">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">rotateImageSimple</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(RotationDirection)orientation=vigra.sampling.RotationDirection.CLOCKWISE</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.rotateImageSimple" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an image by a multiple of 90 degrees.</p>
<p>The &#8216;orientation&#8217; parameter (which must be one of CLOCKWISE, COUNTER_CLOCKWISE and UPSIDE_DOWN
indicates the rotation direction. The &#8216;out&#8217; parameter must, if given, have the according dimensions.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#gaca913f155ee3de0d6c1177d953370f3a">rotateImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<hr class="docutils" />
<p>Spline image views implement an interpolated view for an image which can be accessed
at real-valued coordinates (in contrast to the plain image, which can only be
accessed at integer coordinates). Module vigra.sampling defines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SplineImageView0</span>
<span class="n">SplineImageView1</span>
<span class="n">SplineImageView2</span>
<span class="n">SplineImageView3</span>
<span class="n">SplineImageView4</span>
<span class="n">SplineImageView5</span>
</pre></div>
</div>
<p>The number denotes the spline interpolation order of the respective classes.
Below, we describe SplineImageView3 in detail, but the other classes work
analogously. See <a class="reference external" href="../../doc/vigra/classvigra_1_1SplineImageView.html">SplineImageView</a> in the C++ documentation for more detailed information.</p>
<dl class="class">
<dt id="vigra.sampling.SplineImageView3">
<em class="property">class </em><tt class="descclassname">vigra.sampling.</tt><tt class="descname">SplineImageView3</tt><a class="headerlink" href="#vigra.sampling.SplineImageView3" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>__init__( (object)arg1, (object)arg2) -&gt; object :</dt>
<dd><p class="first">Construct a SplineImageView for the given image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SplineImageView</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">skipPrefilter</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Currently, &#8216;image&#8217; can have dtype numpy.uint8, numpy.int32, and numpy.float32. If &#8216;skipPrefilter&#8217; is True, image values are directly used as spline coefficients, so that the view performs approximation rather than interploation.</p>
</dd>
</dl>
<p>__init__( (object)arg1, (object)arg2) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<dl class="method">
<dt id="vigra.sampling.SplineImageView3.coefficientImage">
<tt class="descname">coefficientImage</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.sampling.SplineImageView3.coefficientImage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dx">
<tt class="descname">dx</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in x direction at a real-valued coordinate.</p>
<p>SplineImageView.dx(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dx3">
<tt class="descname">dx3</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dx3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return third derivative in x direction at a real-valued coordinate.</p>
<p>SplineImageView.dx3(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dx3Image">
<tt class="descname">dx3Image</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dx3Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dx3" title="vigra.sampling.SplineImageView3.dx3"><tt class="xref py py-meth docutils literal"><span class="pre">dx3()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dx3Image(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxImage">
<tt class="descname">dxImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dx" title="vigra.sampling.SplineImageView3.dx"><tt class="xref py py-meth docutils literal"><span class="pre">dx()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxx">
<tt class="descname">dxx</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return second derivative in x direction at a real-valued coordinate.</p>
<p>SplineImageView.dxx(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxxImage">
<tt class="descname">dxxImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxxImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxx" title="vigra.sampling.SplineImageView3.dxx"><tt class="xref py py-meth docutils literal"><span class="pre">dxx()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxxImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxxy">
<tt class="descname">dxxy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mixed third derivative at a real-valued coordinate.</p>
<p>SplineImageView.dxxy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxxyImage">
<tt class="descname">dxxyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxxyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxxy" title="vigra.sampling.SplineImageView3.dxxy"><tt class="xref py py-meth docutils literal"><span class="pre">dxxy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxxyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxy">
<tt class="descname">dxy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mixed second derivative at a real-valued coordinate.</p>
<p>SplineImageView.dxy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxyImage">
<tt class="descname">dxyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxy" title="vigra.sampling.SplineImageView3.dxy"><tt class="xref py py-meth docutils literal"><span class="pre">dxy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxyy">
<tt class="descname">dxyy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxyy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mixed third derivative at a real-valued coordinate.</p>
<p>SplineImageView.dxyy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxyyImage">
<tt class="descname">dxyyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxyyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxyy" title="vigra.sampling.SplineImageView3.dxyy"><tt class="xref py py-meth docutils literal"><span class="pre">dxyy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxyyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dy">
<tt class="descname">dy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in y direction at a real-valued coordinate.</p>
<p>SplineImageView.dy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dy3">
<tt class="descname">dy3</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dy3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return third derivative in y direction at a real-valued coordinate.</p>
<p>SplineImageView.dy3(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dy3Image">
<tt class="descname">dy3Image</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dy3Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dy3" title="vigra.sampling.SplineImageView3.dy3"><tt class="xref py py-meth docutils literal"><span class="pre">dy3()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dy3Image(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dyImage">
<tt class="descname">dyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dy" title="vigra.sampling.SplineImageView3.dy"><tt class="xref py py-meth docutils literal"><span class="pre">dy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dyy">
<tt class="descname">dyy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dyy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return second derivative in y direction at a real-valued coordinate.</p>
<p>SplineImageView.dyy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dyyImage">
<tt class="descname">dyyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dyyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dyy" title="vigra.sampling.SplineImageView3.dyy"><tt class="xref py py-meth docutils literal"><span class="pre">dyy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dyyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.facetCoefficients">
<tt class="descname">facetCoefficients</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.facetCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>SplineImageView.facetCoefficients(x, y) -&gt; matrix</p>
<p>Return the facet coefficient matrix so that spline values can be computed
explicitly. The matrix has size (order+1)x(order+1), where order is 
the order of the spline. The matrix must be multiplied from left and right
with the powers of the local facet x- and y-coordinates respectively
(note that local facet coordinates are in the range [0,1] for odd order
splines and [-0.5, 0.5] for even order splines).</p>
<p>Usage for odd spline order:</p>
<blockquote>
<div>s = SplineImageView3(image)
c = s.coefficients(10.1, 10.7)
x = matrix([1, 0.1, 0.1**2, 0.1**3])
y = matrix([1, 0.7, 0.7**2, 0.7**3])
assert abs(x * c * y.T - s[10.1, 10.7]) &lt; smallNumber</div></blockquote>
<p>Usage for even spline order:</p>
<blockquote>
<div>s = SplineImageView2(image)
c = s.coefficients(10.1, 10.7)
x = matrix([1, 0.1, 0.1**2])
y = matrix([1, -0.3, (-0.3)**2])
assert abs(x * c * y.T - s[10.1, 10.7]) &lt; smallNumber</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2">
<tt class="descname">g2</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return gradient squared magnitude at a real-valued coordinate.</p>
<p>SplineImageView.g2(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2Image">
<tt class="descname">g2Image</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.g2" title="vigra.sampling.SplineImageView3.g2"><tt class="xref py py-meth docutils literal"><span class="pre">g2()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.g2Image(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2x">
<tt class="descname">g2x</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in x direction of the gradient squared magnitude at a real-valued coordinate.</p>
<p>SplineImageView.g2x(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2xImage">
<tt class="descname">g2xImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2xImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.g2x" title="vigra.sampling.SplineImageView3.g2x"><tt class="xref py py-meth docutils literal"><span class="pre">g2x()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.g2xImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2y">
<tt class="descname">g2y</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2y" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in y direction of the gradient squared magnitude at a real-valued coordinate.</p>
<p>SplineImageView.g2y(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2yImage">
<tt class="descname">g2yImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2yImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.g2y" title="vigra.sampling.SplineImageView3.g2y"><tt class="xref py py-meth docutils literal"><span class="pre">g2y()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.g2yImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.height">
<tt class="descname">height</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.sampling.SplineImageView3.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the underlying image.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.interpolatedImage">
<tt class="descname">interpolatedImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">[</span>, <em>(int)xorder=0</em><span class="optional">[</span>, <em>(int)yorder=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.interpolatedImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an interpolated image or derivative image with the given sampling factors and derivative orders. For example, we get a two-fold oversampled image with the x-derivatives in each pixel by:</p>
<p>SplineImageView.interpolatedImage(2.0, 2.0, 1, 0) -&gt; image</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.isInside">
<tt class="descname">isInside</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.sampling.SplineImageView3.isInside" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a coordinate is inside the underlying image.</p>
<p>SplineImageView.isInside(x, y) -&gt; bool</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.isValid">
<tt class="descname">isValid</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.sampling.SplineImageView3.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a coordinate is within the valid range of the SplineImageView.</p>
<p>SplineImageView.isValid(x, y) -&gt; bool</p>
<p>Thanks to reflective boundary conditions, the valid range is three times as big as the size of the underlying image.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.shape">
<tt class="descname">shape</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the underlying image.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.size">
<tt class="descname">size</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.sampling.SplineImageView3.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.width">
<tt class="descname">width</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.sampling.SplineImageView3.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the underlying image.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.sampling.ImagePyramid">
<em class="property">class </em><tt class="descclassname">vigra.sampling.</tt><tt class="descname">ImagePyramid</tt><big>(</big><em>image</em>, <em>copyImageToLevel=0</em>, <em>lowestLevel=0</em>, <em>highestLevel=0</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></p>
<p>Create a new pyramid.
The new pyramid levels range from &#8216;lowestLevel&#8217; to &#8216;highestLevel&#8217; (inclusive),
and the given &#8216;image&#8217; is copied to &#8216;copyImageToLevel&#8217;. The images at other
levels are filled with zeros and sized so that the shape is reduced by half
when going up (to higher levels), and doubled when going down.</p>
<p>This class can handle multi-channel images, but only when image.channelIndex
exists and returns image.ndim-1 (i.e. the image must have axistags, and the 
channel axis must correspond to the last index, as in C- or V-order).</p>
<dl class="method">
<dt id="vigra.sampling.ImagePyramid.createLevel">
<tt class="descname">createLevel</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.createLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that &#8216;level&#8217; exists. If &#8216;level&#8217; is outside the current range of levels,
empty images of the appropriate shape are inserted into the pyramid.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.expand">
<tt class="descname">expand</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;. srcLevel must be larger than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#ga3abb6e1a494b5d3ce952dbacf71c3092">pyramidExpandBurtFilter</a> in the C++ documentation.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.expandLaplacian">
<tt class="descname">expandLaplacian</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.expandLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;, and reconstruct the images for the levels
srcLevel-1 ... destLevel from their Laplacian images. srcLevel must be larger than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#ga220bd2af2ffb47ed8ed6ba583207c079">pyramidExpandBurtLaplacian</a> in the C++ documentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.highestLevel">
<tt class="descname">highestLevel</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.highestLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The pyramids highest level (inclusive).</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.lowestLevel">
<tt class="descname">lowestLevel</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.lowestLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The pyramids lowest level.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.reduce">
<tt class="descname">reduce</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;. srcLevel must be smaller than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#gafde4a3aeaffdb86f415419444acf49e7">pyramidReduceBurtFilter</a> in the C++ documentation.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.reduceLaplacian">
<tt class="descname">reduceLaplacian</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.reduceLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;, and compute Laplacian images for the levels
srcLevel ... destLevel-1. srcLevel must be smaller than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#ga6608e09fdd3756af97586288bc2db2c7">pyramidReduceBurtLaplacian</a> in the C++ documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fourier-transforms">
<h2><a class="toc-backref" href="#id80">Fourier Transforms</a><a class="headerlink" href="#fourier-transforms" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.fourier contains functions for Fourier transforms, Cosine/Sine
transforms, and Fourier-domain filters.</p>
<span class="target" id="module-vigra.fourier"></span><dl class="function">
<dt id="vigra.fourier.angularGaborSigma">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">angularGaborSigma</tt><big>(</big><em>(int)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.fourier.angularGaborSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sensible angular sigma for given parameters.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.createGaborFilter">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">createGaborFilter</tt><big>(</big><em>(object)shape</em>, <em>(float)orientation</em>, <em>(float)centerFrequency</em>, <em>(float)angularSigma</em>, <em>(float)radialSigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.fourier.createGaborFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 2-dimensional gabor filter in frequency space.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.fourierTransform">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">fourierTransform</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.fourier.fourierTransform" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Perform 2-dimensional Fourier transformation of a scalar float32 image.If the input array has multiple channels, each channel is transformed separately.</div></blockquote>
<dl class="docutils">
<dt>fourierTransform( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D float32 volume.</dd>
<dt>fourierTransform( (object)image [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D complex64 image.</dd>
<dt>fourierTransform( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D complex64 volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.fourierTransformInverse">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">fourierTransformInverse</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.fourier.fourierTransformInverse" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Perform 2-dimensional inverse Fourier transformation of a complex64 array.If the input array has multiple channels, each channel is transformed separately.</div></blockquote>
<dl class="docutils">
<dt>fourierTransformInverse( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D complex128 volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.radialGaborSigma">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">radialGaborSigma</tt><big>(</big><em>(float)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.fourier.radialGaborSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sensible radial sigma for given parameters.</p>
</dd></dl>

</div>
<div class="section" id="image-analysis">
<h2><a class="toc-backref" href="#id81">Image Analysis</a><a class="headerlink" href="#image-analysis" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.analysis contains segmentation algorithms (e.g. watershed), edge and
corner detection, localization of maxima and minima etc.</p>
<span class="target" id="module-vigra.analysis"></span><dl class="class">
<dt id="vigra.analysis.Edgel">
<em class="property">class </em><tt class="descclassname">vigra.analysis.</tt><tt class="descname">Edgel</tt><a class="headerlink" href="#vigra.analysis.Edgel" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent an Edgel at a particular subpixel position (x, y), having given &#8216;strength&#8217; and &#8216;orientation&#8217;.</p>
<p>For details, see <a class="reference external" href="../../doc/vigra/classvigra_1_1Edgel.html">Edgel</a> in the vigra C++ documentation.</p>
<dl class="docutils">
<dt>__init__( (object)arg1) -&gt; None :</dt>
<dd><p class="first">Standard constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Edgel</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>__init__( (object)arg1, (float)x, (float)y, (float)strength, (float)orientation) -&gt; None :</dt>
<dd><p class="first">Constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Edgel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="attribute">
<dt id="vigra.analysis.Edgel.orientation">
<tt class="descname">orientation</tt><a class="headerlink" href="#vigra.analysis.Edgel.orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s orientation.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.analysis.Edgel.strength">
<tt class="descname">strength</tt><a class="headerlink" href="#vigra.analysis.Edgel.strength" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s strength.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.analysis.Edgel.x">
<tt class="descname">x</tt><a class="headerlink" href="#vigra.analysis.Edgel.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s x position.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.analysis.Edgel.y">
<tt class="descname">y</tt><a class="headerlink" href="#vigra.analysis.Edgel.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s y position.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.analysis.FeatureAccumulator">
<em class="property">class </em><tt class="descclassname">vigra.analysis.</tt><tt class="descname">FeatureAccumulator</tt><a class="headerlink" href="#vigra.analysis.FeatureAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of this accumulator class is returned by <a class="reference internal" href="#vigra.analysis.extractFeatures" title="vigra.analysis.extractFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractFeatures()</span></tt></a>. The object contains the computed features (i.e. the selected features and their dependencies).</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.activeFeatures">
<tt class="descname">activeFeatures</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.activeFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all computed features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.createAccumulator">
<tt class="descname">createAccumulator</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; FeatureAccumulator :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.createAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an empty accumulator with the same active features as &#8216;self&#8217;. This is useful for merging.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.isActive">
<tt class="descname">isActive</tt><big>(</big><em>(FeatureAccumulator)arg1</em>, <em>(str)feature</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.isActive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if &#8216;feature&#8217; has been computed and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.keys">
<tt class="descname">keys</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all computed features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.merge">
<tt class="descname">merge</tt><big>(</big><em>(FeatureAccumulator)arg1</em>, <em>(FeatureAccumulator)other</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge features with the features from accumulator &#8216;other&#8217;. Raises a TypeError when &#8216;other&#8217; is incompatible with &#8216;self&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.supportedFeatures">
<tt class="descname">supportedFeatures</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.supportedFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all supported features for the given input data array.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.analysis.RegionFeatureAccumulator">
<em class="property">class </em><tt class="descclassname">vigra.analysis.</tt><tt class="descname">RegionFeatureAccumulator</tt><a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of this accumulator class is returned by <a class="reference internal" href="#vigra.analysis.extractRegionFeatures" title="vigra.analysis.extractRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractRegionFeatures()</span></tt></a> and contains the computed global and per-region features.</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.activeFeatures">
<tt class="descname">activeFeatures</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.activeFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all selected features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.createAccumulator">
<tt class="descname">createAccumulator</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; RegionFeatureAccumulator :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.createAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an empty accumulator with the same active features as &#8216;self&#8217;. This is useful for merging.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.isActive">
<tt class="descname">isActive</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em>, <em>(str)feature</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.isActive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if &#8216;feature&#8217; has been computed and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.keys">
<tt class="descname">keys</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all selected features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.maxRegionLabel">
<tt class="descname">maxRegionLabel</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.maxRegionLabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest region label in this accumulator.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.merge">
<tt class="descname">merge</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em>, <em>(RegionFeatureAccumulator)other</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.merge" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Merge features with the features from accumulator &#8216;other&#8217;. &#8216;self&#8217; and &#8216;other&#8217; must have the same <cite>maxRegionLabel`(), or &#8216;self&#8217; must be an empty accumulator (as returned by `create</cite>).</div></blockquote>
<dl class="docutils">
<dt>merge( (RegionFeatureAccumulator)arg1, (FeatureAccumulator)other, (object)labelMap) -&gt; None :</dt>
<dd>Merge features with the features from accumulator &#8216;other&#8217;. The &#8216;labelMap&#8217; determines the correspondence of regions between &#8216;self&#8217; and &#8216;other&#8217; (i.e. region k of accumulator &#8216;other&#8217; is merged into region labelMap[k] of &#8216;self&#8217;).</dd>
<dt>merge( (RegionFeatureAccumulator)arg1, (int)i, (int)j) -&gt; None :</dt>
<dd>Merge features from region &#8216;j&#8217; into region &#8216;i&#8217; of this accumulator.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.supportedFeatures">
<tt class="descname">supportedFeatures</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.supportedFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all supported features for the given input arrays.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="vigra.analysis.beautifyCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">beautifyCrackEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(int)edgeMarker</em>, <em>(int)backgroundMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.beautifyCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Beautify crack edge image for visualization.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga372f1a443c561d454cf46a517f0425e0">beautifyCrackEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cannyEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in an edge image using Canny&#8217;s algorithm.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga729ddcc1323a9c0fd31c52812f08adb6">cannyEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgeImageWithThinning">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgeImageWithThinning</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(bool)addBorder=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cannyEdgeImageWithThinning" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in an edge image using Canny&#8217;s algorithm.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga9aa609d12e327e0d633047b78d61c84e">cannyEdgeImageWithThinning</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgelList">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgelList</tt><big>(</big><em>(object)gradient</em>, <em>(float)threshold</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.cannyEdgelList" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return a list of <a class="reference internal" href="#vigra.analysis.Edgel" title="vigra.analysis.Edgel"><tt class="xref py py-class docutils literal"><span class="pre">Edgel</span></tt></a> objects whose strength is at least &#8216;threshold&#8217;.</p>
<p>The function comes in two forms:</p>
<div class="highlight-python"><pre>cannyEdgelList(gradient, threshold) -&gt; list
cannyEdgelList(image, scale, threshold) -&gt; list</pre>
</div>
<p>The first form expects a gradient image (i.e. with two channels) to compute edgels, whereas the second form expects a scalar image and computes the gradient internally at &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#gaf2233c5ec0e42a15134feda453f6fca5">cannyEdgelList</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>cannyEdgelList( (object)image, (float)scale, (float)threshold) -&gt; list :</dt>
<dd>Compute edgels of a 2D scalar image, given the filter scale.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgelList3x3">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgelList3x3</tt><big>(</big><em>(object)gradient</em>, <em>(float)threshold</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.cannyEdgelList3x3" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return a list of <a class="reference internal" href="#vigra.analysis.Edgel" title="vigra.analysis.Edgel"><tt class="xref py py-class docutils literal"><span class="pre">Edgel</span></tt></a> objects whose strength is at least &#8216;threshold&#8217;.</p>
<p>The function comes in two forms:</p>
<div class="highlight-python"><pre>cannyEdgelList3x3(gradient, threshold) -&gt; list
cannyEdgelList3x3(image, scale, threshold) -&gt; list</pre>
</div>
<p>The first form expects a gradient image (i.e. with two channels) to compute edgels, whereas the second form expects a scalar image and computes the gradient internally at &#8216;scale&#8217;. The results are slightly better than those of <a class="reference internal" href="#vigra.analysis.cannyEdgelList" title="vigra.analysis.cannyEdgelList"><tt class="xref py py-func docutils literal"><span class="pre">cannyEdgelList()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga04e860482291f33d59c0992b479041e6">cannyEdgelList3x3</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>cannyEdgelList3x3( (object)image, (float)scale, (float)threshold) -&gt; list :</dt>
<dd>Compute edgels of a 2D scalar image, given the filter scale.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.closeGapsInCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">closeGapsInCrackEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.closeGapsInCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Close one-pixel wide gaps in a cell grid edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#gab9c56ad0d2769ad7ddca5708e7adfee5">closeGapsInCrackEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessBeaudet">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessBeaudet</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessBeaudet" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Beaudet at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#ga0c750a26d679a2ea13fd697dac73a123">beaudetCornerDetector</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessBoundaryTensor">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessBoundaryTensor</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessBoundaryTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the boundary tensor at the given &#8216;scale&#8217;.</p>
<p>Specifically, the cornerness is defined as twice the small eigenvalue of the boundary tensor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gab4ee0f19130a109119cc9cbc594ed1b7">boundaryTensor</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessFoerstner">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessFoerstner</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessFoerstner" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Foerstner at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#gab70e0f0cec3312e4b0df415c6b2a733b">foerstnerCornerDetector</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessHarris">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessHarris</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessHarris" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Harris at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#ga8ac6885918f92043c688fca04401248f">cornerResponseFunction</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessRohr">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessRohr</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessRohr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Rohr at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#ga425b0f1d2d17b7aa2518dff5cd1abd8e">rohrCornerDetector</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMaxima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMaxima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extendedLocalMaxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima and maximal plateaus in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#gacf065fa5d3b1f0e8b2b6eedc742e117a">extendedLocalMaxima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMaxima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMaxima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extendedLocalMaxima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima and maximal plateaus in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 (default) or 26 .</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga0db91012c965e9950ae09ab25ec2c786">extendedLocalMaxima3D</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMinima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMinima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.analysis.extendedLocalMinima" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>extendedLocalMinima( (object)image [, (float)marker=1.0 [, (int)neighborhood=8 [, (object)out=None]]]) -&gt; object :</dt>
<dd><p class="first">Find local minima and minimal plateaus in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga5d85854a266cf6f5d4bff98b34e123fb">extendedLocalMinima</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMinima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMinima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.analysis.extendedLocalMinima3D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>extendedLocalMinima3D( (object)volume [, (int)marker=1 [, (int)neighborhood=6 [, (object)out=None]]]) -&gt; object :</dt>
<dd><p class="first">Find local minima and minimal plateaus in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6(default) or 26 .</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#gad1280b5f8335ebdadbb45a1b8cf8e8f5">extendedLocalMinima3D</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extractFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extractFeatures</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)features='all'</em><span class="optional">]</span><big>)</big> &rarr; FeatureAccumulator :<a class="headerlink" href="#vigra.analysis.extractFeatures" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Extract global features (e.g. Mean, Variance, Minimum, etc.)
from the input array (&#8216;image&#8217; or &#8216;volume&#8217;). An accumulator object
of type <a class="reference internal" href="#vigra.analysis.FeatureAccumulator" title="vigra.analysis.FeatureAccumulator"><tt class="xref py py-class docutils literal"><span class="pre">FeatureAccumulator</span></tt></a> is returned that holds the computed
features.</p>
<p>The overloaded function extractFeatures() supports 2D or 3D
arrays with arbitrary many channels. The element type of the
input array must be <strong>dtype=numpy.float32</strong>. The set of available features
depends on the input array. The &#8216;Histogram&#8217; feature, for example,
is only supported for singleband arrays. Call <a class="reference internal" href="#vigra.analysis.supportedFeatures" title="vigra.analysis.supportedFeatures"><tt class="xref py py-func docutils literal"><span class="pre">supportedFeatures()</span></tt></a>
with the same input array to get a list of all available features
for this input.</p>
<p>The argument &#8216;features&#8217; can take the following values:</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;all&#8217;: compute all supported features (default)</p>
</li>
<li><p class="first">name:  compute a single feature (and its dependencies)</p>
</li>
<li><p class="first">[name1, name2,...]:  compute the given features plus dependencies</p>
</li>
<li><dl class="first docutils">
<dt>None or &#8216;&#8217;:  return an empty accumulator, whose method </dt>
<dd><p class="first last"><a class="reference internal" href="#vigra.analysis.FeatureAccumulator.supportedFeatures" title="vigra.analysis.FeatureAccumulator.supportedFeatures"><tt class="xref py py-meth docutils literal"><span class="pre">supportedFeatures()</span></tt></a>
tells you the list of supported features for the
given input array.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>To compute per-region features, use <a class="reference internal" href="#vigra.analysis.extractRegionFeatures" title="vigra.analysis.extractRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractRegionFeatures()</span></tt></a>.</p>
<p>This overload is called for 2D input arrays two or more than
four channels. Histograms and quantiles are not supported for
this input.</p>
<p>For further details about the meaning of the features, see
<a class="reference external" href="../vigra/group__FeatureAccumulators.html">Feature Accumulators</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractFeatures( (object)volume [, (object)features=&#8217;all&#8217;]) -&gt; FeatureAccumulator :</dt>
<dd>Overload for 3D arrays with arbitrary many channels.
Histograms and quantiles are not supported for this input.</dd>
<dt>extractFeatures( (object)image [, (object)features=&#8217;all&#8217;]) -&gt; FeatureAccumulator :</dt>
<dd>Likewise for 2D arrays with 3 channels.
Histograms and quantiles are not supported for this input.</dd>
<dt>extractFeatures( (object)volume [, (object)features=&#8217;all&#8217;]) -&gt; FeatureAccumulator :</dt>
<dd>Likewise for 3D arrays with 3 channels.
Histograms and quantiles are not supported for this input.</dd>
</dl>
<p>extractFeatures( (object)image [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64]]]) -&gt; FeatureAccumulator :</p>
<blockquote>
<div><p>This overload of extractFeatures() computes global statistics for a
2D scalar input array, e.g. <a class="reference internal" href="#vigra.ScalarImage" title="vigra.ScalarImage"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarImage</span></tt></a></p>
<p>Features &#8216;Histogram&#8217; and &#8216;Quantiles&#8217; are supported for this input.
Options are:</p>
<blockquote>
<div><ul>
<li><p class="first">histogramRange: lower and upper bound of the histogram</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;globalminmax&#8217;:  compute and use global minimum/maximum (default)</p>
</li>
<li><dl class="first docutils">
<dt>[lower, upper]:  provide explicit bounds (float numbers),</dt>
<dd><p class="first last">useful to ensure that merge will be allowed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">binCount: number of bins (default: 64).</p>
</li>
</ul>
</div></blockquote>
<p>Histogram options are ignored when the histogram feature is not selected.
Quantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from
the specified histogram.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractFeatures( (object)volume [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64]]]) -&gt; FeatureAccumulator :</dt>
<dd>Likewise for a scalar 3D input array, e.g. <a class="reference internal" href="#vigra.ScalarVolume" title="vigra.ScalarVolume"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarVolume</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extractRegionFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extractRegionFeatures</tt><big>(</big><em>(object)image</em>, <em>(object)labels</em><span class="optional">[</span>, <em>(object)features='all'</em><span class="optional">[</span>, <em>(object)ignoreLabel=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; RegionFeatureAccumulator :<a class="headerlink" href="#vigra.analysis.extractRegionFeatures" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Extract region features from an input array with <strong>dtype=numpy.float32</strong>
and return a <a class="reference internal" href="#vigra.analysis.RegionFeatureAccumulator" title="vigra.analysis.RegionFeatureAccumulator"><tt class="xref py py-class docutils literal"><span class="pre">RegionFeatureAccumulator</span></tt></a> object.</p>
<p>Membership of the array elements (pixels) to regions is specified
by a &#8216;labels&#8217; array with element type <strong>dtype=uint32</strong>.</p>
<p>The set of available features depends on the input array.
Call <a class="reference internal" href="#vigra.analysis.supportedRegionFeatures" title="vigra.analysis.supportedRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">supportedRegionFeatures()</span></tt></a> with the same input and label
arrays to get a list of all available features for these inputs.</p>
<p>The argument &#8216;features&#8217; can take the following values:</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;all&#8217;: compute all supported features (default)</p>
</li>
<li><p class="first">name:  compute a single feature (and its dependencies)</p>
</li>
<li><p class="first">[name1, name2,...]:  compute the given features plus dependencies</p>
</li>
<li><dl class="first docutils">
<dt>None or &#8216;&#8217;:  return an empty accumulator, whose method </dt>
<dd><p class="first last"><a class="reference internal" href="#vigra.analysis.RegionFeatureAccumulator.supportedFeatures" title="vigra.analysis.RegionFeatureAccumulator.supportedFeatures"><tt class="xref py py-meth docutils literal"><span class="pre">supportedFeatures()</span></tt></a>
tells you the list of supported features for the
given input array.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>When the feature name starts with &#8216;Global&#8217;, the feature is computed
globally, i.e. without considering region membership.</p>
<p>The argument &#8216;ignoreLabel&#8217; is useful when the label array contains
a background region (usually label 0) that should be ignored during
feature computation. If &#8216;ignoreLabel&#8217; is None (the default), all
region labels are used.</p>
<p>This overload is called for 2D input arrays with two or more than
four channels. Histograms and quantiles are not supported for this
input.</p>
<p>For further details about the meaning of the features, see
<a class="reference external" href="../vigra/group__FeatureAccumulators.html">Feature Accumulators</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractRegionFeatures( (object)volume, (object)labels [, (object)features=&#8217;all&#8217; [, (object)ignoreLabel=None]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>Likewise for a 3D input array  with two or more than four channels.
Histograms and quantiles are not supported for this input.</dd>
<dt>extractRegionFeatures( (object)image, (object)labels [, (object)features=&#8217;all&#8217; [, (object)ignoreLabel=None]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>This overload of extractRegionFeatures() is called for
2D input arrays with 3 channels.</dd>
<dt>extractRegionFeatures( (object)volume, (object)labels [, (object)features=&#8217;all&#8217; [, (object)ignoreLabel=None]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>This overload of extractRegionFeatures() is called for
3D input arrays with 3 channels.</dd>
</dl>
<p>extractRegionFeatures( (object)image, (object)labels [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64 [, (object)ignoreLabel=None]]]]) -&gt; RegionFeatureAccumulator :</p>
<blockquote>
<div><p>This overload of extractRegionFeatures() computes region statistics
for a scalar 2D input array, e.g. <a class="reference internal" href="#vigra.ScalarImage" title="vigra.ScalarImage"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarImage</span></tt></a>.</p>
<p>Features &#8216;Histogram&#8217; and &#8216;Quantiles&#8217; are supported for this input. Options are:</p>
<blockquote>
<div><ul>
<li><p class="first">histogramRange: lower and upper bound of the histogram</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;globalminmax&#8217;:  compute and use global minimum/maximum (default)</p>
</li>
<li><p class="first">&#8216;regionminmax&#8217;:   use minimum/maximum within each region</p>
</li>
<li><dl class="first docutils">
<dt>[lower, upper]:  provide explicit bounds (float numbers),</dt>
<dd><p class="first last">useful to ensure that merge will be allowed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">binCount: number of bins (default: 64).</p>
</li>
</ul>
</div></blockquote>
<p>Histogram options are ignored when Histogram feature is not selected.
Quantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from
the specified histogram.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractRegionFeatures( (object)volume, (object)labels [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64 [, (object)ignoreLabel=None]]]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>Likewise for 3D scalar arrays, e.g. <a class="reference internal" href="#vigra.ScalarVolume" title="vigra.ScalarVolume"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarVolume</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelImage</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)neighborhood=4</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.analysis.labelImage" title="Permalink to this definition">¶</a></dt>
<dd><p>labelImage( (object)image [, (int)neighborhood=4 [, (object)out=None]]) -&gt; object</p>
<dl class="docutils">
<dt>labelImage( (object)image [, (int)neighborhood=4 [, (object)out=None]]) -&gt; object :</dt>
<dd><p class="first">Find the connected components of a segmented image. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 (default) or 8.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga25fed81e4512334de2cfa257d38972b2">labelImage</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelImageWithBackground">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelImageWithBackground</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)neighborhood=4</em><span class="optional">[</span>, <em>(int)background_value=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.analysis.labelImageWithBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>labelImageWithBackground( (object)image [, (int)neighborhood=4 [, (int)background_value=0 [, (object)out=None]]]) -&gt; object</p>
<dl class="docutils">
<dt>labelImageWithBackground( (object)image [, (int)neighborhood=4 [, (float)background_value=0 [, (object)out=None]]]) -&gt; object :</dt>
<dd><p class="first">Find the connected components of a segmented image, excluding the background from labeling, where the background is the set of all pixels with the given &#8216;background_value&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 (default) or 8.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#gad8d7c944ead026988c0a3bcadd8076b6">labelImageWithBackground</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelVolume">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelVolume</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.analysis.labelVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>labelVolume( (object)volume [, (int)neighborhood=6 [, (object)out=None]]) -&gt; object</p>
<dl class="docutils">
<dt>labelVolume( (object)volume [, (int)neighborhood=6 [, (object)out=None]]) -&gt; object :</dt>
<dd><p class="first">Find the connected components of a segmented volume. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 (default) or 26.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga89a6b1e5784831c7145612bd738f3112">labelVolume</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelVolumeWithBackground">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelVolumeWithBackground</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(int)background_value=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.analysis.labelVolumeWithBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>labelVolumeWithBackground( (object)volume [, (int)neighborhood=6 [, (int)background_value=0 [, (object)out=None]]]) -&gt; object</p>
<dl class="docutils">
<dt>labelVolumeWithBackground( (object)volume [, (int)neighborhood=6 [, (float)background_value=0 [, (object)out=None]]]) -&gt; object :</dt>
<dd><p class="first">Find the connected components of a segmented volume, excluding the background from labeling, where the background is the set of all pixels with the given &#8216;background_value&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 (default) or 26.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga9ea391a72baa327cf6b3c7ac555d1c75">labelVolumeWithBackground</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMaxima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMaxima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMaxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMaxima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMaxima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMaxima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima and maximal plateaus in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6(default) or 26 .</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#gaf7d58b90367742c7d20d9b47b82129b6">localMaxima3D</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMinima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMinima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMinima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga527dfba5468e97ca7f1d676d34bc7162">localMinima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMinima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMinima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMinima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 or 26 (default).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#gac845c0bf489cfea8b5caabb8ac827609">localMinima3D</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.regionImageToCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">regionImageToCrackEdgeImage</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)edgeLabel=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.regionImageToCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Transform a labeled uint32 image into a crack edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga0d13d25c5b735aaca90c5a506bb274ac">regionImageToCrackEdgeImage</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>regionImageToCrackEdgeImage( (object)image [, (int)edgeLabel=0 [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a uint64 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.regionImageToEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">regionImageToEdgeImage</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)edgeLabel=1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.regionImageToEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Transform a labeled uint32 image into an edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga6b16eb7df332ab9392e0927c2b5383e2">regionImageToEdgeImage</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>regionImageToEdgeImage( (object)image [, (int)edgeLabel=1 [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a uint64 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.removeShortEdges">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">removeShortEdges</tt><big>(</big><em>(object)image</em>, <em>(int)minEdgeLength</em>, <em>(int)nonEdgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.removeShortEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove short edges from an edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga6f9601dcf8f062b88b8cb80b8fdd76a5">removeShortEdges</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.shenCastanCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">shenCastanCrackEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.shenCastanCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga52ce27e210e918ed15281dff03ee712e">differenceOfExponentialCrackEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.shenCastanEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">shenCastanEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.shenCastanEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga82468161d9b270516e72ab0bc76f63b7">differenceOfExponentialEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.slicSuperpixels">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">slicSuperpixels</tt><big>(</big><em>(object)image</em>, <em>(float)intensityScaling</em>, <em>(int)seedDistance</em><span class="optional">[</span>, <em>(int)minSize=0</em><span class="optional">[</span>, <em>(int)iterations=10</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.analysis.slicSuperpixels" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>slicSuperpixels( (object)image, (float)intensityScaling, (int)seedDistance [, (int)minSize=0 [, (int)iterations=10 [, (object)out=None]]]) -&gt; tuple :</dt>
<dd><p class="first">Compute Slic superpixels for a 2D image.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>image:</dt>
<dd>The 2D-image on which the superpixels will be calculated. Accepts single- and threeband images.</dd>
<dt>intensityScaling:</dt>
<dd>Scale (divide) color/intensity difference by this parameter before comparing to spatial distance.</dd>
<dt>seedDistance:</dt>
<dd>specify the radius of the window around each seed in which the algorithm looks for potential members of the corresponding superpixel thus limiting the superpixel size. The grid spacing for seed placement is determined by this parameter.</dd>
<dt>minSize:</dt>
<dd>Minimum size for superpixels. By default the algorithm merges all regions smaller than a quarter of the average superpixel size.</dd>
<dt>iterations:</dt>
<dd>Specify number of iterations. The default is 10. out:
The label image (with dtype=numpy.uint32) to be filled by the algorithm.     It will be allocated by the slicSuperpixels function if not provided)</dd>
</dl>
</div></blockquote>
<p class="last">The function returns a Python tuple (labelImage, maxRegionLabel)</p>
</dd>
</dl>
<p>slicSuperpixels( (object)image, (float)intensityScaling, (int)seedDistance [, (int)minSize=0 [, (int)iterations=10 [, (object)out=None]]]) -&gt; tuple</p>
<dl class="docutils">
<dt>slicSuperpixels( (object)image, (float)intensityScaling, (int)seedDistance [, (int)minSize=0 [, (int)iterations=10 [, (object)out=None]]]) -&gt; tuple :</dt>
<dd>Likewise compute Slic superpixels for a 3D volume, either single- or threeband.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.supportedFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">supportedFeatures</tt><big>(</big><em>array</em><big>)</big><a class="headerlink" href="#vigra.analysis.supportedFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of feature names that are available for the given array. These feature
names are the valid inputs to a call of <a class="reference internal" href="#vigra.analysis.extractFeatures" title="vigra.analysis.extractFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractFeatures()</span></tt></a>. E.g., to compute 
just the first two features in the list, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">supportedFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Computing features:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extractFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.supportedRegionFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">supportedRegionFeatures</tt><big>(</big><em>array</em>, <em>labels</em><big>)</big><a class="headerlink" href="#vigra.analysis.supportedRegionFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of feature names that are available for the given array and label array. 
These feature names are the valid inputs to a call of 
<a class="reference internal" href="#vigra.analysis.extractRegionFeatures" title="vigra.analysis.extractRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractRegionFeatures()</span></tt></a>. E.g., to compute just the first two features in the 
list, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">supportedRegionFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Computing features:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extractRegionFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.watersheds">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">watersheds</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)neighborhood=4</em><span class="optional">[</span>, <em>(object)seeds=None</em><span class="optional">[</span>, <em>(str)method=''</em><span class="optional">[</span>, <em>(SRGType)terminate=vigra.analysis.SRGType.CompleteGrow</em><span class="optional">[</span>, <em>(int)max_cost=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.analysis.watersheds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>watersheds( (object)image [, (int)neighborhood=4 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (float)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple :</dt>
<dd><p class="first">Compute the watersheds of a 2D image.</p>
<blockquote>
<div><dl class="docutils">
<dt>watersheds(image, neighborhood=4, seeds = None, methods = &#8216;RegionGrowing&#8217;, </dt>
<dd>terminate=CompleteGrow, threshold=0, out = None) -&gt; (labelimage, max_ragion_label)</dd>
</dl>
</div></blockquote>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>image:</dt>
<dd>the image or volume containing the boundary indicator values     (high values = high edgeness, dtype=numpy.uint8 or numpy.float32).</dd>
<dt>neighborhood:</dt>
<dd><p class="first">the pixel neighborhood to be used. Feasible values depend on the     dimension and method:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>2-dimensional data:</dt>
<dd>4 (default) or 8.</dd>
<dt>3-dimensional data:</dt>
<dd>6 (default) or 26</dd>
</dl>
</div></blockquote>
</dd>
<dt>seeds:</dt>
<dd>a label image specifying region seeds, only supported by methods &#8216;RegionGrowing&#8217; and &#8216;Turbo&#8217;    (with dtype=numpy.uint32).</dd>
<dt>method:</dt>
<dd><p class="first">the algorithm to be used for watershed computation. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;Turbo&#8217;:</dt>
<dd>(default if input dtype == uint8) use <a href="#id88"><span class="problematic" id="id89">fastSeededRegionGrowing_</span></a> or tws() respectively</dd>
<dt>&#8216;RegionGrowing&#8217;:</dt>
<dd>(default if input dtype != uint8) use <a class="reference external" href="../../doc/vigra/group__SeededRegionGrowing.html#ga7b54436edf7b15b9628d17a22917b4b1">seededRegionGrowing</a> or <a class="reference external" href="../../doc/vigra/group__SeededRegionGrowing.html#gae9e3ebc5978a393267485d426141a201">seededRegionGrowing3D</a> respectively</dd>
<dt>&#8216;UnionFind:</dt>
<dd>use <a class="reference external" href="../../doc/vigra/group__SeededRegionGrowing.html#ga798e1da19d24c46a3762057b1708e8b3">watershedsUnionFind</a> or <a class="reference external" href="../../doc/vigra/group__SeededRegionGrowing.html#ga848b9a3983f20e8ad753d104aad16810">watersheds3D</a> respectively</dd>
</dl>
</div></blockquote>
</dd>
<dt>terminate:</dt>
<dd><p class="first">when to stop growing. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>CompleteGrow:</dt>
<dd>(default) grow until all pixels are assigned to a region</dd>
<dt>KeepCountours:</dt>
<dd>keep a 1-pixel wide contour between all regions, only supported         by method &#8216;RegionGrowing&#8217;</dd>
<dt>StopAtThreshold:</dt>
<dd>stop when the boundary indicator values exceed the threshold given by         parameter &#8216;max_cost&#8217;, only supported by method &#8216;RegionGrowing&#8217;</dd>
<dt>KeepCountours | StopAtThreshold:</dt>
<dd>keep 1-pixel wide contour and stop at given &#8216;max_cost&#8217;, only         supported by method &#8216;RegionGrowing&#8217;</dd>
</dl>
</div></blockquote>
</dd>
<dt>max_cost:</dt>
<dd>terminate growing when boundary indicator exceeds this value (ignored when     &#8216;terminate&#8217; is not StopAtThreshold or method is not &#8216;RegionGrowing&#8217;)</dd>
<dt>out:</dt>
<dd>the label image (with dtype=numpy.uint32) to be filled by the algorithm.     It will be allocated by the watershed function if not provided)</dd>
</dl>
</div></blockquote>
<p class="last">The function returns a Python tuple (labelImage, maxRegionLabel)</p>
</dd>
</dl>
<p>watersheds( (object)volume [, (int)neighborhood=6 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (int)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple</p>
<dl class="docutils">
<dt>watersheds( (object)volume [, (int)neighborhood=6 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (float)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple :</dt>
<dd>Likewise, compute watersheds of a volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.watershedsNew">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">watershedsNew</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)neighborhood=4</em><span class="optional">[</span>, <em>(object)seeds=None</em><span class="optional">[</span>, <em>(str)method=''</em><span class="optional">[</span>, <em>(SRGType)terminate=vigra.analysis.SRGType.CompleteGrow</em><span class="optional">[</span>, <em>(int)max_cost=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.analysis.watershedsNew" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>watershedsNew( (object)image [, (int)neighborhood=4 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (float)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple :</dt>
<dd>graph-based watershed</dd>
</dl>
<p>watershedsNew( (object)image [, (int)neighborhood=6 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (int)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple</p>
<dl class="docutils">
<dt>watershedsNew( (object)image [, (int)neighborhood=6 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (float)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple :</dt>
<dd>graph-based watershed</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.watershedsUnionFind">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">watershedsUnionFind</tt><big>(</big><em>image</em>, <em>neighborhood=None</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.analysis.watershedsUnionFind" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute watersheds of an image using the union find algorithm.
If &#8216;neighborhood&#8217; is &#8216;None&#8217;, it defaults to 8-neighborhood for 2D inputs
and 6-neighborhood for 3D inputs.</p>
<p>Calls <a class="reference internal" href="#vigra.analysis.watersheds" title="vigra.analysis.watersheds"><tt class="xref py py-func docutils literal"><span class="pre">watersheds()</span></tt></a> with parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">watersheds</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">neighborhood</span><span class="o">=</span><span class="n">neighborhood</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;UnionFind&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="geometry">
<h2><a class="toc-backref" href="#id82">Geometry</a><a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.geometry contains geometric primitives (such as polygons) and related algorithms.</p>
<span class="target" id="module-vigra.geometry"></span><dl class="function">
<dt id="vigra.geometry.convexHull">
<tt class="descclassname">vigra.geometry.</tt><tt class="descname">convexHull</tt><big>(</big><em>(object)points</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.geometry.convexHull" title="Permalink to this definition">¶</a></dt>
<dd><p>convexHull( (object)points) -&gt; object</p>
<dl class="docutils">
<dt>convexHull( (object)points) -&gt; object :</dt>
<dd><p class="first">Compute the convex hull of a point set.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__MathFunctions.html#ga8ba489a131e75016f32095b106659d22">convexHull</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="optimization">
<h2><a class="toc-backref" href="#id83">Optimization</a><a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.optimization provides functions for constrained and unconstrained linear regression.</p>
<span class="target" id="module-vigra.optimization"></span><dl class="function">
<dt id="vigra.optimization.lassoRegression">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">lassoRegression</tt><big>(</big><em>(object)A</em>, <em>(object)b</em><span class="optional">[</span>, <em>(bool)nonNegative=False</em><span class="optional">[</span>, <em>(bool)lsq=True</em><span class="optional">[</span>, <em>(bool)lasso=False</em><span class="optional">[</span>, <em>(int)maxSolutionCount=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.optimization.lassoRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression with L1 regularization.</p>
<p>If &#8216;nonNegative&#8217; is &#8216;True&#8217;, the solution will be constrained to non-negative
values, otherwise values may have arbitrary sign (the default).
If &#8216;lsq&#8217; is &#8216;True&#8217;, the algorithm will return the least squares solution
for each active set. If &#8216;lasso&#8217; is &#8216;True&#8217;, the LASSO solution will be returned
for each active set. Both may be &#8216;True&#8217; simultaneously.
If &#8216;maxSolutionCount&#8217; is non-zero, atr most so many active sets will
be computed.</p>
<p>The algorithm returns a tuple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">numActiveSets</span><span class="p">,</span> <span class="n">activeSets</span><span class="p">,</span> <span class="n">lsqSolutions</span><span class="p">,</span> <span class="n">lassoSolutions</span><span class="p">)</span>
</pre></div>
</div>
<p>where &#8216;numActiveSets&#8217; specifies how many active sets have been computed,
&#8216;activeSets&#8217; is the list of all active sets (ordered by decreasing regularization),
and &#8216;lsqSolutions&#8217; and &#8216;lassoSolutions&#8217; are lists of the corresponding solutions
for each active set (&#8216;lsqSolutions&#8217; and &#8216;lassoSolutions&#8217; will be &#8216;None&#8217; when
the corresponding function argument was &#8216;False&#8217;). An active set is a list of
indices of all variables whose values are non-zero in the corresponding
solution.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.optimization.leastSquares">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">leastSquares</tt><big>(</big><em>(object)A</em>, <em>(object)b</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.optimization.leastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform plain linear regression.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#gab3be347f5631d0aa2ee74c07479e0383">leastSquares</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.optimization.nonnegativeLeastSquares">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">nonnegativeLeastSquares</tt><big>(</big><em>(object)A</em>, <em>(object)b</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.optimization.nonnegativeLeastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression where the solution is constrained to be non-negative.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#ga73b680f4375cd2963543db1a7cf85e41">nonnegativeLeastSquares</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.optimization.ridgeRegression">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">ridgeRegression</tt><big>(</big><em>(object)A</em>, <em>(object)b</em>, <em>(float)lambda</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.optimization.ridgeRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression with L2 regularization.</p>
<p>&#8216;lambda&#8217; is the regularization parameter - the larger it is, the more
biased towards zero the solution will become.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#ga647810e9f3f2ff2e401f410b4855c58a">ridgeRegression</a> in the vigra C++ documentation.</p>
</dd></dl>

</div>
<div class="section" id="machine-learning">
<h2><a class="toc-backref" href="#id84">Machine Learning</a><a class="headerlink" href="#machine-learning" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.learning will eventually provide a wide range of machine learning
tools. Right now, it only contains an implementation of the random forest classifier
and probabilistic latent semantic analysis (pLSA) as an example for unsupervised learning.</p>
<span class="target" id="module-vigra.learning"></span><dl class="function">
<dt id="vigra.learning.pLSA">
<tt class="descclassname">vigra.learning.</tt><tt class="descname">pLSA</tt><big>(</big><em>(object)features</em>, <em>(int)nComponents</em><span class="optional">[</span>, <em>(int)nIterations=50</em><span class="optional">[</span>, <em>(float)minGain=0.0001</em><span class="optional">[</span>, <em>(bool)normalize=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.learning.pLSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform probabilistic latent semantic analysis.</p>
<p>The imput matrix &#8216;features&#8217; must have shape (nFeatures*nSamples). PCA will
reduce it to a smaller matrix &#8216;C&#8217; with shape (nComponents*nSamples) that 
preserves as much information as possible. Specifically, the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">pLSA</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>returns a projection matrix &#8216;P&#8217; with shape (nComponents*nFeatures)
such that the matrix <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">numpy.dot(P,</span> <span class="pre">C)</span></tt> is a rank-nComponents matrix
that approximates the matrix &#8216;features&#8217; well under the pLSA criterion.
Note that the result of pLSA() is not unique, since the algorithm uses random
initialization.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Unsupervised__Decomposition.html#ga7aff6f8e1ad85add65d226bcd899e07b">pLSA</a> in the C++ documentation for more detailed
information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.learning.principleComponents">
<tt class="descclassname">vigra.learning.</tt><tt class="descname">principleComponents</tt><big>(</big><em>(object)features</em>, <em>(int)nComponents</em><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.learning.principleComponents" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform principle component analysis.</p>
<p>The imput matrix &#8216;features&#8217; must have shape (nFeatures*nSamples). PCA will
reduce it to a smaller matrix &#8216;C&#8217; with shape (nComponents*nSamples) that 
preserves as much variance as possible. Specifically, the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">principleComponents</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>returns a projection matrix &#8216;P&#8217; with shape (nComponents*nFeatures)
such that <tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">numpy.dot(numpy.transpose(P),</span> <span class="pre">features)</span></tt>. Conversely, the
matrix  <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">numpy.dot(P,</span> <span class="pre">C)</span></tt> is the best possible rank-nComponents
approximation to the matrix &#8216;features&#8217; under the least-squares criterion.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Unsupervised__Decomposition.html#ga03b34ec75f31e6ea3b2dc541f31204fe">principleComponents</a> in the C++ documentation for more detailed
information.</p>
</dd></dl>

<dl class="class">
<dt id="vigra.learning.RandomForest">
<em class="property">class </em><tt class="descclassname">vigra.learning.</tt><tt class="descname">RandomForest</tt><a class="headerlink" href="#vigra.learning.RandomForest" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>__init__( (object)arg1 [, (int)treeCount=255 [, (int)mtry=-1 [, (int)min_split_node_size=1 [, (int)training_set_size=0 [, (float)training_set_proportions=1.0 [, (bool)sample_with_replacement=True [, (bool)sample_classes_individually=False [, (bool)prepare_online_learning=False [, (object)labels=[]]]]]]]]]]) -&gt; object :</dt>
<dd><p class="first">Constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">RandomForest</span><span class="p">(</span><span class="n">treeCount</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="n">mtry</span><span class="o">=</span><span class="n">RF_SQRT</span><span class="p">,</span> <span class="n">min_split_node_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
             <span class="n">training_set_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">training_set_proportions</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
             <span class="n">sample_with_replacement</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sample_classes_individually</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">prepare_online_learning</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>&#8216;treeCount&#8217; controls the number of trees that are created.
&#8216;labels&#8217; is a list specifying the permitted labels.</p>
<blockquote>
<div>If empty (default), the labels are automatically determined
from the training data. A non-empty list is useful when some
labels lack training examples.</div></blockquote>
<p class="last">See <a class="reference external" href="../../doc/vigra/classvigra_1_1RandomForest.html">RandomForest</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1RandomForestOptions.html">RandomForestOptions</a> in the C++ documentation for the meaning of the other parameters.</p>
</dd>
<dt>__init__( (object)arg1, (str)filename [, (str)pathInFile=&#8217;&#8216;]) -&gt; object :</dt>
<dd><p class="first">Load from HDF5 file:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">RandomForest</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">pathInFile</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="vigra.learning.RandomForest.featureCount">
<tt class="descname">featureCount</tt><big>(</big><em>(RandomForest)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForest.featureCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of features the RandomForest works with.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.labelCount">
<tt class="descname">labelCount</tt><big>(</big><em>(RandomForest)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForest.labelCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of labels, the RandomForest knows.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.learnRF">
<tt class="descname">learnRF</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.learning.RandomForest.learnRF" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a random Forest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;.</p>
<p>and returns the OOB. See the vigra documentation for the meaning af the rest of the parameters.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.learnRFWithFeatureSelection">
<tt class="descname">learnRFWithFeatureSelection</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.learning.RandomForest.learnRFWithFeatureSelection" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a random Forest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;.</p>
<p>and returns the OOB and the Variable importanceSee the vigra documentation for the meaning af the rest of the paremeters.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.onlineLearn">
<tt class="descname">onlineLearn</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em>, <em>(int)startIndex</em><span class="optional">[</span>, <em>(bool)adjust_thresholds=False</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.learning.RandomForest.onlineLearn" title="Permalink to this definition">¶</a></dt>
<dd><p>Learn online.</p>
<p>Works only if forest has been created with prepare_online_learning=true. Needs the old training data and the new appened, starting at startIndex.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.predictLabels">
<tt class="descname">predictLabels</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)nanLabel=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForest.predictLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels on &#8216;testData&#8217;.</p>
<p>If a &#8216;nanLabel&#8217; is provided, it will be returned for all rows of
the &#8216;testData&#8217; that contain an NaN value. Otherwise, an exception is
thrown whenever Nan is encountered.</p>
<p>The output is an array containing a label for every test samples.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.predictProbabilities">
<tt class="descname">predictProbabilities</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForest.predictProbabilities" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Predict probabilities for different classes on &#8216;testData&#8217;.</p>
<p>The output is an array containing a probability for every test sample and class.</p>
</div></blockquote>
<dl class="docutils">
<dt>predictProbabilities( (RandomForest)arg1, (RF_OnlinePredictionSet)testData [, (object)out=None]) -&gt; object :</dt>
<dd>The output is an array containing a probability for every test sample and class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.reLearnTree">
<tt class="descname">reLearnTree</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em>, <em>(int)treeId</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.learning.RandomForest.reLearnTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-learn one tree of the forest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;.</p>
<p>and returns the OOB. This might be helpful in an online learning setup to improve the classifier.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.treeCount">
<tt class="descname">treeCount</tt><big>(</big><em>(RandomForest)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForest.treeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the &#8216;treeCount&#8217;, that was set when constructing the RandomForest.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.writeHDF5">
<tt class="descname">writeHDF5</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(str)filename</em><span class="optional">[</span>, <em>(str)pathInFile=''</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.learning.RandomForest.writeHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the random forest in the given HDF5 file &#8216;filename&#8217; under the internal
path &#8216;pathInFile&#8217;.</p>
</dd></dl>

</dd></dl>

<p>For more information, refer to <a class="reference external" href="../../doc/vigra/classvigra_1_1RandomForest.html">RandomForest</a> in the C++ documentation.</p>
<dl class="class">
<dt id="vigra.learning.RandomForestOld">
<em class="property">class </em><tt class="descclassname">vigra.learning.</tt><tt class="descname">RandomForestOld</tt><a class="headerlink" href="#vigra.learning.RandomForestOld" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>__init__( (object)arg1, (object)trainData, (object)trainLabels [, (int)treeCount=255 [, (int)mtry=0 [, (int)min_split_node_size=1 [, (int)training_set_size=0 [, (float)training_set_proportions=1.0 [, (bool)sample_with_replacement=True [, (bool)sample_classes_individually=False]]]]]]]) -&gt; object :</dt>
<dd><p class="first">Constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">RandomForestOld</span><span class="p">(</span><span class="n">trainData</span><span class="p">,</span> <span class="n">trainLabels</span><span class="p">,</span>
                <span class="n">treeCount</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="n">mtry</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_split_node_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">training_set_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">training_set_proportions</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">sample_with_replacement</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sample_classes_individually</span><span class="o">=</span><span class="bp">False</span><span class="p">,)</span>
</pre></div>
</div>
<p>Construct and train a RandomForest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;. &#8216;treeCount&#8217; controls the number of trees that are created.</p>
<p class="last">See <a class="reference external" href="../../doc/vigra/classvigra_1_1RandomForest.html">RandomForest</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1RandomForestOptions.html">RandomForestOptions</a> in the C++ documentation for the meaning of the other parameters.</p>
</dd>
</dl>
<dl class="method">
<dt id="vigra.learning.RandomForestOld.featureCount">
<tt class="descname">featureCount</tt><big>(</big><em>(RandomForestOld)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForestOld.featureCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of features the RandomForest works with.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.labelCount">
<tt class="descname">labelCount</tt><big>(</big><em>(RandomForestOld)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForestOld.labelCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of labels, the RanfomForest knows.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.predictLabels">
<tt class="descname">predictLabels</tt><big>(</big><em>(RandomForestOld)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForestOld.predictLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels on &#8216;testData&#8217;.The output is an array containing a labels for every test samples.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.predictProbabilities">
<tt class="descname">predictProbabilities</tt><big>(</big><em>(RandomForestOld)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForestOld.predictProbabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities for different classes on &#8216;testData&#8217;.The output is an array containing a probability for every test sample and class.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.treeCount">
<tt class="descname">treeCount</tt><big>(</big><em>(RandomForestOld)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForestOld.treeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the &#8216;treeCount&#8217;, that was set when constructing the RandomForest.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="noise-estimation-and-normalization">
<h2><a class="toc-backref" href="#id85">Noise Estimation and Normalization</a><a class="headerlink" href="#noise-estimation-and-normalization" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.noise provides noise estimation and normalization according to a
method proposed by Foerstner.</p>
<span class="target" id="module-vigra.noise"></span><dl class="function">
<dt id="vigra.noise.linearNoiseNormalization">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">linearNoiseNormalization</tt><big>(</big><em>(object)image</em>, <em>(float)a0</em>, <em>(float)a1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.linearNoiseNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise normalization by means of an estimated linear noise model.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#ga98960448c1bac4e2e068e7dd6ffdfe66">linearNoiseNormalization</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.linearNoiseNormalizationEstimated">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">linearNoiseNormalizationEstimated</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.noise.linearNoiseNormalizationEstimated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="vigra.noise.noiseVarianceClustering">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">noiseVarianceClustering</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.noiseVarianceClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the noise variance as a function of the image intensity and cluster the results.
This operator first calls noiseVarianceEstimation() to obtain a sequence of intensity/variance pairs,
which are then clustered using the median cut algorithm. Then the cluster centers (i.e. average variance vs. average intensity)
are determined and returned in the result sequence.</p>
<p>Since the length of the resulting array is not known beforhand, it cannot be written into an preallocated array
(the &#8220;out&#8221; argument in most other vigra python functions)
.
For details see the vigra documentation <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#ga78d48b96e66ee00680567fe9b84d2b71">noiseVarianceClustering</a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.noiseVarianceEstimation">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">noiseVarianceEstimation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.noiseVarianceEstimation" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the noise variance as a function of the image intensity.</p>
<p>Returns an array with the means in the first column and the variances in the second column.
Since the length of the resulting array is not known beforhand, it can not be written into an preallocated array
(the &#8220;out&#8221; argument in most other vigra python functions.</p>
<p>For details see the vigra documentation <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#gac7a0f3b1b8de238ad40a4925f9e62d3f">noiseVarianceEstimation</a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.nonparametricNoiseNormalization">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">nonparametricNoiseNormalization</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.nonparametricNoiseNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise normalization by means of an estimated non-parametric noise model.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#ga1d937331b5773114d6c1187560bb901e">nonparametricNoiseNormalization</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.quadraticNoiseNormalization">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">quadraticNoiseNormalization</tt><big>(</big><em>(object)image</em>, <em>(float)a0</em>, <em>(float)a1</em>, <em>(float)a2</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.quadraticNoiseNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise normalization by means of an estimated quadratic noise model.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#gaeac0754774b3c445c953359f5d2d495f">quadraticNoiseNormalization</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.quadraticNoiseNormalizationEstimated">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">quadraticNoiseNormalizationEstimated</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.noise.quadraticNoiseNormalizationEstimated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="writing-your-own-c-modules">
<span id="sec-own-modules"></span><h2><a class="toc-backref" href="#id86">Writing Your Own C++ Modules</a><a class="headerlink" href="#writing-your-own-c-modules" title="Permalink to this headline">¶</a></h2>
<p>When you want to write your own vigranumpy extension modules, first make sure that you compile and link with the same versions of numpy and boost_python that your current vigranumpy installation uses. Otherwise, communication between new and existing modules will not work (and even crash). Then follow these steps:</p>
<ol class="arabic">
<li><p class="first">Create the main module source file. This file contains the module&#8217;s &#8216;init&#8217; function. Let&#8217;s assume that the module will be called &#8216;my_module&#8217;, and the file is &#8216;my_module.cxx&#8217;. A stub for &#8216;my_module.cxx&#8217; typically looks like this:</p>
<div class="highlight-python"><pre>// define PY_ARRAY_UNIQUE_SYMBOL (required by the numpy C-API)
#define PY_ARRAY_UNIQUE_SYMBOL my_module_PyArray_API

// include the vigranumpy C++ API
#include &lt;Python.h&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;vigra/numpy_array.hxx&gt;
#include &lt;vigra/numpy_array_converters.hxx&gt;

... // your includes

... // implementation of your wrapper functions and classes

using namespace boost::python;

// the argument of the init macro must be the module name
BOOST_PYTHON_MODULE_INIT(my_module)
{
    // initialize numpy and vigranumpy
    vigra::import_vigranumpy();

    // export a function
    def("my_function", &amp;my_function,
        (arg("arg1"), arg("arg2"), ...),
        "Documentation");

    // export a class and its member functions
    class_&lt;MyClass&gt;("MyClass",
        "Documentation")
        .def("foo", &amp;MyClass::foo,
             (arg("arg1"), arg("arg2"), ...),
             "Documentation")
    ;

    ... // more module functionality (refer to boost_python documentation)
}</pre>
</div>
</li>
<li><p class="first">When your module uses additional C++ source files, they should start with the following defines:</p>
<div class="highlight-python"><pre>// this must define the same symbol as the main module file (numpy requirement)
#define PY_ARRAY_UNIQUE_SYMBOL my_module_PyArray_API
#define NO_IMPORT_ARRAY</pre>
</div>
</li>
<li><p class="first">Implement your wrapper functions. Numpy ndarrays are passed to C++ via the wrapper classes <a class="reference external" href="../../doc/vigra/classvigra_1_1NumpyArray.html">NumpyArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1NumpyAnyArray.html">NumpyAnyArray</a>. You can influence the conversion from Python to C++ by using different instantiations of NumpyArray, as long as the Python array supports the axistags attribute (refer to <a class="reference internal" href="#array-order-parameter"><em>axis order definitions</em></a> for the meaning of the term &#8216;ascending order&#8217;):</p>
<div class="highlight-python"><pre>    // We add a 'using' declaration for brevity of our examples.
    // In actual code, you should probably prefer explicit namespace qualification.
using namespace vigra;

    // Accept any array type and return an arbitrary array type.
    // Returning NumpyAnyArray is always safe, because at that point
    // C++ no longer cares about the particular type of the array.
NumpyAnyArray foo(NumpyAnyArray array);

    // Accept a 3-dimensional float32 array and transpose it
    // into ascending axis order ('F' order).
void foo(NumpyArray&lt;3, float&gt; array);

    // Accept a 2-dimensional float32 array with an arbitrary number of channels and
    // transpose the axes into VIGRA ('V') order (channels are last, other axes ascending).
    // Note that the NumpyArray dimension is 3 to account for the channel dimension.
    // If the original numpy array has no channel axis, vigranumpy will automatically
    // insert a singleton axis.
void foo(NumpyArray&lt;3, Multiband&lt;float&gt; &gt; array);

    // Accept a 2-dimensional float32 array that has only a single channel
    // (that is, 'array.channels == 1' must hold on the Python side).
    // Non-channel axes are transposed into ascending order.
    // Note that the NumpyArray dimension is now 2.
void foo(NumpyArray&lt;2, Singleband&lt;float&gt; &gt; array);

    // Accept a float32 array that has 2 non-channel dimensions and
    // exactly 3 channels (i.e. 'array.channels == 3' on the Python side).
    // Non-channel axes are transposed into ascending order.
    // Note that the NumpyArray dimension is again 2, but the pixel type is
    // now a vector.
    // The conversion will only succeed if the channel axis is unstrided on
    // the Python side (that is, the following expression is True:
    //      array.strides[array.channelIndex] == array.dtype.itemsize).
void foo(NumpyArray&lt;2, TinyVector&lt;float, 3&gt; &gt; array);
void foo(NumpyArray&lt;2, RGBValue&lt;float&gt; &gt; array);</pre>
</div>
<p>Or course, these functions can also be templated.</p>
<p>When your functions return newly allocated arrays, it is usually desirable to transfer the input&#8217;s axistags to the output (otherwise, vigranumpy will use <a class="reference internal" href="#vigra.VigraArray.defaultAxistags" title="vigra.VigraArray.defaultAxistags"><tt class="xref py py-meth docutils literal"><span class="pre">defaultAxistags()</span></tt></a> as a fallback). There is a standard vigranumpy idiom for this task which assumes that the wrapped function has an optional parameter &#8216;output&#8217; for a possibly pre-allocated output array. The axistags are then transferred by reshaping the output array with a <tt class="docutils literal"><span class="pre">taggedShape()</span></tt> (which is a combination of a shape and axistags):</p>
<div class="highlight-python"><pre>NumpyAnyArray
foo(NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; input,
    NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; output = boost::python::object())
{
    // Reshape only if the output array was not explicitly passed in.
    // Otherwise, use the output array as is.
    output.reshapeIfEmpty(input.taggedShape(),
              "error message when shape is unsuitable.");

    ... // your algorithm
}</pre>
</div>
<p>It is also possible to modify the tagged shape before it is applied to the output array:</p>
<div class="highlight-python"><pre>input.taggedShape()
     .resize(Shape2(new_width, new_height))
     .setChannelCount(new_channel_count)
     .setChannelDescription("a description")</pre>
</div>
<p>The C++ code can be multi-threaded when you unlock Python&#8217;s global interpreter lock. After unlocking, your wrapper code must not call any Python functions, so the unlock statement should go after <tt class="docutils literal"><span class="pre">output.reshapeIfEmpty()</span></tt>:</p>
<div class="highlight-python"><pre>NumpyAnyArray
foo(NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; input,
    NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; output = boost::python::object())
{
    output.reshapeIfEmpty(input.taggedShape(), "Message.");

        // Allow parallelization from here on. The destructor of
        // _pythread will automatically regain the global interpreter lock
        // just before this function returns to Python.
    PyAllowThreads _pythread;

    ... // your algorithm
}</pre>
</div>
</li>
<li><p class="first">Export your wrapped functions. <tt class="docutils literal"><span class="pre">boost::python::def</span></tt> is called in its usual way, with one simple extension: Since vigranumpy does not know which NumpyArray variants you are going to use, appropriate converter functions between Python and C++ must be registered on demand. You do this by enclosing your function pointer into a call to the &#8216;registerConverters()&#8217; function:</p>
<div class="highlight-python"><pre>// in the module's init function
def("my_function", vigra::registerConverters(&amp;my_function),
   (arg("arg1"), ...),
   "Documentation");</pre>
</div>
</li>
</ol>
<p>If you need more information, it is always a good idea to look at the source code of the existing vigranumpy modules.</p>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1><a class="toc-backref" href="#id87">Indices and tables</a><a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul>
<li><p class="first"><a class="reference internal" href="genindex.html"><em>Index</em></a></p>
</li>
<li><p class="first"><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></p>
</li>
<li><p class="first"><a class="reference internal" href="search.html"><em>Search Page</em></a></p>
<blockquote>
<div></div></blockquote>
</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Vigranumpy Reference</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#axistags-and-the-vigraarray-data-structure">Axistags and the VigraArray Data Structure</a></li>
<li><a class="reference internal" href="#more-on-the-motivation-and-use-of-axistags">More On the Motivation and Use of Axistags</a><ul>
<li><a class="reference internal" href="#history-of-the-problem">History of the problem</a></li>
<li><a class="reference internal" href="#arrays-as-matrices">Arrays as Matrices</a></li>
<li><a class="reference internal" href="#arrays-as-images">Arrays as Images</a></li>
<li><a class="reference internal" href="#multi-dimensional-arrays">Multi-Dimensional Arrays</a></li>
<li><a class="reference internal" href="#vigra-and-numpy">VIGRA and numpy</a></li>
<li><a class="reference internal" href="#vigranumpy-axistags">Vigranumpy Axistags</a></li>
<li><a class="reference internal" href="#vigranumpy-conventions">Vigranumpy Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#axistag-reference">Axistag Reference</a></li>
<li><a class="reference internal" href="#vigraarray-reference">VigraArray Reference</a></li>
<li><a class="reference internal" href="#import-and-export-functions">Import and Export Functions</a></li>
<li><a class="reference internal" href="#mathematical-functions-and-type-coercion">Mathematical Functions and Type Coercion</a></li>
<li><a class="reference internal" href="#color-and-intensity-manipulation">Color and Intensity Manipulation</a></li>
<li><a class="reference internal" href="#filters">Filters</a></li>
<li><a class="reference internal" href="#sampling-image-resizing-and-image-pyramids">Sampling: Image Resizing and Image Pyramids</a></li>
<li><a class="reference internal" href="#fourier-transforms">Fourier Transforms</a></li>
<li><a class="reference internal" href="#image-analysis">Image Analysis</a></li>
<li><a class="reference internal" href="#geometry">Geometry</a></li>
<li><a class="reference internal" href="#optimization">Optimization</a></li>
<li><a class="reference internal" href="#machine-learning">Machine Learning</a></li>
<li><a class="reference internal" href="#noise-estimation-and-normalization">Noise Estimation and Normalization</a></li>
<li><a class="reference internal" href="#writing-your-own-c-modules">Writing Your Own C++ Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">vigranumpy 1.10.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright , Ullrich Koethe and others.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>