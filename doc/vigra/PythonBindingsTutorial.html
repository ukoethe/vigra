<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - VIGRA Python Bindings</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">VIGRA Python Bindings 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><p>See also the full <a href="../vigranumpy/index.html">vigranumpy reference</a>!</p>
<p>When you configure VIGRA with the option <code>-DWITH_VIGRANUMPY=1</code> while running cmake, a Python module <code>vigra</code> will be compiled and installed. It exposes most of VIGRA's functionality for easy scripting and prototyping in Python. Most importantly, VIGRA's Python bindings are fully integrated with the popular 'numpy' package so that you can call vigra functions directly with numpy <code>ndarrays</code>. No explicit or implicit conversion of data formats is required.</p>
<p>The syntax of the Python version is usually very similar to the C++ syntax, with one important difference: You do not have to pass pre-allocated result arrays to the functions. That is, while the call to <code><a class="el" href="group__CommonConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113" title="Perform isotropic Gaussian convolution.">gaussianSmoothing()</a></code> in C++ is written like this</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, float&gt; inputImage(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width, height)), 
                         resultImage(inputImage.shape());  <span class="comment">// pre-allocate result with correct shape</span>
    ... <span class="comment">// fill inputImage</span>
    
    <span class="comment">// smooth image with Gaussian filter with sigma=1.5</span>
    <span class="comment">// (pre-allocated resultImage must be passed to the function)</span>
    <a class="code" href="group__CommonConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113" title="Perform isotropic Gaussian convolution.">gaussianSmoothing</a>(inputImage, resultImage, 1.5);
</pre></div><p>the corresponding Python call is</p>
<div class="fragment"><pre class="fragment">    &gt;&gt;&gt; <span class="keyword">import</span> numpy, vigra
    
    &gt;&gt;&gt; inputImage = numpy.zeros((width, height), dtype=numpy.float32)
    ...  # fill inputImage
    
    &gt;&gt;&gt; resultImage = vigra.filters.gaussianSmoothing(inputImage, 1.5);
</pre></div><p>The result image is automatically allocated and returned by the function. Nonetheless, it is still possible to pass a result array of appropriate shape explicitly by means of the <code>out</code> parameter:</p>
<div class="fragment"><pre class="fragment">    &gt;&gt;&gt; resultImage = numpy.zeros(inputImage.shape, dtype=numpy.float32)
    &gt;&gt;&gt; vigra.filters.gaussianSmoothing(inputImage, 1.5, out=resultImage)
</pre></div><p>This is, for example, useful when the same result image should be reused in several calls of the same function to avoid the repeated creation of new result arrays. Another possible use is the application of a function to only a rectangular region-of-interest: When the full result array is already allocated, you can pass a view of the approriate subarray to the <code>out</code> parameter in order to fill just the desired ROI.</p>
<p>When a C++ function provides options, they are exposed on the Python side as keyword arguments:</p>
<div class="fragment"><pre class="fragment">    &gt;&gt;&gt; labeling, max_label = vigra.analysis.watersheds(inputImage, seeds=seedImage, method=<span class="stringliteral">&#39;UnionFind&#39;</span>)
</pre></div><p>In general, the correspondence between a Python function and its C++ counterpart is straightforward, and the Python documentation frequently refers to the C++ documentation for details. However, there is a crucial difference: the default axis interpretation is different in VIGRA's <code>MultiArray</code> (which interpretes axes as x, y, z, so called 'Fortran' order) and in numpy's <code>ndarray</code> (which interpretes them as z, y, x, so called 'C'-order). To help you deal with this difficulty, vigranumpy provides a subclass <a href="../vigranumpy/index.html#axistags-and-the-vigraarray-data-structure">VigraArray</a> of <code>ndarray</code> and the concept of <a href="../vigranumpy/index.html#more-on-the-motivation-and-use-of-axistags">axistags</a>. Please take the time to read this material in order to avoid surprises.</p>
<p>The full <a href="../vigranumpy/index.html">vigranumpy reference</a> is available via HTML or can be obtained directly at the Python prompt by the <code>help()</code> command:</p>
<div class="fragment"><pre class="fragment">    &gt;&gt;&gt; help(vigra.filters.gaussianSmoothing)
</pre></div><p>Another important difference between C++ and Python is that vigranumpy exposes most functions only for a restricted set of pixel types. This restriction is necessary because support for all possible type combinations would result in a combinatorial explosion and unreasonably large Python modules. In general, all functions are implemented for <code>float</code> pixel types (called <code>numpy.float32</code> on the Python side), and some provide <code>uint8</code> and/or <code>uint32</code> versions in addition. If you call a function with an unsupported pixel type, an error message listing the supported types will be printed:</p>
<div class="fragment"><pre class="fragment">    &gt;&gt;&gt; a = vigra.ScalarImage((20,20), dtype=numpy.float64)

    &gt;&gt;&gt; vigra.gaussianSmoothing(a, 1) # doesn<span class="stringliteral">&#39;t support numpy.float64</span>
<span class="stringliteral">    ArgumentError: Python argument types in</span>
<span class="stringliteral">        vigra.filters.gaussianSmoothing(numpy.ndarray, int)</span>
<span class="stringliteral">    did not match C++ signature:</span>
<span class="stringliteral">        gaussianSmoothing(class vigra::NumpyArray&lt;3,struct vigra::Multiband&lt;float&gt;,struct vigra::StridedArrayTag&gt; array, class boost::python::api::object sigma, class vigra::NumpyArray&lt;3,struct vigra::Multiband&lt;float&gt;,struct vigra::StridedArrayTag&gt; out=None, class boost::python::api::object sigma_d=0.0, class boost::python::api::object step_size=1.0, double window_size=0.0, class boost::python::api::object roi=None)    </span>
<span class="stringliteral"></span>
<span class="stringliteral">        gaussianSmoothing(class vigra::NumpyArray&lt;4,struct vigra::Multiband&lt;float&gt;,struct vigra::StridedArrayTag&gt; array, class boost::python::api::object sigma, class vigra::NumpyArray&lt;4,struct vigra::Multiband&lt;float&gt;,struct vigra::StridedArrayTag&gt; out=None, class boost::python::api::object sigma_d=0.0, class boost::python::api::object step_size=1.0, double window_size=0.0, class boost::python::api::object roi=None)</span>
</pre></div><p>The error message is automatically generated by boost::python and therefore rather technical. It says that <code>gaussianSmoothing()</code> supports 3- and 4-dimensional arrays where the rightmost dimension is interpreted as a channel axis, and the pixel type must be <code>float</code> (these properties are indicated by the type specifications <code>NumpyArray&lt;3,struct vigra::Multiband&lt;float&gt;</code> and <code>NumpyArray&lt;4,struct vigra::Multiband&lt;float&gt;</code> respectively). Thus, the input array must be a <code>float32</code> image or volume with either no explicit channel axis (in which case a singleton channel axis will be inserted automatically) or with arbitrary many channels (e.g. RGB).</p>
<p><a href="../vigranumpy/index.html#more-on-the-motivation-and-use-of-axistags">Axistags</a> allow vigranumpy to distinguish if a given 3-dimensional array is to be interpreted as a 2D image with multiple channels, or as a 3D volume with only a single channel. If no axistags are attached to the array, it is unspecified which version of an algorithm will be called. Axistags are automatically specified when arrays are created with one of the factory functions in the <code>vigra</code> module, for example:</p>
<div class="fragment"><pre class="fragment">    &gt;&gt;&gt; a = vigra.ScalarImage((30, 20))
    &gt;&gt;&gt; print <span class="stringliteral">&quot;%s \n %r&quot;</span> % (a.shape, a.axistags)
    (30L, 20L)
     x y

    &gt;&gt;&gt; a = vigra.RGBImage((30, 20))
    &gt;&gt;&gt; print <span class="stringliteral">&quot;%s \n %r&quot;</span> % (a.shape, a.axistags)
    (30L, 20L, 3L)
     x y c

    &gt;&gt;&gt; a = vigra.ScalarVolume((30, 20, 10))
    &gt;&gt;&gt; print <span class="stringliteral">&quot;%s \n %r&quot;</span> % (a.shape, a.axistags)
    (30L, 20L, 10L)
     x y z

    &gt;&gt;&gt; a = vigra.RGBVolume((30, 20, 10))
    &gt;&gt;&gt; print <span class="stringliteral">&quot;%s \n %r&quot;</span> % (a.shape, a.axistags)
    (30L, 20L, 10L, 3L)
     x y z c
</pre></div><p>Axistags are encoded 'x', 'y', 'z' for the three spatial axes, 'c' for a channel axis, and 't' for a time axis. If the channel axis is missing, vigranumpy will assume that the array has only a single channel. That is, arrays with shape (30, 20, 1) and axistags 'x y c' are equivalent to arrays with shape (30, 20) and axistags 'x y'. Functions that change the order of the axes (such as <code>array.transpose()</code>) or reduce the number of axes (e.g. <code>array[:, 1, :]</code>) also modify the axistags accordingly, so that you can always ask for the axis meaning by simply calling <code>array.axistags</code>. </p>
</div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Mon Nov 18 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
