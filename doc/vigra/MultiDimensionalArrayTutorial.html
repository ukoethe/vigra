<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Multi-Dimensional Arrays</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Multi-Dimensional Arrays 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><h2>Section Contents</h2>
<ul style="list-style-image:url(documents/bullet.gif)">
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayBasics">Basic MultiArray Usage</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayIndexing">Array Indexing via Coordinates</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayScanOrder">One-dimensional Indexing and Scan-Order Iterator</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayMethods">Important MultiArray Methods</a> <ul type="disc">
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayViewBasics">The MultiArrayView Interface</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_subarray">subarray(p,q)</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_bind">bind&lt;M&gt;(i) and bindAt(M, i)</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_vector_elements">expandElements(k) and bindElementChannel(i)</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_transpose">transpose()</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_unstrided">isUnstrided(k)</a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="MultiArrayBasics"></a>
Basic MultiArray Usage</h2>
<p><a class="el" href="classvigra_1_1MultiArray.html">vigra::MultiArray</a> is the most fundamental data structure in VIGRA. It holds a rectangular block of values in arbitrary many dimensions. Most VIGRA functions operate on top of MultiArray or the associated class MultiArrayView (see <a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayViewBasics">The MultiArrayView Interface</a>).</p>
<p>A 2D image can be interpreted as a matrix, i.e. a 2-dimensional array, where each element holds the information of a specific pixel. Internally, the data are stored in a single 1-dimensional piece of memory, and MultiArray encapsulates the entire mapping between our familiar 2-dimensional notation and the raw memory. Pixels in an image are identified by a coordinate pair (x,y), where indexing starts at 0. That is, the pixels in a 800x600 image are indexed by <code>x = 0,...,799 and y = 0,...,599</code>. The principle analoguously extends to higher dimensions.</p>
<p>The structure of a multidimensional array is given by its <code>shape</code> vector, and the length of the shape vector is the array's <em>dimension</em>. The dimension must be fixed as a template parameter at compule time, while the shape is passed to the array's constructor. The second important template parameter is the pixel's <code>value_type</code>, as you know it form <code>std::vector</code>.</p>
<p>To represent the data of a gray scale image, we just need to store one value per pixel, so we choose a 2-dimensional array, where each element has the <code> unsigned char </code> type (in VIGRA, this type is also available as <a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">vigra::UInt8</a>). We instantiate a gray scale image object like this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;vigra/multi_array.hxx&gt;</span>
    
    <span class="keyword">using namespace </span>vigra; <span class="comment">// for brevity in the examples - don&#39;t do this in header files!</span>
    
    <span class="keywordtype">int</span> width = ...,  height = ...;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;2, UInt8&gt;</a> image(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width, height));
</pre></div><p>By default, VIGRA arrays are <b>always zero-initialized</b>. Another initial value can be provided in the constructor, or later via the <code>init()</code> function or the assignment operator:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, UInt8&gt; image(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width, height), 255); <span class="comment">// init with value 255</span>
    
    image.init(128);  <span class="comment">// same effect, different initial value</span>
    image = 100;      <span class="comment">// yet another way</span>
</pre></div><p>The <code>Shape2</code> typedef also exists for higher dimensions up to five as <code>Shape3</code> etc. If you need even more dimensions, use <code>MultiArrayShape&lt;N&gt;::type</code> instead, were N is the number of dimensions:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// dimension 0 runs from 0, 1, ..., 299</span>
    <span class="comment">// dimension 1 runs from 0, 1, ..., 199</span>
    <span class="comment">// dimension 2 runs from 0, 1, ...,  99</span>
    MultiArray&lt;3, double&gt; volume(<a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a>(300, 200, 100));
    
    MultiArray&lt;7, float&gt; array7D(MultiArrayShape&lt;7&gt;::type(20, 10, ...));
</pre></div><p>When storing RGB images we obviously can't simply use the unsigned char type because every pixel contains 3 numbers: values for red, green and blue. Mathematically, you want to store a data vector for each pixel. To this end, VIGRA provides the <code>vigra::RGBValue&lt;ValueType&gt;</code> class. So for RGB-images just use: </p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, RGBValue&lt;UInt8&gt; &gt; rgb_image(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(256, 128));
</pre></div><p>vigra::RGBValue&lt;ValueType&gt; is a specialised 3-dimensional vector containing ValueType elements. Arbitrary short vectors can be stored in the <code>TinyVector&lt;ValueType, SIZE&gt;</code> class, which is the base class of RGBValue. It's length must be specified at compile time in the template parameter <code>SIZE</code>. Vectors whose length is known at compile time are very useful for the compiler to produce highly optimized code. Therefore, <code>Shape2</code> and it's higher-dimensional coursins are instances of <code>TinyVector</code> as well.</p>
<p>Alternatively you can use a 3-dimensional array <code><a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray</a>&lt;3, unsigned char&gt;</code> to represent a color image. The third dimension has size 3 and contains the information for the red, green and blue channel.</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, UInt8&gt; rgb_array(<a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a>(256, 128, 3));
</pre></div><p>However, we are not going to use this form in the tutorial because <code>vigra::RGBValue&lt;ValueType&gt;</code> provides many helpful methods that are not available when color is just another array dimension.</p>
<h2><a class="anchor" id="MultiArrayIndexing"></a>
Array Indexing via Coordinates</h2>
<p>The easiest way to access the values of an array is via the coordinates. A tuple of coordinates can again be specified by the appropriate shape object, which must be passed to the array's indexing operator:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> width = 300, height = 200;
    MultiArray&lt;2, int&gt; image(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width, height));

    <span class="comment">// set all elements to 3</span>
    image.init(3);

    <span class="comment">// print pixel at x=1 and y=2</span>
    <span class="keywordtype">int</span> x=1, y=2;
    std::cout &lt;&lt; image[<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(x,y)] &lt;&lt; std::endl;  <span class="comment">// output: 3</span>
</pre></div><p><b>Important Remark:</b> Notice that VIGRA follows the mathematical convention of the index order: dimension 0 corresponds to the x (horizontal) coordinate, dimension 1 to the y (vertical) coordinate, and so on. Accordingly, dimension 0 is changing fastest in memory: when we increase x by one, we get to the next memory location. In matrix jargon, this is also known as <em>Fortran order</em>. Many image processing libraries (e.g. <a href="http://www.imagemagick.org/">Image Magick</a>, <a href="http://opencv.willowgarage.com/">OpenCV</a>, and <a href="http://qt-project.org/">Qt</a>) use the same convention. However, others like Matlab and numpy, use the reverse order (so called <em>C order</em>). Don't be confused!</p>
<p>Internally, shape objects are implemented in terms of the powerful <a class="el" href="classvigra_1_1TinyVector.html">vigra::TinyVector</a> class. This means that shape objects support the usual mathematical operations like addition, multiplication and scalar products. Coordinate computations can thus be performed on entire coordinate objects at once - there is no need to manipulate the individual coordinates separately.</p>
<p>Nonetheless, in some circumstances it is more convenient to provide coordinates individually rather than in a shape object. This is possible with round brackets (x,y):</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// access via individual coordinates</span>
    image(1,2) = 22;
</pre></div><p>This kind of indexing is supported for dimensions up to five, and only if the array's dimension is known (this is not always the case: in a generic function where the dimension is a template parameter, you must use shape objects). In combination with the method <code>shape(n)</code>, that returns the length of the n-th dimension, we can use the coordinates to set the element of an entire row or column:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// set all elements of first row to 13</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; image.shape(1); i++)
        image(1,i) = 13;
</pre></div><p>On first sight, individual coordinates may be necessary to iterator of the image or parts of it. But the following example shows that the same effect can be achieved with a shape object that is allocated outside the loop: 3rd column of a 8x4-matrix (initialized with 5) to 7.</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// instantiate shape object (zero intialized by default)</span>
    <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a> p;
    <span class="comment">// bind x=2</span>
    p[0] = 2;
    <span class="comment">// iterator over row 2</span>
    <span class="keywordflow">for</span>(p[1]=0; p[1]&lt;image.shape(1); ++p[1])   
        image[p] = 7;
</pre></div><p>We will discuss more powerful methods to access certain parts of an array in section <a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayMethods">Important MultiArray Methods</a>.</p>
<h2><a class="anchor" id="MultiArrayScanOrder"></a>
One-dimensional Indexing and Scan-Order Iterator</h2>
<p>Regardless of the array's dimension, it is always possible to access elements with 1-dimensional index, its <em>scan-order index</em>, via the normal indexing operator. For example, <code>array[1]</code> refers to the index of the second array element. Defining a scan order is often called <em>flattening</em> of an array, because a high-dimensional data structure is accessed like a 1-dimensional vector. Notive that scan-order access in VIGRA does not require the data to be copied.</p>
<p>VIGRA defines scan-order by considering the dimensions from front to back. Thus, items are accessed such that only the x coordinate is incremented, while y (and possibly further coordinates) are held fixed at 0. When x is exhausted, y is incremented by one and the iteration starts again at x=0. To control iteration, the function <code>array.size()</code> returns the total number of elements:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, int&gt; intArray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,2));

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;intArray.size(); ++k=
        intArray[k] = k+1;
    
    <span class="comment">// the array now contains the values</span>
    <span class="comment">//</span>
    <span class="comment">//   1 2 3</span>
    <span class="comment">//   4 5 6</span>
</pre></div><p>Alternatively, scan-order access can be achieved with an STL-compatible iterator pair obtained by calling <code>array.begin()</code> and <code>array.end()</code>. Continuing with the example above, we can write:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// declare an alias for the iterator type</span>
    <span class="keyword">typedef</span> MultiArray&lt;2, int&gt;::iterator Iter;

    <span class="comment">// iterate over intArray and print the elements in scan order</span>
    <span class="keywordflow">for</span> (Iter i = intArray.begin(); i != intArray.end(); ++i)
        std::cout &lt;&lt; *i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    std::cout &lt;&lt; std::endl;
    
    <span class="comment">// output: 1 2 3 4 5 6</span>
</pre></div><p>The iterator is implemented by class <code>StridedScanOrderIterator</code> which encapsulates all the bookkeeping necessary to get the elements in the correct order, even when the array was transposed (see below).</p>
<p>Scan-order access is useful to implement pointwise operations, e.g. the addition of two matrices. The following code adds two matrices and stores the result in the first one:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, int&gt; matrix1(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,3)),
                       matrix2(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,3));
    ... <span class="comment">// fill in data</span>

    <span class="comment">// use indexing</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; matrix1.size(); ++i)
        matrix1[i] += matrix2[i];
    
    <span class="comment">// use iterators</span>
    <span class="keywordflow">for</span> (Iter i = matrix1.begin(), j = matrix2.begin(); i != matrix1.end(); ++i, ++j)
        *i += *j;
</pre></div><p>This is convenient because the actual high-dimensional shapes of the arrays are of no significance for point-wise operations as long as the shapes match. Be careful: the arrays themselves have no way of checking this condition. So thefollowing code using two transposed shapes is perfectly valid C++, but has probably not the intended effect:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, int&gt; matrix3(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,2)),
                       matrix4(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(2,3));  <span class="comment">// transposed shape of matrix3</span>
    ... <span class="comment">// fill in data</span>

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; matrix3.size(); ++i)
        matrix3[i] += matrix4[i];  <span class="comment">// works, but may not have the intended effect</span>
</pre></div><p>By the way: VIGRA provides the += operator (and is cousins) to write this more concisely, and this operator throws an exception if the shapes don't match:</p>
<div class="fragment"><pre class="fragment">    matrix1 += matrix2;          <span class="comment">// works fine!</span>
    matrix3 += matrix4;          <span class="comment">// error: shape mismatch!</span>
</pre></div><p>For more information on mathematical operations on arrays see the <a class="el" href="group__MultiMathModule.html">multi_math</a> module.</p>
<p>As mentioned, VIGRA's scan order is similar to the NumPy-method <code>array.flatten()</code>. You use it, to copy a multi-dimensional array into an one-dimensional array, or to access elements in flattened order. The only difference is that NumPy uses "C-order" , i.e. the rightmost dimension takes priority, whereas VIGRA uses Fortran-order, i.e. the leftmost dimension takes priority. A method like flatten can be implemented in VIGRA as:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, int&gt; intArray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,2));

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;intArray.size(); ++k=
        intArray[k] = k+1;
    
    <span class="comment">// create 1D-array of appropriate size</span>
    std::vector&lt;int&gt; flatArray(intArray.size());
    
    <span class="comment">// copy 2D-array into 1D-array using the STL</span>
    std::copy(intArray.begin(), intArray.end(), flatArray.begin());
    
    <span class="comment">// print 1D-array on console</span>
    <span class="comment">// (same output as printing from the StridedScanOrderIterator directly) </span>
    <span class="keywordflow">for</span> (std::vector&lt;int&gt;::iterator i = flatArray.begin(); i != flatArray.end(); ++i)
         std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    std::cout &lt;&lt; std::endl;
</pre></div><p>To show the difference between VIGRA and NumPy we'll add the NumPy output, i.e. the result when we had used C-order in the code above:</p>
<div class="fragment"><pre class="fragment">
    flatArray - index     0       1       2       3       4       5 
    -----------------------------------------------------------------
    VIGRA-output:         1       2       3       4       5       6
    intArray - index    [0,0]   [1,0]   [2,0]   [0,1]   [1,1]   [2,1]
    -----------------------------------------------------------------
    NumPy-output:         1       4       2       5       3       6
    intArray - index    [0,0]   [0,1]   [1,0]   [1,1]   [2,0]   [2,1]
    </pre></div><p>To change the axis priorities of the StridedScanOrderIterator, look at the transpose-function in the next section.</p>
<h2><a class="anchor" id="MultiArrayMethods"></a>
Important MultiArray Methods</h2>
<p>This part of the tutorial explains important methods of MultiArray. However, before we proceed, we need to introduce the class <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a>.</p>
<h3><a class="anchor" id="MultiArrayViewBasics"></a>
The MultiArrayView Interface</h3>
<p>A <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> has the same interface as a MultiArray (with the exception of <code>reshape()</code> and <code>swap()</code>), but it doesn't own its data. Instead, it provides a <em>view</em> onto the data of some other array. In contrast, a MultiArray owns its data and is responsible for freeing it in the destructor. MultiArrays are automatically converted into MultiArrayViews when needed.</p>
<p>The point of this distinction is that MultiArrayViews can be used to access and manipulate the same data in many different ways <em>without any need for creating copies</em>. For example, we can work with a 2-dimensional slice of a volume dataset (i.e. a lower dimensional part of a 3D array) without first copying the slice into a 2D image. This is possible whenever the desired view can be realized by just manipulating the internal <em>mapping</em> from indices and shapes to memory locations, and not the memory layout itself.</p>
<p>This possibility -- which is similarly implemented in other packages like Matlab and numpy -- is a key ingredient for efficient computations with multi-dimensional arrays. Thus, most VIGRA functions actually receive MultiArrayViews to maximize flexibility. This section describes the most important ways to create new MultiArrayViews from an existing array or view. The complete documentation is available in the <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> reference.</p>
<hr/>
<h3><a class="anchor" id="MultiArray_subarray"></a>
subarray(p,q)</h3>
<p>This method creates a rectangular subarray of your array between the points p and q, where p (the starting point of the subregion) is included, q (the ending point) is not. <code>subarray</code> does not change the dimension of the array (this is the task of the various <code>bind</code>-methods).</p>
<p>To give an example, we create a 4x4 array that consitst of a checkerboard with 2x2 squares:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, float&gt; array_4x4(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(4,4));  <span class="comment">// zero (black) initialized</span>
    
    <span class="comment">// paint the upper left 2x2 square white</span>
    array_4x4.subarray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(0,0), <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(2,2)) = 1.0;
    
    <span class="comment">// likewise for the lower right 2x2 square, but this time we </span>
    <span class="comment">// store the array view explicitly for illustration</span>
    MultiArrayView&lt;2, int&gt; lower_right_square = array_4x4.subarray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(2,2), <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(4,4));
    lower_right_square = 1.0;
    
    <span class="comment">// contents of array_4x4 now:</span>
    <span class="comment">//    1 1 0 0</span>
    <span class="comment">//    1 1 0 0</span>
    <span class="comment">//    0 0 1 1</span>
    <span class="comment">//    0 0 1 1</span>
</pre></div><p>The positions p and q are specified with the familiar <code>Shape</code> objects. In this example we simply overwrite parts of the array. The following larger example uses <code>subarray</code> to output a half-sized subimage around the center of the original image: <a href="subimage_tutorial_8cxx-example.html">subimage_tutorial.cxx</a> <br/>
 The relevant part of this code is shown here (the functions <code>importImage</code> and <code>exportImage</code> are described in section <a class="el" href="ImageInputOutputTutorial.html">Image Input and Output</a>):</p>
 <div class="fragment"><pre class="fragment">        <span class="comment">// read image given as first argument</span>
        <span class="comment">// file type is determined automatically</span>
        ImageImportInfo info(argv[1]);
        
        <span class="keywordflow">if</span>(info.isGrayscale()) 
        {
            <span class="comment">// read image from file</span>
            MultiArray&lt;2, UInt8&gt; imageArray(info.shape());
            importImage(info, imageArray);

            <span class="comment">// we want to cut out the center of the original image, such that the </span>
            <span class="comment">// size of the remaining image is half the original</span>
            <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a> upperLeft  = info.shape() / 4,
                   lowerRight = info.shape() - upperLeft;
        
            <span class="comment">// create subimage around center for output</span>
            MultiArrayView&lt;2, UInt8&gt; subimage = imageArray.subarray(upperLeft, lowerRight);
            
            <span class="comment">// write the subimage to the file provided as second command line argument</span>
            <span class="comment">// the file type will be determined from the file name&#39;s extension</span>
            exportImage(subimage, ImageExportInfo(argv[2]));
</pre></div></p>
<p>After reading the (here: gray scale) image data to an array we need to calculate the coordinates of our subimage. In this case we want to cut out the middle part of the image. Afterwards we write the subimage into a new array. Look at the result:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_sub.gif" alt="lenna_sub.gif"/>
<div class="caption">
subimage output file</div></div>
   </td></tr>
</table>
<hr/>
<h3><a class="anchor" id="MultiArray_bind"></a>
bind&lt;M&gt;(i) and bindAt(M, i)</h3>
<p>These methods bind axis M to the index i and thus reduce the dimension of the array by one. The only difference between the two forms is that the axis to be bound must be known at compile time in the first form, whereas it can be specified at runtime in the second.</p>
<p>Binding is useful when we want to access and/or manipulate a particular row or column of an image, or a single slice of a volume. In principle, the same can also be achieved by explicit loops, but use of <code>bind</code> often leads to more elegant and more generic code. Consider the following code to initialize the third column of an image with the constant 5:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// initialize 200x100 image</span>
    MultiArray&lt;2, int&gt; array2d(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(200,100)); <span class="comment">// zero initialized</span>

    <span class="comment">// initialize column 2 with value 5 using a loop</span>
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;array2d.shape(1); ++y)
        array2d(2, y) = 5;
        
    <span class="comment">// the same using bind</span>
    array2d.bind&lt;0&gt;(2) = 5;
</pre></div><p>NumPy-Users are familiar with the bind mechanism as "slicing". The example above written in numpy syntax becomes: </p>
<div class="fragment"><pre class="fragment">
    array2d[2, :] = 5      // NumPy-equivalent of array2d.bind&lt;0&gt;(2) = 5
    </pre></div><p>You can also initialize a lower-dimensional array with the bind-method:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// initialize new 1D array with 3rd column of a 2D array</span>
    MultiArray&lt;1, int&gt; array1d = array2d.bind&lt;0&gt;(2);
</pre></div><p>The array <code>array1d</code> contains the elements the 3rd column of <code>array2d</code>. This bahavior nicely illustrates the difference between a copy and a view: <code>array1d</code> contains a copy of the 3rd column, whereas the <code>bind</code> function only creates a new view to the existing data in <code>array2d</code>.</p>
<p>At this point we have to distinguish between the classes <code> MultiArray </code> and <code> MultiArrayView </code>. MultiArray inherits from MultiArrayView and contains the memory management of the array. With MultiArrayView we can view the data stored in a MultiArray. The code above produces a copy of the 3rd column of intArray. If we change the elements of <code>lowArray</code> nothing happens to <code> intArray </code>.</p>
<div class="fragment"><pre class="fragment">         <span class="comment">// initialize 200x100 image</span>
    MultiArray&lt;2, int&gt; array2d(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(200,100)); <span class="comment">// zero initialized</span>

    <span class="comment">// initialize new 1D array with 3rd column of a 2D array</span>
    MultiArray&lt;1, int&gt; array1d = array2d.bind&lt;0&gt;(2);
    
    <span class="comment">// overwrite element [0] of array1d</span>
    array1d[0] = 1;
    
    <span class="comment">// this has no effect on the original array2d</span>
    <span class="comment">// output: 0 1</span>
    std::cout &lt;&lt; array2d(2, 0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; array1d[0] &lt;&lt; std::endl;
    
    <span class="comment">// initialize a view and overwrite element [0]</span>
    MultiArrayView&lt;1, int&gt; array_view = array2d.bind&lt;0&gt;(2);
    array_view[0] = 2;
    
    <span class="comment">// now, the original array2d has changed as well</span>
    <span class="comment">// output: 2 2</span>
    std::cout &lt;&lt; array2d(2, 0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; array_view[0] &lt;&lt; std::endl;
</pre></div><p>Moving on to image processing we'll give an example how you can flip an image by using bind. We read a gray scale image into a 2-dimensional array called <code> imageArray </code>. Then we initalize a new array <code> newImageArray </code> of the same dimension and size and set the first row of <code> newImageArray </code> to the values of the last row of <code> imageArray </code>, the second row to the values of the second last row and so on. Hence, we flip the image top to bottom.</p>
 <div class="fragment"><pre class="fragment">            <span class="comment">// mirror the image horizontally </span>
            <span class="comment">// (for didactic reasons, we implement this variant explicitly,</span>
            <span class="comment">//  note that info.height()-1 is equal to the last y-index)</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;info.height(); y++) 
            {           
                newImageArray.bind&lt;1&gt;(y) = imageArray.bind&lt;1&gt;(info.height()-1-y);
            }
</pre></div></p>
<p>However, you don't need to implement a method like this yourself because VIGRA already provides the function <a class="el" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0">reflectImage()</a>. We use this function to flip the image left-to-right:</p>
 <div class="fragment"><pre class="fragment">            <span class="comment">// mirror the image vertically</span>
            <a class="code" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0" title="Reflect image horizontally or vertically.">reflectImage</a>(imageArray, newImageArray, vertical);
</pre></div></p>
<p>The complete example can be found in <a href="mirror_tutorial_8cxx-example.html">mirror_tutorial.cxx</a>. (This program needs an infile and an outfile as command-line arguments and contains additional I/O code which will be explained in section <a class="el" href="ImageInputOutputTutorial.html">Image Input and Output</a>.) Here you can see what happens to an input file:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_mirror_horizontal.gif" alt="lenna_mirror_horizontal.gif"/>
<div class="caption">
mirrored top to bottom</div></div>
 </td><td></td><td><div class="image">
<img src="lenna_mirror_vertical.gif" alt="lenna_mirror_vertical.gif"/>
<div class="caption">
mirrored left to right</div></div>
 </td><td></td></tr>
</table>
<p>For completeness, there are five additional versions of the bind()-method:</p>
<dl>
<dt><b> bindInner(i) </b> with scalar or multi-dimensional index i: </dt>
<dd>if i is an <code> integer </code>, the innermost dimension (axis 0) is fixed to i, <br/>
 if i is <code>MultiArrayShape&lt;M&gt;::type</code> (a shape of size M), then the M innermost dimensions (axes 0...M-1) are fixed to the values in the shape vector  </dd>
<dt><b> bindOuter(i) </b> with scalar or multi-dimensional index i: </dt>
<dd>if i is an <code> integer </code>, the outmost dimension (axis N-1) is fixed to i, <br/>
 if i is <code>MultiArrayShape&lt;M&gt;::type</code> (a shape of size M), then the M outmost dimensions (axes N-M ... N-1) are fixed to the values in the shape vector  </dd>
<dt><b> diagonal() </b>: </dt>
<dd>Create a 1-dimensional view to the diagonal elements of the original array (i.e. <code>view[i] == array(i,i,i)</code> for a 3D original array).  </dd>
</dl>
<p>The opposite of binding - inserting a new axis - is also possible. However, since we cannot alter the internal memory layout and thus cannot insert additional data elements, a new axis must be singleton axis, i.e. an axis with length 1. The argument of <code>insertSingletonDimension(k)</code> determines the position of the new axis, with <code>0 &lt;= k &lt;= N</code> when the original array has <code>N</code> dimensions:</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, int&gt; array(20,10);
    std::cout &lt;&lt; array.insertSingletonDimension(1).shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// prints &quot;(20, 1, 10)&quot;</span>
</pre></div><hr/>
<h3><a class="anchor" id="MultiArray_vector_elements"></a>
expandElements(k) and bindElementChannel(i)</h3>
<p>When the array elements are vectors (i.e. <a class="el" href="classvigra_1_1TinyVector.html">vigra::TinyVector</a> or <a class="el" href="classvigra_1_1RGBValue.html">vigra::RGBValue</a>), we can expand these elements into an addtional array dimension: </p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, TinyVector&lt;int, 3&gt; &gt; vector_array(20, 10);
    std::cout &lt;&lt; vector_array.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// prints &quot;(20, 10)&quot;</span>
    
    MultiArrayView&lt;3, int&gt; expanded(vector_array.expandElements(2));
    std::cout &lt;&lt; expanded.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// prints &quot;(20, 10, 3)&quot;</span>
</pre></div><p>The argument <code>k</code> of <code>expandElements(k)</code> determines the desired position of the channel axis, i.e. the index that refers to the vector elements. When the original vector array has <code>N</code> dimensions (not counting the channel axis), it is required that <code>0 &lt;= k &lt;= N</code>.</p>
<p>Often, we are only interested in a single channel of a vector-valued array. This can be achieved with the function <code>bindElementChannel(i)</code>. For example, we can extract the green channel (i.e. channel 1) from an RGB image like this: </p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, RGBValue&lt;UInt8&gt; &gt; rgb_array(20, 10);
    MultiArrayView&lt;2, UInt8&gt; green_channel(rgb_array.bindElementChannel(1));
</pre></div><p> This is simply an abbreviation for <code>rgb_array.expandElements(0).bindInner(1)</code>.</p>
<hr/>
<h3><a class="anchor" id="MultiArray_transpose"></a>
transpose()</h3>
<p>Everyone is familiar with the <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">transpose()</a></code> function of a matrix (i.e. a 2-dimensional array). Once again, this operation is possible without copying the data by just manipulating the internal access functions. The following example demonstrates the difference between a transposed copy and view:</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// create array</span>
    MultiArray&lt;2, int&gt; base_array(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(4,4));
    
    <span class="comment">// init array such that pixel values are equal to their x coordinate</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; base_array.size(); i++) 
    {
        base_array[i] = i % base_array.shape(0);
    }

    std::cout &lt;&lt; <span class="stringliteral">&quot;base_array:\n&quot;</span>;
    print(base_array);

    <span class="comment">// create a transposed array and a transposed view</span>
    MultiArray&lt;2, int&gt; transarray = base_array.transpose();
    MultiArrayView&lt;2, int&gt; transarrayView = base_array.transpose();

    std::cout &lt;&lt; <span class="stringliteral">&quot;transarray:\n&quot;</span>;
    print(transarray);
    std::cout &lt;&lt; <span class="stringliteral">&quot;transArrayView:\n&quot;</span>;
    print(transarrayView);

    <span class="comment">// set transarray to 5    </span>
    transarray = 5;
    std::cout &lt;&lt; <span class="stringliteral">&quot;base_array after setting transarray to 5\n(no change, since transarray is a copy):\n&quot;</span>;
    print(base_array);

    <span class="comment">// set transarrayView to 5</span>
    transarrayView = 5;
    std::cout &lt;&lt; <span class="stringliteral">&quot;base_array after setting transarrayView to 5\n(base_array changes because transarrayView is a view):\n&quot;</span>;
    print(base_array);
</pre></div></p>
<p>The output is:</p>
<div class="fragment"><pre class="fragment">
    base_array:
    0  1  2  3
    0  1  2  3
    0  1  2  3
    0  1  2  3
    transarray:
    0  0  0  0
    1  1  1  1
    2  2  2  2
    3  3  3  3
    transArrayView:
    0  0  0  0
    1  1  1  1
    2  2  2  2
    3  3  3  3
    base_array after setting transarray to 5
    (no change, since transarray is a copy):
    0  1  2  3
    0  1  2  3
    0  1  2  3
    0  1  2  3
    base_array after setting transarrayView to 5
    (base_array changes because transarrayView is a view):
    5  5  5  5
    5  5  5  5
    5  5  5  5
    5  5  5  5
    </pre></div><p>The function <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a></code> generalizes transposition to arrays of arbitrary dimensions. Here, it just reverses the order of the axes: axis 0 becomes axis N-1, axis 1 becomes axis N-2 and so on. In the following example we transpose a 5D array and print out its shape.</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// transposing a 5D array</span>
    <span class="comment">// instantiate 5D array</span>
    MultiArray&lt;5, int&gt; array5D(<a class="code" href="group__MultiIteratorGroup.html#ga5eb712151ca3fc644d569dee5723f67c" title="shape type for MultiArray&lt;5, T&gt;">Shape5</a>(1,2,3,4,5));

    <span class="comment">// print the shape of the original array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of array5D: &quot;</span> &lt;&lt; array5D.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

    <span class="comment">// transpose array</span>
    MultiArrayView&lt;5, int&gt; arrayview5D = array5D.transpose();

    <span class="comment">// print the shape of transposed array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of array5D view after default transpose(): &quot;</span> &lt;&lt; arrayview5D.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
</pre></div></p>
<p>The output is:</p>
<div class="fragment"><pre class="fragment">
    Shape of array5D: (1, 2, 3, 4, 5)
    Shape of array5D view after default transpose(): (5, 4, 3, 2, 1)
    </pre></div><p>Finally, <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a></code> can also be called with a shape object that specifies the desired permutation of the axes: When <code>permutation[k] = j</code>, axis <code>j</code> of the original array becomes axis <code>k</code> of the transposed array (remember, that VIGRA counts the axes from 0):</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// transpose to an explicitly specified axis permutation</span>
    MultiArrayView&lt;5, int&gt; arrayview5D_permuted = array5D.transpose(<a class="code" href="group__MultiIteratorGroup.html#ga5eb712151ca3fc644d569dee5723f67c" title="shape type for MultiArray&lt;5, T&gt;">Shape5</a>(2,1,3,4,0));

    <span class="comment">// print the shape of transposed array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of array5D view after user-defined transpose(): &quot;</span> &lt;&lt; arrayview5D_permuted.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    std::cout &lt;&lt; <span class="stringliteral">&quot;    (applied permutation 2 =&gt; 0, 1 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 0 =&gt; 4 to the axes)\n&quot;</span>;
</pre></div></p>
<p>The permutation in the example is 2,1,3,4,0. Thus, original dimension 0 appears in the last position of the new view, original dimension 2 appears in the first position, and so on as demonstrated by the output of the example:</p>
<div class="fragment"><pre class="fragment">
    Shape of array5D view after user-defined transpose(): (3, 2, 4, 5, 1)
        (applied permutation 2 =&gt; 0, 1 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 0 =&gt; 4 to the axes)
    </pre></div><p>When we transpose an image about the major diagonal, we can simply use the view created by <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a></code>. However, transposition about the minor diagonal requires a new image, which can be filled by <a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090">transposeImage()</a> like this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="impex_8hxx.html" title="image import and export functions">vigra/impex.hxx</a>&gt;</span>
<span class="preprocessor">#include &lt;vigra/basicgeometry.hxx&gt;</span>

<span class="keyword">using namespace </span>vigra; 

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)
{
    <span class="keywordflow">if</span>(argc != 3) 
    {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; infile outfile&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;(grayscale images only, supported formats: &quot;</span> &lt;&lt; <a class="code" href="group__VigraImpex.html#ga1f42a533f86021968b8ca4d9d9644279" title="List the image formats VIGRA can read and write.">impexListFormats</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1;
    }
    
    <span class="comment">// choose diagonal for transpose</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Transpose about which diagonal?\n&quot;</span>;
    std::cout &lt;&lt; <span class="stringliteral">&quot;1 - major\n&quot;</span>;
    std::cout &lt;&lt; <span class="stringliteral">&quot;2 - minor\n&quot;</span>;
    <span class="keywordtype">int</span> mode;
    std::cin &gt;&gt; mode;

    <span class="keywordflow">try</span> 
    {
        <span class="comment">// read image given as first command line argument</span>
        <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;2, UInt8&gt;</a> imageArray;
        <a class="code" href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e" title="Read an image from a file.">importImage</a>(argv[1], imageArray);

        <span class="keywordflow">if</span>(mode == 1)
        {
            <span class="comment">// when transposing about the major diagonal, we can simply</span>
            <span class="comment">// write a transposed view to the file given as second argument</span>
            <a class="code" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3" title="Write an image to a file.">exportImage</a>(imageArray.transpose(), argv[2]);
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">// when transposing about the minor diagonal, we need a new</span>
            <span class="comment">// image with reversed shape to hold the transposed data</span>
            <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;2, UInt8&gt;</a> transposed(<a class="code" href="group__TinyVectorOperators.html#ga8ca94c8917082971917a51ece034f52f" title="reversed copy">reverse</a>(imageArray.shape()));
            <a class="code" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090" title="Transpose an image over the major or minor diagonal.">transposeImage</a>(imageArray, transposed, minor);
            <a class="code" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3" title="Write an image to a file.">exportImage</a>(transposed, argv[2]);
        }
    }
    <span class="keywordflow">catch</span> (std::exception &amp; e) 
    {
        <span class="comment">// catch any errors that might have occurred and print their reason</span>
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>The result is:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_transposed_major.gif" alt="lenna_transposed_major.gif"/>
<div class="caption">
transpose about major diagonal</div></div>
  </td><td><div class="image">
<img src="lenna_transposed_minor.gif" alt="lenna_transposed_minor.gif"/>
<div class="caption">
transpose about minor diagonal</div></div>
   </td></tr>
</table>
<p>In VIGRA, image transposition is also implemented in function <code><a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090" title="Transpose an image over the major or minor diagonal.">vigra::transposeImage</a>(...)</code>. The difference is that <a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090" title="Transpose an image over the major or minor diagonal.">transposeImage()</a> copies the image data, whereas <a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a> just changes the internal mapping from indices to memory locations.</p>
<p><b>Important note:</b> Transposing an array also changes the direction of the StridedScanOrderIterator. Imagine a 3x4- matrix. Scan-order means that we iterate from left to right, row by row. Now, let's transpose the matrix to a 4x3 view. Than, scan-order in the new view is again left to right, row by row. However, in the original matrix this now corresponds to a transposed scan: from top to bottom, column by column. The same applies to the array's index operator with integer argument.</p>
<hr/>
<h3><a class="anchor" id="MultiArray_unstrided"></a>
isUnstrided(k)</h3>
<p>A MultiArray always accesses its elements in consecutive memory order, i.e. <code>&amp;array[i] == &amp;array.data()[i]</code> for all <code>i</code> in the range <code>[0, array.size())</code>. However, this does in general not hold for MultiArrayViews, because changing array access is the whole point of view creation. Sometimes, it is necessary to find out if a view still has consecutive, unstrided memory access, for example when you want to pass on the view's data to an external library that only accepts plain C arrays: When the view happens to be unstrided, you can avoid to create a copy of the data. You can determine this with the function <code>isUnstrided(k)</code> which returns <code>true</code> when the array is unstrided up to dimension <code>k</code> (<code>k</code> defaults to <code>N-1</code>, i.e. the entire array must be unstrided): </p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, int&gt; array(20,10);
    std::cout &lt;&lt; array.isUnstrided() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; array.transpose().isUnstrided() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// prints &quot;true false&quot;</span>
</pre></div> </div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
