<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Feature Accumulators</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Feature Accumulators
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<p>The namespace <code><a class="el" href="namespacevigra_1_1acc.html">vigra::acc</a></code> provides the function <a class="el" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">vigra::acc::extractFeatures()</a> along with associated statistics functors and accumulator classes. Together, they provide a framework for efficient compution of a wide variety of statistical features, both globally for an entire image, and locally for each region defined by a label array. Many different statistics can be composed out of a small number of fundamental statistics and suitable modifiers. The user simply selects the desired statistics by means of their <em>tags</em> (see below), and a template meta-program automatically generates an efficient functor that computes exactly those statistics.</p>
<p>The function <a class="el" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures()</a> scans the data in as few passes as the selected statstics permit (usually one or two passes are sufficient). Statistics are computed by accurate incremental algorithms, whose internal state is maintained by accumulator objects. The state is updated by passing data to the accumulator one sample at a time. Accumulators are grouped within an accumulator chain. Dependencies between accumulators in the accumulator chain are automatically resolved and missing dependencies are inserted. For example, to compute the mean, you also need to count the number of samples. This allows accumulators to offload some of their computations on other accumulators, making the algorithms more efficient. Each accumulator only sees data in the appropriate pass through the data, called its "working pass".</p>
<p><b>#include</b> &lt;<a class="el" href="accumulator_8hxx_source.html">vigra/accumulator.hxx</a>&gt;</p>
<p><b>Basic statistics:</b></p>
<ul>
<li>PowerSum&lt;N&gt; (computes <img class="formulaInl" alt="$ \sum_i x_i^N $" src="form_122.png"/>)</li>
<li>AbsPowerSum&lt;N&gt; (computes <img class="formulaInl" alt="$ \sum_i |x_i|^N $" src="form_123.png"/>)</li>
<li>Skewness, UnbiasedSkewness</li>
<li>Kurtosis, UnbiasedKurtosis</li>
<li>Minimum, Maximum</li>
<li>FlatScatterMatrix (flattened upper-triangular part of scatter matrix)</li>
<li>4 histogram classes (see <a class="el" href="group__FeatureAccumulators.html#histogram">below</a>)</li>
<li>StandardQuantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%)</li>
<li>ArgMinWeight, ArgMaxWeight (store data or coordinate where weight assumes its minimal or maximal value)</li>
<li>CoordinateSystem (identity matrix of appropriate size)</li>
</ul>
<p><b>Modifiers:</b> (S is the statistc to be modified)</p>
<ul>
<li>Normalization <table  border="0">
<tr>
<td>DivideByCount&lt;S&gt; </td><td>S/Count  </td></tr>
<tr>
<td>RootDivideByCount&lt;S&gt; </td><td>sqrt( S/Count )  </td></tr>
<tr>
<td>DivideUnbiased&lt;S&gt; </td><td>S/(Count-1)  </td></tr>
<tr>
<td>RootDivideUnbiased&lt;S&gt; &#160; &#160; </td><td>sqrt( S/(Count-1) )  </td></tr>
</table>
</li>
<li>Data preparation: <table  border="0">
<tr>
<td>Central&lt;S&gt; </td><td>substract mean before computing S  </td></tr>
<tr>
<td>Principal&lt;S&gt; </td><td>project onto PCA eigenvectors  </td></tr>
<tr>
<td>Whitened&lt;S&gt; &#160; &#160; </td><td>scale to unit variance after PCA  </td></tr>
<tr>
<td>Coord&lt;S&gt; </td><td>compute S from pixel coordinates rather than from pixel values  </td></tr>
<tr>
<td>Weighted&lt;S&gt; </td><td>compute weighted version of S  </td></tr>
<tr>
<td>Global&lt;S&gt; </td><td>compute S globally rather than per region (per region is default if labels are given)  </td></tr>
</table>
</li>
</ul>
<p>Aliases for many important features are implemented (mainly as <code>typedef FullName Alias</code>). The alias names are equivalent to full names. Below are some examples for supported alias names. A full list of all available statistics and alias names can be found in the namespace reference <code><a class="el" href="namespacevigra_1_1acc.html">vigra::acc</a></code>. These examples also show how to compose statistics from the fundamental statistics and modifiers:</p>
<table  border="0">
<tr>
<th>Alias </th><th>Full Name  </th></tr>
<tr>
<td>Count </td><td>PowerSum&lt;0&gt;  </td></tr>
<tr>
<td>Sum </td><td>PowerSum&lt;1&gt;  </td></tr>
<tr>
<td>SumOfSquares </td><td>PowerSum&lt;2&gt;  </td></tr>
<tr>
<td>Mean </td><td>DivideByCount&lt;PowerSum&lt;1&gt;&gt;  </td></tr>
<tr>
<td>RootMeanSquares &#160; </td><td>RootDivideByCount&lt;PowerSum&lt;2&gt;&gt;  </td></tr>
<tr>
<td>Moment&lt;N&gt; </td><td>DivideByCount&lt;PowerSum&lt;N&gt;&gt;  </td></tr>
<tr>
<td>Variance </td><td>DivideByCount&lt;Central&lt;PowerSum&lt;2&gt;&gt;&gt;  </td></tr>
<tr>
<td>StdDev </td><td>RootDivideByCount&lt;Central&lt;PowerSum&lt;2&gt;&gt;&gt;  </td></tr>
<tr>
<td>Covariance </td><td>DivideByCount&lt;FlatScatterMatrix&gt;  </td></tr>
<tr>
<td>RegionCenter </td><td>Coord&lt;Mean&gt;  </td></tr>
<tr>
<td>CenterOfMass </td><td>Weighted&lt;Coord&lt;Mean&gt;&gt;  </td></tr>
</table>
<p>There are a few <b>rules for composing statistics</b>:</p>
<ul>
<li>modifiers can be specified in any order, but are internally transformed to standard order: Global&lt;Weighted&lt;Coord&lt;normalization&lt;data preparation&lt;basic statistic</li>
<li>only one normalization modifier and one data preparation modifier (Central or Principal or Whitened) is permitted</li>
<li>Count ignores all modifiers except Global and Weighted</li>
<li>Sum ignores Central and Principal, because sum would be zero</li>
<li>ArgMinWeight and ArgMaxWeight are automatically Weighted</li>
</ul>
<p>Here is an example how to use <a class="el" href="classvigra_1_1acc_1_1AccumulatorChain.html">acc::AccumulatorChain</a> to compute statistics. (To use Weighted&lt;&gt; or Coord&lt;&gt; modifiers, see below):</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">    #include &lt;<a class="code" href="impex_8hxx.html" title="image import and export functions">vigra/impex.hxx</a>&gt;</span>
<span class="preprocessor">    #include &lt;vigra/accumulator.hxx&gt;</span>
    <span class="keyword">using namespace </span>vigra::acc;
    <span class="keyword">typedef</span> <span class="keywordtype">double</span> DataType;
    <span class="keywordtype">int</span> size = 1000;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;2, DataType&gt;</a> data(<a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::Shape2</a>(size, size));
   
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain</a>&lt;DataType, 
        <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Variance, Mean, StdDev, Minimum, Maximum, RootMeanSquares, Skewness, Covariance&gt;</a> &gt;
        a;
        
    std::cout &lt;&lt; <span class="stringliteral">&quot;passes required: &quot;</span> &lt;&lt; a.passesRequired() &lt;&lt; std::endl;
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a); 
    
    std::cout &lt;&lt; <span class="stringliteral">&quot;Mean: &quot;</span> &lt;&lt; get&lt;Mean&gt;(a) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;Variance: &quot;</span> &lt;&lt; get&lt;Variance&gt;(a) &lt;&lt; std::endl;
</pre></div><p>The <a class="el" href="classvigra_1_1acc_1_1AccumulatorChain.html">acc::AccumulatorChain</a> object contains the selected statistics and their dependencies. Statistics have to be wrapped with <a class="el" href="structvigra_1_1acc_1_1Select.html">acc::Select</a>. The statistics are computed with the <a class="el" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">acc::extractFeatures</a> function and the statistics can be accessed with <a class="el" href="namespacevigra_1_1acc.html#ae1dae7352beb92b0f5b64b44d4fca420">acc::get</a> .</p>
<p>Rules and notes:</p>
<ul>
<li>order of statistics in Select&lt;&gt; is arbitrary</li>
<li>up to 20 statistics in Select&lt;&gt;, but Select&lt;&gt; can be nested</li>
<li>dependencies are automatically inserted</li>
<li>duplicates are automatically removed</li>
<li>extractFeatures() does as many passes through the data as necessary</li>
<li>each accumulator only sees data in the appropriate pass (its "working pass")</li>
</ul>
<p>The Accumulators can also be used with vector-valued data (<a class="el" href="classvigra_1_1RGBValue.html" title="Class for a single RGB value.">vigra::RGBValue</a>, <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::TinyVector</a>, <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray</a> or <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">vigra::MultiArrayView</a>):</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1RGBValue.html" title="Class for a single RGB value.">vigra::RGBValue&lt;double&gt;</a> DataType;
    AccumulatorChain&lt;DataType, Select&lt;...&gt; &gt; a;
    ...
</pre></div><p>To compute <b>weighted statistics</b> (Weighted&lt;&gt;) or <b>statistics over coordinates</b> (Coord&lt;&gt;), the accumulator chain can be used with several coupled arrays, one for the data and another for the weights and/or the labels. "Coupled" means that statistics are computed over the corresponding elements of the involved arrays. This is internally done by means of <a class="el" href="classvigra_1_1CoupledScanOrderIterator.html">CoupledScanOrderIterator</a> and <a class="el" href="classvigra_1_1CoupledHandle.html">vigra::CoupledHandle</a> which provide simultaneous access to several arrays (e.g. weight and data) and corresponding coordinates. The types of the coupled arrays are best specified by means of the helper class <a class="el" href="structvigra_1_1CoupledArrays.html">vigra::CoupledArrays</a> :</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, RGBValue&lt;unsigned char&gt;</a> &gt; data(...);
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, double&gt;</a>                   weights(...);
    
    AccumulatorChain&lt;CoupledArrays&lt;3, RGBValue&lt;unsigned char&gt;, <span class="keywordtype">double</span>&gt;,
                     Select&lt;...&gt; &gt; a;
</pre></div><p>This works likewise for label images which are needed for region statistics (see below). The indxx of the array holding data, weights, or labels respectively can be specified inside the Select wrapper. These <b>index specifiers</b> are: (INDEX is of type int)</p>
<ul>
<li>DataArg&lt;INDEX&gt;: data are in array 'INDEX' (default INDEX=1)</li>
<li>LabelArg&lt;INDEX&gt;: labels are in array 'INDEX' (default INDEX=2)</li>
<li>WeightArg&lt;INDEX&gt;: weights are in array 'INDEX' (default INDEX=rightmost index)</li>
</ul>
<p>Pixel coordinates are always at index 0. To collect statistics, you simply pass all arrays to the <code>extractFeatures()</code> function: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, double&gt;</a> data(...), weights(...);
    
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain&lt;CoupledArrays&lt;3, double, double&gt;</a>, <span class="comment">// two 3D arrays for data and weights</span>
        <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;DataArg&lt;1&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1WeightArg.html" title="Specifies index of data in CoupledHandle.">WeightArg&lt;2&gt;</a>,           <span class="comment">// in which array to look (coordinates are always arg 0)</span>
               <a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">Mean</a>, <a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">Variance</a>,                     <span class="comment">//statistics over values  </span>
               <a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">Coord&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">Coord&lt;Variance&gt;</a>,       <span class="comment">//statistics over coordinates,</span>
               <a class="code" href="classvigra_1_1acc_1_1Weighted.html" title="Compute weighted version of the statistic.">Weighted&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Weighted.html" title="Compute weighted version of the statistic.">Weighted&lt;Variance&gt;</a>, <span class="comment">//weighted values,</span>
               <a class="code" href="classvigra_1_1acc_1_1Weighted.html" title="Compute weighted version of the statistic.">Weighted&lt;Coord&lt;Mean&gt;</a> &gt; &gt; &gt;          <span class="comment">//weighted coordinates.</span>
        a;
     
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data, weights, a);
</pre></div><p>This even works for a single array, which is useful if you want to combine values with coordinates. For example, to find the location of the minimum element in an array, you interpret the data as weights and select the <code>Coord&lt;ArgMinWeight&gt;</code> statistic (note that the version of <code>extractFeatures()</code> below only works in conjunction with <code><a class="el" href="structvigra_1_1CoupledArrays.html">CoupledArrays</a></code>, despite the fact that there is only one array involved): </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, double&gt;</a> data(...);
    
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain&lt;CoupledArrays&lt;3, double&gt;</a>,
                     <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;WeightArg&lt;1&gt;</a>,           <span class="comment">// we interprete the data as weights</span>
                            <a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">Coord&lt;ArgMinWeight&gt;</a> &gt; &gt; <span class="comment">// and look for the coordinate with minimal weight</span>
        a;
        
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data, a);
    std::cout &lt;&lt; <span class="stringliteral">&quot;minimum is at &quot;</span> &lt;&lt; get&lt;Coord&lt;ArgMinWeight&gt; &gt;(a) &lt;&lt; std::endl;
</pre></div><p>To compute <b>region statistics</b>, you use <a class="el" href="classvigra_1_1acc_1_1AccumulatorChainArray.html">acc::AccumulatorChainArray</a>. Regions are defined by means of a label array whose elements specify the region ID of the corresponding point. Therefore, you will always need at least two arrays here, which are again best specified using the <code><a class="el" href="structvigra_1_1CoupledArrays.html">CoupledArrays</a></code> helper:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, double&gt;</a> data(...);
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> labels(...);

    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray&lt;CoupledArrays&lt;3, double, int&gt;</a>,
        <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;DataArg&lt;1&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1LabelArg.html" title="Specifies index of labels in CoupledHandle.">LabelArg&lt;2&gt;</a>,       <span class="comment">// in which array to look (coordinates are always arg 0)</span>
               <a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">Mean</a>, <a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">Variance</a>,                    <span class="comment">//per-region statistics over values</span>
               <a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">Coord&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">Coord&lt;Variance&gt;</a>,      <span class="comment">//per-region statistics over coordinates</span>
               <a class="code" href="classvigra_1_1acc_1_1Global.html" title="Modifier. Compute statistic globally rather than per region.">Global&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Global.html" title="Modifier. Compute statistic globally rather than per region.">Global&lt;Variance&gt;</a> &gt; &gt; <span class="comment">//global statistics</span>
    a;

    a.ignoreLabel(0); <span class="comment">//statistics will not be computed for region 0 (e.g. background)</span>

    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data, labels, a);

    <span class="keywordtype">int</span> regionlabel = ...;
    std::cout &lt;&lt; get&lt;Mean&gt;(a, regionlabel) &lt;&lt; std::endl; <span class="comment">//get Mean of region with label &#39;regionlabel&#39;</span>
</pre></div><p>In some application it will be known only at run-time which statistics have to be computed. An Accumulator with <b>run-time activation</b> is provided by the <a class="el" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html">acc::DynamicAccumulatorChain</a> class. One specifies a set of statistics at compile-time and from this set one can activate the needed statistics at run-time:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, double&gt;</a> data(...);
    <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html" title="Create a dynamic accumulator chain containing the selected statistics and their dependencies.">DynamicAccumulatorChain</a>&lt;double, 
        <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Mean, Minimum, Maximum, Variance, StdDev&gt;</a> &gt; a; <span class="comment">// at compile-time</span>
    activate&lt;Mean&gt;(a);      <span class="comment">//at run-time</span>
    a.activate(<span class="stringliteral">&quot;Minimum&quot;</span>);  <span class="comment">//same as activate&lt;Minimum&gt;(a) (alias names are not recognized)</span>
    
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a);
    std::cout &lt;&lt; <span class="stringliteral">&quot;Mean: &quot;</span> &lt;&lt; get&lt;Mean&gt;(a) &lt;&lt; std::endl;       <span class="comment">//ok</span>
    <span class="comment">//std::cout &lt;&lt; &quot;Maximum: &quot; &lt;&lt; get&lt;Maximum&gt;(a) &lt;&lt; std::endl; // run-time error because Maximum not activated</span>
</pre></div><p>Likewise, for run-time activation of region statistics, use <a class="el" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html">acc::DynamicAccumulatorChainArray</a>.</p>
<p><b>Accumulator merging</b> (e.g. for parallelization or hierarchical segmentation) is possible for many accumulators:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, double&gt;</a> data(...);
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain&lt;double, Select&lt;Mean, Variance, Skewness&gt;</a> &gt; a, a1, a2;

    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a); <span class="comment">//process entire data set at once</span>
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.begin()+data.size()/2, a1); <span class="comment">//process first half</span>
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin()+data.size()/2, data.end(), a2); <span class="comment">//process second half</span>
    a1 += a2; <span class="comment">// merge: a1 now equals a0 (within numerical tolerances)</span>
</pre></div><p>Not all statistics can be merged (e.g. Principal usually cannot, except for some important specializations). A statistic can be merged if the "+=" operator is supported (see the documentation of that particular statistic). If the accumulator chain only requires one pass to collect the data, it is also possible to just apply the extractFeatures() function repeatedly:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, double&gt;</a> data(...);
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain&lt;double, Select&lt;Mean, Variance&gt;</a> &gt; a;

    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.begin()+data.size()/2, a); <span class="comment">// this works because </span>
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin()+data.size()/2, data.end(), a);   <span class="comment">// all statistics only need pass 1</span>
</pre></div><p>More care is needed to merge coordinate-based statistics. By default, all coordinate statistics are computed in the local coordinate system of the current region of interest. That is, the upper left corner of the ROI has the coordinate (0, 0) by default. This behavior is not desirable when you want to merge coordinate statistics from different ROIs: then, all accumulators should use the same coordinate system, usually the global system of the entire dataset. This can be achieved by the <code>setCoordinateOffset()</code> function. The following code demonstrates this for the <code>RegionCenter</code> statistic:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra;
    <span class="keyword">using namespace </span>vigra::acc;
    
    <a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, double&gt;</a> data(width, height);
    <a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, int&gt;</a>    labels(width, height);
    
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray&lt;CoupledArrays&lt;2, double, int&gt;</a>,
                          <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;DataArg&lt;1&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1LabelArg.html" title="Specifies index of labels in CoupledHandle.">LabelArg&lt;2&gt;</a>, 
                                 <a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">RegionCenter</a>&gt; &gt;
    a1, a2;
    
    <span class="comment">// a1 is responsible for the left half of the image. The local coordinate system of this ROI </span>
    <span class="comment">// happens to be identical to the global coordinate system, so the offset is zero.</span>
    <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">Shape2</a> origin(0,0);
    a1.setCoordinateOffset(origin);
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.subarray(origin, <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">Shape2</a>(width/2, height)), 
                    labels.subarray(origin, <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width/2, height)),
                    a1);
                    
    <span class="comment">// a2 is responsible for the right half, so the offset of the local coordinate system is (width/2, 0)</span>
    origin = <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width/2, 0);
    a2.setCoordinateOffset(origin);
    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.subarray(origin, <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">Shape2</a>(width, height)), 
                    labels.subarray(origin, <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(width, height)),
                    a2);
   
    <span class="comment">// since both accumulators worked in the same global coordinate system, we can safely merge them</span>
    a1.merge(a2);
</pre></div><p>When you compute region statistics in ROIs, it is sometimes desirable to use a local region labeling in each ROI. In this way, the labels of each ROI cover a consecutive range of numbers starting with 0. This can save a lot of memory, because <code>AccumulatorChainArray</code> internally uses dense arrays -- accumulators will be allocated for all labels from 0 to the maxmimum label, even when many of them are unused. This is avoided by a local labeling. However, this means that label 1 (say) may refer to two different regions in different ROIs. To adjust for this mismatch, you can pass a label mapping to <code>merge()</code> that provides a global label for each label of the accumulator to be merged. Thus, each region on the right hand side will be merged into the left-hand-side accumulator with the given <em>global</em> label. For example, let us assume that the left and right half of the image contain just one region and background. Then, the accumulators of both ROIs have the label 0 (background) and 1 (the region). Upon merging, the region from the right ROI should be given the global label 2, whereas the background should keep its label 0. This is achieved like this:</p>
<div class="fragment"><pre class="fragment">    std::vector&lt;int&gt; labelMapping(2);
    labelMapping[0] = 0;   <span class="comment">// background keeps label 0</span>
    labelMapping[1] = 2;   <span class="comment">// local region 1 becomes global region 2</span>
    
    a1.merge(a2, labelMapping);
</pre></div><p><a class="anchor" id="histogram"></a> Four kinds of <b>histograms</b> are currently implemented:</p>
<table  border="0">
<tr>
<td>IntegerHistogram </td><td>Data values are equal to bin indices  </td></tr>
<tr>
<td>UserRangeHistogram </td><td>User provides lower and upper bounds for linear range mapping from values to indices.  </td></tr>
<tr>
<td>AutoRangeHistogram </td><td>Range mapping bounds are defiend by minimum and maximum of the data (2 passes needed!)  </td></tr>
<tr>
<td>GlobalRangeHistogram &#160; </td><td>Likewise, but use global min/max rather than region min/max as AutoRangeHistogram will  </td></tr>
</table>
<ul>
<li>The number of bins is specified at compile time (as template parameter int BinCount) or at run-time (if BinCount is zero at compile time). In the first case the return type of the accumulator is <a class="el" href="classvigra_1_1TinyVector.html">TinyVector&lt;double, BinCount&gt;</a> (number of bins cannot be changed). In the second case, the return type is <a class="el" href="classvigra_1_1MultiArray.html">MultiArray&lt;1, double&gt;</a> and the number of bins must be set before seeing data (see example below).</li>
<li>If UserRangeHistogram is used, the bounds for the linear range mapping from values to indices must be set before seeing data (see below).</li>
<li>Options can be set by passing an instance of <a class="el" href="classvigra_1_1HistogramOptions.html" title="Set histogram options.">HistogramOptions</a> to the accumulator chain (same options for all histograms in the chain) or by directly calling the appropriate member functions of the accumulators.</li>
<li>Merging is supported if the range mapping of the histograms is the same.</li>
<li>Histogram accumulators have two members for outliers (left_outliers, right_outliers).</li>
</ul>
<p>With the StandardQuantiles class, <b>histogram quantiles</b> (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from a given histgram using linear interpolation. The return type is <a class="el" href="classvigra_1_1TinyVector.html">TinyVector&lt;double, 7&gt;</a> .</p>
<p><a class="anchor" id="acc_hist_options"></a>Usage: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::acc;
    <span class="keyword">typedef</span> <span class="keywordtype">double</span> DataType;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;2, DataType&gt;</a> data(...);
    
    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1UserRangeHistogram.html" title="Histogram where user provides bounds for linear range mapping from values to indices.">UserRangeHistogram&lt;40&gt;</a> SomeHistogram;   <span class="comment">//binCount set at compile time</span>
    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1UserRangeHistogram.html" title="Histogram where user provides bounds for linear range mapping from values to indices.">UserRangeHistogram&lt;0&gt;</a> SomeHistogram2; <span class="comment">// binCount must be set at run-time</span>
    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1AutoRangeHistogram.html" title="Histogram where range mapping bounds are defined by minimum and maximum of data.">AutoRangeHistogram&lt;0&gt;</a> SomeHistogram3;
    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1StandardQuantiles.html" title="Compute (0%, 10%, 25%, 50%, 75%, 90%, 100%) quantiles from given histogram.">StandardQuantiles&lt;SomeHistogram3&gt;</a> Quantiles3;
    
    <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain&lt;DataType, Select&lt;SomeHistogram, SomeHistogram2, SomeHistogram3, Quantiles3&gt;</a> &gt; a;
    
    <span class="comment">//set options for all histograms in the accumulator chain:</span>
    <a class="code" href="classvigra_1_1HistogramOptions.html" title="Set histogram options.">vigra::HistogramOptions</a> histogram_opt;         
    histogram_opt = histogram_opt.<a class="code" href="classvigra_1_1HistogramOptions.html#adbbd8c327b126c15338d3f37709faa6e">setBinCount</a>(50); 
    <span class="comment">//histogram_opt = histogram_opt.setMinMax(0.1, 0.9); // this would set min/max for all three histograms, but range bounds </span>
                                                         <span class="comment">// shall be set automatically by min/max of data for SomeHistogram3</span>
    a.setHistogramOptions(histogram_opt);  

    <span class="comment">// set options for a specific histogram in the accumulator chain:</span>
    getAccumulator&lt;SomeHistogram&gt;(a).setMinMax(0.1, 0.9); <span class="comment">// number of bins must be set before setting min/max</span>
    getAccumulator&lt;SomeHistogram2&gt;(a).setMinMax(0.0, 1.0);

    <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a);

    <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::TinyVector&lt;double, 40&gt;</a> hist = get&lt;SomeHistogram&gt;(a);
    <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;1, double&gt;</a> hist2 = get&lt;SomeHistogram2&gt;(a);
    <a class="code" href="classvigra_1_1TinyVector.html">vigra::TinyVector&lt;double, 7&gt;</a> quant = get&lt;Quantiles3&gt;(a);
    <span class="keywordtype">double</span> right_outliers = getAccumulator&lt;SomeHistogram&gt;(a).right_outliers;
</pre></div> </div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
