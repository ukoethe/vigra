<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - vigra Namespace Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">vigra Namespace Reference
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1acc.html">acc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1linalg.html">linalg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1multi__math.html">multi_math</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1FourNeighborhood.html">FourNeighborhood</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1EightNeighborhood.html">EightNeighborhood</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1Neighborhood3DSix.html">Neighborhood3DSix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra_1_1Neighborhood3DTwentySix.html">Neighborhood3DTwentySix</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ArrayOfRegionStatistics.html">ArrayOfRegionStatistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate statistics for all regions of a labeled image.  <a href="classvigra_1_1ArrayOfRegionStatistics.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ArrayVector.html">ArrayVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ArrayVectorView.html">ArrayVectorView</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental class template for images.  <a href="classvigra_1_1BasicImage.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BasicImageIterator.html">BasicImageIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BasicImageIteratorBase.html">BasicImageIteratorBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BasicImageView.html">BasicImageView</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">BasicImage</a> using foreign memory.  <a href="classvigra_1_1BasicImageView.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BestGiniOfColumn.html">BestGiniOfColumn</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BilinearInterpolatingAccessor.html">BilinearInterpolatingAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear interpolation at non-integer positions.  <a href="classvigra_1_1BilinearInterpolatingAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BlueAccessor.html">BlueAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Box.html">Box</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an n-dimensional box as a (begin, end) pair. Depending on the value type, <a class="el" href="classvigra_1_1Box.html#a1d60efdd2ef2dc80805ce6fd301e92b4">end()</a> is considered to be outside the box (as in the STL, for integer types), or inside (for floating point types). <a class="el" href="classvigra_1_1Box.html#a1c84c6eaf4e01d65c070547607cbeb8d">size()</a> will always be <a class="el" href="classvigra_1_1Box.html#a1d60efdd2ef2dc80805ce6fd301e92b4">end()</a> - <a class="el" href="classvigra_1_1Box.html#a9ff7568951abbeeb1ca4497106b77b77">begin()</a>.  <a href="classvigra_1_1Box.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BrightnessContrastFunctor.html">BrightnessContrastFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust brightness and contrast of an image.  <a href="classvigra_1_1BrightnessContrastFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSpline.html">BSpline</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSplineBase.html">BSplineBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BucketQueue.html">BucketQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority queue implemented using bucket sort.  <a href="classvigra_1_1BucketQueue.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CatmullRomSpline.html">CatmullRomSpline</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ColumnIterator.html">ColumnIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator adapter to linearly access columns.  <a href="classvigra_1_1ColumnIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ConstBasicImageIterator.html">ConstBasicImageIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ConstImageIterator.html">ConstImageIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard 2D random access const iterator for images that store the data as a linear array.  <a href="classvigra_1_1ConstImageIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ConstStridedImageIterator.html">ConstStridedImageIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to be used when pixels are to be skipped.  <a href="classvigra_1_1ConstStridedImageIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ConstValueIterator.html">ConstValueIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator that always returns the constant specified in the constructor.  <a href="classvigra_1_1ConstValueIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options class template for convolutions.  <a href="classvigra_1_1ConvolutionOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoordinateConstValueAccessor.html">CoordinateConstValueAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward accessor to the value() part of the values an iterator points to.  <a href="classvigra_1_1CoordinateConstValueAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoscotFunction.html">CoscotFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1CoupledArrays.html">CoupledArrays</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoupledHandle.html">CoupledHandle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoupledScanOrderIterator.html">CoupledScanOrderIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over multiple images simultaneously in scan order.  <a href="classvigra_1_1CoupledScanOrderIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CrackContourCirculator.html">CrackContourCirculator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Circulator that walks around a given region.  <a href="classvigra_1_1CrackContourCirculator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional difference vector.  <a href="classvigra_1_1Diff2D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1DiffusivityFunctor.html">DiffusivityFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Diffusivity functor for non-linear diffusion.  <a href="classvigra_1_1DiffusivityFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Dist2D.html">Dist2D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1DT__StackEntry.html">DT_StackEntry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1EarlyStoppStd.html">EarlyStoppStd</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard early stopping criterion.  <a href="classvigra_1_1EarlyStoppStd.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Edgel.html">Edgel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1EntropyCriterion.html">EntropyCriterion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for the FFTW complex types '<code>fftw_complex</code>'.  <a href="classvigra_1_1FFTWComplex.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWConvolvePlan.html">FFTWConvolvePlan</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWImaginaryAccessor.html">FFTWImaginaryAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWMagnitudeAccessor.html">FFTWMagnitudeAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWPhaseAccessor.html">FFTWPhaseAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWRealAccessor.html">FFTWRealAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWSquaredMagnitudeAccessor.html">FFTWSquaredMagnitudeAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FFTWWriteRealAccessor.html">FFTWWriteRealAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FindAverage.html">FindAverage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the average pixel value in an image or ROI.  <a href="classvigra_1_1FindAverage.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FindAverageAndVariance.html">FindAverageAndVariance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the average pixel value and its variance in an image or ROI.  <a href="classvigra_1_1FindAverageAndVariance.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FindBoundingRectangle.html">FindBoundingRectangle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bounding rectangle of an ROI in an image.  <a href="classvigra_1_1FindBoundingRectangle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FindMinMax.html">FindMinMax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum pixel value in an image or ROI.  <a href="classvigra_1_1FindMinMax.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FindROISize.html">FindROISize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of an ROI in an image.  <a href="classvigra_1_1FindROISize.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FindSum.html">FindSum</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sum of the pixel values in an image or ROI.  <a href="classvigra_1_1FindSum.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1FunctorTraits.html">FunctorTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Export associated information for a functor.  <a href="classvigra_1_1FunctorTraits.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GaborFilterFamily.html">GaborFilterFamily</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Family of gabor filters of different scale and direction.  <a href="classvigra_1_1GaborFilterFamily.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GammaFunctor.html">GammaFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform gamma correction of an image.  <a href="classvigra_1_1GammaFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GiniCriterion.html">GiniCriterion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GrayToRGBAccessor.html">GrayToRGBAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GreenAccessor.html">GreenAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1HDF5File.html">HDF5File</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to HDF5 files.  <a href="classvigra_1_1HDF5File.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1HDF5Handle.html">HDF5Handle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for hid_t objects.  <a href="classvigra_1_1HDF5Handle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1HDF5ImportInfo.html">HDF5ImportInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument object for the function <a class="el" href="group__VigraHDF5Impex.html#ga8ccb383ad5d24064f31fab265bc07439" title="Read the data specified by the given vigra::HDF5ImportInfo object and write the into the given &#39;array...">readHDF5()</a>.  <a href="classvigra_1_1HDF5ImportInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1HistogramOptions.html">HistogramOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set histogram options.  <a href="classvigra_1_1HistogramOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ImageArray.html">ImageArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental class template for arrays of equal-sized images.  <a href="classvigra_1_1ImageArray.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ImageExportInfo.html">ImageExportInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument object for the function <a class="el" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3" title="Write an image to a file.">exportImage()</a>.  <a href="classvigra_1_1ImageExportInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ImageImportInfo.html">ImageImportInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument object for the function <a class="el" href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e" title="Read an image from a file.">importImage()</a>.  <a href="classvigra_1_1ImageImportInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ImageIterator.html">ImageIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard 2D random access iterator for images that store the data in a linear array.  <a href="classvigra_1_1ImageIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ImageIteratorBase.html">ImageIteratorBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for 2D random access iterators.  <a href="classvigra_1_1ImageIteratorBase.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ImagePyramid.html">ImagePyramid</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template for logarithmically tapering image pyramids.  <a href="classvigra_1_1ImagePyramid.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1IteratorAdaptor.html">IteratorAdaptor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly create 1-dimensional iterator adapters.  <a href="classvigra_1_1IteratorAdaptor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1IteratorTraits.html">IteratorTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Export associated information for each image iterator.  <a href="structvigra_1_1IteratorTraits.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 1 dimensional convolution kernel.  <a href="classvigra_1_1Kernel1D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel2D.html">Kernel2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 2 dimensional convolution kernel.  <a href="classvigra_1_1Kernel2D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Lab2RGBFunctor.html">Lab2RGBFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert perceptual uniform CIE L*a*b* into linear (raw) RGB.  <a href="classvigra_1_1Lab2RGBFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Lab2RGBPrimeFunctor.html">Lab2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert perceptual uniform CIE L*a*b* into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1Lab2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Lab2XYZFunctor.html">Lab2XYZFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert perceptual uniform CIE L*a*b* into standardized tri-stimulus XYZ.  <a href="classvigra_1_1Lab2XYZFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1LastValueFunctor.html">LastValueFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores and returns the last value it has seen.  <a href="classvigra_1_1LastValueFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1LineIterator.html">LineIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator adapter to iterate along an arbitrary line on the image.  <a href="classvigra_1_1LineIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1LocalMinmaxOptions.html">LocalMinmaxOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for <a class="el" href="group__LocalMinMax.html#ga527dfba5468e97ca7f1d676d34bc7162" title="Find local minima in an image or multi-dimensional array.">localMinima()</a> and <a class="el" href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47" title="Find local maxima in an image or multi-dimensional array.">localMaxima()</a>.  <a href="classvigra_1_1LocalMinmaxOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Luv2RGBFunctor.html">Luv2RGBFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert perceptual uniform CIE L*u*v* into linear (raw) RGB.  <a href="classvigra_1_1Luv2RGBFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Luv2RGBPrimeFunctor.html">Luv2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert perceptual uniform CIE L*u*v* into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1Luv2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Luv2XYZFunctor.html">Luv2XYZFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert perceptual uniform CIE L*u*v* into standardized tri-stimulus XYZ.  <a href="classvigra_1_1Luv2XYZFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MagnitudeFunctor.html">MagnitudeFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MappedBucketQueue.html">MappedBucketQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority queue implemented using bucket sort (STL compatible).  <a href="classvigra_1_1MappedBucketQueue.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1MeshGridAccessor.html">MeshGridAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiArray.html">MultiArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main <code><a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a></code> class containing the memory management.  <a href="classvigra_1_1MultiArray.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiArrayNavigator.html">MultiArrayNavigator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A navigator that provides access to the 1D subranges of an n-dimensional range given by a <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a> and an nD shape.  <a href="classvigra_1_1MultiArrayNavigator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for, and view to, <a class="el" href="classvigra_1_1MultiArray.html">vigra::MultiArray</a>.  <a href="classvigra_1_1MultiArrayView.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiCoordinateIterator.html">MultiCoordinateIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a virtual array where each element contains its coordinate.  <a href="classvigra_1_1MultiCoordinateIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiCoordinateNavigator.html">MultiCoordinateNavigator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A navigator that provides access to the 1D subranges of an n-dimensional range given by an nD shape.  <a href="classvigra_1_1MultiCoordinateNavigator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiImageAccessor2.html">MultiImageAccessor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access two images simultaneously.  <a href="classvigra_1_1MultiImageAccessor2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1MultiIterator.html">MultiIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional hierarchical iterator to be used with <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> if it is not strided.  <a href="classvigra_1_1MultiIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NeighborhoodCirculator.html">NeighborhoodCirculator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Circulator that walks around a given location in a given image.  <a href="classvigra_1_1NeighborhoodCirculator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NeighborOffsetCirculator.html">NeighborOffsetCirculator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Circulator that walks around a given location.  <a href="classvigra_1_1NeighborOffsetCirculator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Node_3_01e__ConstProbNode_01_4.html">Node&lt; e_ConstProbNode &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NodeBase.html">NodeBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NoiseNormalizationOptions.html">NoiseNormalizationOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass options to one of the noise normalization functions.  <a href="classvigra_1_1NoiseNormalizationOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NonlinearLSQOptions.html">NonlinearLSQOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass options to <a class="el" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares()</a>.  <a href="classvigra_1_1NonlinearLSQOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NormalRandomFunctor.html">NormalRandomFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NumpyAnyArray.html">NumpyAnyArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NumpyArray.html">NumpyArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1PLSAOptions.html">PLSAOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Option object for the <a class="el" href="group__Unsupervised__Decomposition.html#ga7aff6f8e1ad85add65d226bcd899e07b">pLSA</a> algorithm.  <a href="classvigra_1_1PLSAOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Point2D.html">Point2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional point or position.  <a href="classvigra_1_1Point2D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Polynomial.html">Polynomial</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1PolynomialView.html">PolynomialView</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1PriorityQueue.html">PriorityQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap-based priority queue compatible to <a class="el" href="classvigra_1_1BucketQueue.html" title="Priority queue implemented using bucket sort.">BucketQueue</a>.  <a href="classvigra_1_1PriorityQueue.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ProblemSpec.html">ProblemSpec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">problem specification class for the random forest.  <a href="classvigra_1_1ProblemSpec.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Processor_3_01ClassificationTag_00_01LabelType_00_01T1_00_01C1_00_01T2_00_01C2_01_4.html">Processor&lt; ClassificationTag, LabelType, T1, C1, T2, C2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Processor_3_01RegressionTag_00_01LabelType_00_01T1_00_01C1_00_01T2_00_01C2_01_4.html">Processor&lt; RegressionTag, LabelType, T1, C1, T2, C2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RandomForest.html">RandomForest</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RandomForestClassCounter.html">RandomForestClassCounter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RandomForestOptions.html">RandomForestOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for the random forest.  <a href="classvigra_1_1RandomForestOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RandomNumberGenerator.html">RandomNumberGenerator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Rational.html">Rational</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Rect2D.html">Rect2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional rectangle.  <a href="classvigra_1_1Rect2D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RedAccessor.html">RedAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ReduceFunctor.html">ReduceFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to reduce the dimensionality of an array.  <a href="classvigra_1_1ReduceFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RestrictedNeighborhoodCirculator.html">RestrictedNeighborhoodCirculator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Circulator that walks around a given location in a given image, using a restricted neighborhood.  <a href="classvigra_1_1RestrictedNeighborhoodCirculator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGB2LabFunctor.html">RGB2LabFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linear (raw) RGB into perceptual uniform CIE L*a*b*.  <a href="classvigra_1_1RGB2LabFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGB2LuvFunctor.html">RGB2LuvFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linear (raw) RGB into perceptual uniform CIE L*u*v*.  <a href="classvigra_1_1RGB2LuvFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGB2RGBPrimeFunctor.html">RGB2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linear (raw) RGB into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1RGB2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGB2sRGBFunctor.html">RGB2sRGBFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linear (raw) RGB into standardized sRGB.  <a href="classvigra_1_1RGB2sRGBFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGB2XYZFunctor.html">RGB2XYZFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linear (raw) RGB into standardized tri-stimulus XYZ.  <a href="classvigra_1_1RGB2XYZFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBAccessor.html">RGBAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBGradientMagnitudeFunctor.html">RGBGradientMagnitudeFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2LabFunctor.html">RGBPrime2LabFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into perceptual uniform CIE L*a*b*.  <a href="classvigra_1_1RGBPrime2LabFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2LuvFunctor.html">RGBPrime2LuvFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into perceptual uniform CIE L*u*v*.  <a href="classvigra_1_1RGBPrime2LuvFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2RGBFunctor.html">RGBPrime2RGBFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into non-linear (raw) RGB.  <a href="classvigra_1_1RGBPrime2RGBFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2XYZFunctor.html">RGBPrime2XYZFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into standardized tri-stimulus XYZ.  <a href="classvigra_1_1RGBPrime2XYZFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2YPrimeCbCrFunctor.html">RGBPrime2YPrimeCbCrFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into Y'CbCr color difference components.  <a href="classvigra_1_1RGBPrime2YPrimeCbCrFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2YPrimeIQFunctor.html">RGBPrime2YPrimeIQFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into Y'IQ components.  <a href="classvigra_1_1RGBPrime2YPrimeIQFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2YPrimePbPrFunctor.html">RGBPrime2YPrimePbPrFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into Y'PbPr color difference components.  <a href="classvigra_1_1RGBPrime2YPrimePbPrFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBPrime2YPrimeUVFunctor.html">RGBPrime2YPrimeUVFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert non-linear (gamma corrected) R'G'B' into Y'UV components.  <a href="classvigra_1_1RGBPrime2YPrimeUVFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBToGrayAccessor.html">RGBToGrayAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a single RGB value.  <a href="classvigra_1_1RGBValue.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1RowIterator.html">RowIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator adapter to linearly access row.  <a href="classvigra_1_1RowIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Sampler.html">Sampler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create random samples from a sequence of indices.  <a href="classvigra_1_1Sampler.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SamplerOptions.html">SamplerOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for the <a class="el" href="classvigra_1_1Sampler.html" title="Create random samples from a sequence of indices.">Sampler</a> class.  <a href="classvigra_1_1SamplerOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SeedOptions.html">SeedOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for generateWatershedSeeds().  <a href="classvigra_1_1SeedOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SeedRgDirectValueFunctor.html">SeedRgDirectValueFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics functor to be used for seeded region growing.  <a href="classvigra_1_1SeedRgDirectValueFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SequenceAccessor.html">SequenceAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for items that are STL compatible sequences.  <a href="classvigra_1_1SequenceAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SIFImportInfo.html">SIFImportInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts image properties from an Andor SIF file header.  <a href="classvigra_1_1SIFImportInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Size2D.html">Size2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional size object.  <a href="classvigra_1_1Size2D.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SlantedEdgeMTFOptions.html">SlantedEdgeMTFOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass options to one of the <a class="el" href="group__SlantedEdgeMTF.html#gaff310bc50ffb7d3a60f545c2b7a7bf37">slantedEdgeMTF()</a> functions.  <a href="classvigra_1_1SlantedEdgeMTFOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1SlicOptions.html">SlicOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for <a class="el" href="group__SeededRegionGrowing.html#ga5561f1ce9b3f7a95b7de67738a0d2447" title="Compute SLIC superpixels in arbitrary dimensions.">slicSuperpixels()</a>.  <a href="structvigra_1_1SlicOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SortSamplesByDimensions.html">SortSamplesByDimensions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Splice.html">Splice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SplineImageView.html">SplineImageView</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a continuous view onto a discrete image using splines.  <a href="classvigra_1_1SplineImageView.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SplineImageView0.html">SplineImageView0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image view for nearest-neighbor interpolation.  <a href="classvigra_1_1SplineImageView0.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SplineImageView1.html">SplineImageView1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image view for bi-linear interpolation.  <a href="classvigra_1_1SplineImageView1.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SplitBase.html">SplitBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1sRGB2RGBFunctor.html">sRGB2RGBFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert standardized sRGB into non-linear (raw) RGB.  <a href="classvigra_1_1sRGB2RGBFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate access to the values an iterator points to.  <a href="classvigra_1_1StandardAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate read access to the values an iterator points to.  <a href="classvigra_1_1StandardConstAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StandardConstValueAccessor.html">StandardConstValueAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate access to the values an iterator points to.  <a href="classvigra_1_1StandardConstValueAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StandardValueAccessor.html">StandardValueAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate access to the values an iterator points to.  <a href="classvigra_1_1StandardValueAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StaticPolynomial.html">StaticPolynomial</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopAfterTree.html">StopAfterTree</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopAfterVoteCount.html">StopAfterVoteCount</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopBase.html">StopBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopIfBinTest.html">StopIfBinTest</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopIfConverging.html">StopIfConverging</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopIfMargin.html">StopIfMargin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StopIfProb.html">StopIfProb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1StridedArrayTag.html">StridedArrayTag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StridedImageIterator.html">StridedImageIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to be used when pixels are to be skipped.  <a href="classvigra_1_1StridedImageIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StridedMultiIterator.html">StridedMultiIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional hierarchical iterator to be used with <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> if it is not strided.  <a href="classvigra_1_1StridedMultiIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1StridedScanOrderIterator.html">StridedScanOrderIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential iterator for <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>.  <a href="classvigra_1_1StridedScanOrderIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Threshold.html">Threshold</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvigra_1_1Threshold.html" title="Threshold an image.">Threshold</a> an image.  <a href="classvigra_1_1Threshold.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ThresholdSplit.html">ThresholdSplit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE. The interface conforms to STL vector, except that there are no functions that change the size of a <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a>.  <a href="classvigra_1_1TinyVector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for fixed size vectors.  <a href="classvigra_1_1TinyVectorBase.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1TinyVectorView.html">TinyVectorView</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for fixed size vectors.  <a href="classvigra_1_1TinyVectorView.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1UniformIntRandomFunctor.html">UniformIntRandomFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1UniformRandomFunctor.html">UniformRandomFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1UnstridedArrayTag.html">UnstridedArrayTag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VectorAccessor.html">VectorAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for items that are STL compatible vectors.  <a href="classvigra_1_1VectorAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VectorComponentAccessor.html">VectorComponentAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for one component of a vector.  <a href="classvigra_1_1VectorComponentAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VectorComponentValueAccessor.html">VectorComponentValueAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for one component of a vector.  <a href="classvigra_1_1VectorComponentValueAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VectorElementAccessor.html">VectorElementAccessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for one component of a vector.  <a href="classvigra_1_1VectorElementAccessor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VectorNormFunctor.html">VectorNormFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor for computing the vector norm.  <a href="classvigra_1_1VectorNormFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VectorNormSqFunctor.html">VectorNormSqFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor for computing the squared vector norm.  <a href="classvigra_1_1VectorNormSqFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VolumeExportInfo.html">VolumeExportInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument object for the function <a class="el" href="group__VolumeImpex.html#gac9a23a3dac8373296367f882493d2d60" title="Function for exporting a 3D volume.">exportVolume()</a>.  <a href="classvigra_1_1VolumeExportInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1VolumeImportInfo.html">VolumeImportInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument object for the function <a class="el" href="group__VolumeImpex.html#gaa8328600a03da4d2849fe33f2a080705" title="Function for importing a 3D volume.">importVolume()</a>.  <a href="classvigra_1_1VolumeImportInfo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1WatershedOptions.html">WatershedOptions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for watershed algorithms.  <a href="classvigra_1_1WatershedOptions.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1WignerMatrix.html">WignerMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computation of Wigner D matrix + rotation functions in SH,VH and R  <a href="classvigra_1_1WignerMatrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1XYZ2LabFunctor.html">XYZ2LabFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert standardized tri-stimulus XYZ into perceptual uniform CIE L*a*b*.  <a href="classvigra_1_1XYZ2LabFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1XYZ2LuvFunctor.html">XYZ2LuvFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert standardized tri-stimulus XYZ into perceptual uniform CIE L*u*v*.  <a href="classvigra_1_1XYZ2LuvFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1XYZ2RGBFunctor.html">XYZ2RGBFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert standardized tri-stimulus XYZ into linear (raw) RGB.  <a href="classvigra_1_1XYZ2RGBFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1XYZ2RGBPrimeFunctor.html">XYZ2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert standardized tri-stimulus XYZ into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1XYZ2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1YPrimeCbCr2RGBPrimeFunctor.html">YPrimeCbCr2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Y'CbCr color difference components into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1YPrimeCbCr2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1YPrimeIQ2RGBPrimeFunctor.html">YPrimeIQ2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Y'IQ color components into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1YPrimeIQ2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1YPrimePbPr2RGBPrimeFunctor.html">YPrimePbPr2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Y'PbPr color difference components into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1YPrimePbPr2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1YPrimeUV2RGBPrimeFunctor.html">YPrimeUV2RGBPrimeFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Y'UV color components into non-linear (gamma corrected) R'G'B'.  <a href="classvigra_1_1YPrimeUV2RGBPrimeFunctor.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">AtImageBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#ga4cc579294aeb92b2639e0f4d8744fc58">AtVolumeBorder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode whether a voxel is near the volume border.  <a href="group__VoxelNeighborhood.html#ga4cc579294aeb92b2639e0f4d8744fc58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">UInt8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaf7e342087f23fa1b4651510fbe2fde90">BImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">UInt8</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga40a63f7a3e96164c1077a11438371ff5">BRGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ImageIterators.html#ga110ba64ad5460bac151be32b748da74b">CoordinateIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate an image where each pixel contains its coordinate.  <a href="group__ImageIterators.html#ga110ba64ad5460bac151be32b748da74b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac81aa87ff25f08b0c7cf06bab1eddd13"></a><!-- doxytag: member="vigra::Diff3D" ref="gac81aa87ff25f08b0c7cf06bab1eddd13" args="" -->
typedef <a class="el" href="classvigra_1_1TinyVector.html">vigra::TinyVector</a>&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#gac81aa87ff25f08b0c7cf06bab1eddd13">Diff3D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">3-dimensional difference vector <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaa506d6092a193e037a1766737c781f7b">DImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaa036c9ad3ae0ffa40b46046343a0e4f2">DRGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a><br class="typebreak"/>
&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gac2804d94abe2f4d5c601f5501f4c294f">DVector2Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a><br class="typebreak"/>
&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga16c2b279961911253eeccc9ec8011ef3">DVector3Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a><br class="typebreak"/>
&lt; double, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaffa1c30fa8eafa80431421c3e82dcd8a">DVector4Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1EightNeighborhood_1_1NeighborCode.html">EightNeighborhood::NeighborCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PixelNeighborhood.html#ga04897760f5b7969c9811a3c258f5981d">EightNeighborCode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1NeighborOffsetCirculator.html">NeighborOffsetCirculator</a><br class="typebreak"/>
&lt; <a class="el" href="group__PixelNeighborhood.html#ga04897760f5b7969c9811a3c258f5981d">EightNeighborCode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PixelNeighborhood.html#gaf3f9a7308ef28b8e19b4eae7eee9c13d">EightNeighborOffsetCirculator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga58cc9e13367834f4c49ad4f55c7df854">FFTWComplexImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; fftw_real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gae8339cb9eea2c7a74b6f7030f5e5c822">FFTWRealImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga1170a9252f2ce52a075238e327ec78f0">FImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1FourNeighborhood_1_1NeighborCode.html">FourNeighborhood::NeighborCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PixelNeighborhood.html#ga58cb45fb133eb7c1d63fd14f65b8320f">FourNeighborCode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1NeighborOffsetCirculator.html">NeighborOffsetCirculator</a><br class="typebreak"/>
&lt; <a class="el" href="group__PixelNeighborhood.html#ga58cb45fb133eb7c1d63fd14f65b8320f">FourNeighborCode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PixelNeighborhood.html#ga3b3e5a92f6776e041fb4687aac2764ec">FourNeighborOffsetCirculator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga0217ae4add549fefbc1fe4a1f6d5136a">FRGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a><br class="typebreak"/>
&lt; float, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga1d1599adb292403c7766a7ffa099323e">FVector2Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a><br class="typebreak"/>
&lt; float, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a><br class="typebreak"/>
&lt; float, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga18d596089442715dcc31683b3eafdb77">FVector4Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RidgeSplit<br class="typebreak"/>
&lt; <a class="el" href="classvigra_1_1BestGiniOfColumn.html">BestGiniOfColumn</a><br class="typebreak"/>
&lt; <a class="el" href="classvigra_1_1GiniCriterion.html">GiniCriterion</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra.html#a4843bfa9895ddff20af7279e053b3629">GiniRidgeSplit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaa8e0f5fa2b9612e2caeed36ff0a6daad">IImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37ecc0a8cab40177174b3a7cf6e07aa3"></a><!-- doxytag: member="vigra::Int16" ref="ga37ecc0a8cab40177174b3a7cf6e07aa3" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 16, detail::SignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga37ecc0a8cab40177174b3a7cf6e07aa3">Int16</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga37ecc0a8cab40177174b3a7cf6e07aa3">Int16</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga885822797a13038e4ca0c074a6d2756a">Int16Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga37ecc0a8cab40177174b3a7cf6e07aa3">Int16</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga736b5f3694d1536694fd357ae8a36a49">Int16RGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92f05c4b6944ec5926841e34f03a9060"></a><!-- doxytag: member="vigra::Int32" ref="ga92f05c4b6944ec5926841e34f03a9060" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 32, detail::SignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga23a490c4345d9f9829e2dcbcff28cb00">Int32Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaeca1ebec69a24d3fb59ab6279bec1598">Int32RGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e7cdf6669ca1e8c3bdabf919a85c6d7"></a><!-- doxytag: member="vigra::Int64" ref="ga4e7cdf6669ca1e8c3bdabf919a85c6d7" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 64, detail::SignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga4e7cdf6669ca1e8c3bdabf919a85c6d7">Int64</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d6b28ce33a32e76311d703bff080069"></a><!-- doxytag: member="vigra::Int8" ref="ga7d6b28ce33a32e76311d703bff080069" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 8, detail::SignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga7d6b28ce33a32e76311d703bff080069">Int8</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga7d6b28ce33a32e76311d703bff080069">Int8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga55871a371db690b76295adbc077a1916">Int8Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga7d6b28ce33a32e76311d703bff080069">Int8</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga6e9edcdc6420b18fe9c7ef0791b17790">Int8RGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga095888e847fba6b9eb4c810ccd2135e3"></a><!-- doxytag: member="vigra::IntBiggest" ref="ga095888e847fba6b9eb4c810ccd2135e3" args="" -->
typedef <br class="typebreak"/>
detail::SelectBiggestIntegerType<br class="typebreak"/>
&lt; detail::SignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga095888e847fba6b9eb4c810ccd2135e3">IntBiggest</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the biggest signed integer type of the system <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga9e9a94902f552dcf9726d60d65d2780d">IRGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1RandomNumberGenerator.html">RandomNumberGenerator</a><br class="typebreak"/>
&lt; detail::RandomState<br class="typebreak"/>
&lt; detail::MT19937 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RandomNumberGeneration.html#ga663aac0cefac046218349844e0567ac4">MersenneTwister</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1Neighborhood3DSix_1_1NeighborCode3D.html">Neighborhood3DSix::NeighborCode3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#gaae23891fb489f969e6deff00b8d76b8a">NeighborCode3DSix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1Neighborhood3DTwentySix_1_1NeighborCode3D.html">Neighborhood3DTwentySix::NeighborCode3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#ga89b6c2a18b23d145b3bc2fe983803f08">NeighborCode3DTwentySix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1RandomNumberGenerator.html">RandomNumberGenerator</a><br class="typebreak"/>
&lt; detail::RandomState<br class="typebreak"/>
&lt; detail::MT19937 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RandomNumberGeneration.html#gac1184f48edbce638f79fcb5d8074984d">RandomMT19937</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1RandomNumberGenerator.html">RandomNumberGenerator</a><br class="typebreak"/>
&lt; detail::RandomState<br class="typebreak"/>
&lt; detail::TT800 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RandomNumberGeneration.html#gaf517ee17df7fcc2c4b299428b4fe0065">RandomTT800</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6799170bf47f30c42a3f164f6ccf8ce"></a><!-- doxytag: member="vigra::Shape1" ref="gaf6799170bf47f30c42a3f164f6ccf8ce" args="" -->
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; 1 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#gaf6799170bf47f30c42a3f164f6ccf8ce">Shape1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shape type for MultiArray&lt;1, T&gt; <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e2ffc107bb0e38f9b1288b647c8ec5b"></a><!-- doxytag: member="vigra::Shape2" ref="ga2e2ffc107bb0e38f9b1288b647c8ec5b" args="" -->
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; 2 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shape type for <a class="el" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, T&gt;</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac70cfe6730d928789a2b3ce1f37ae379"></a><!-- doxytag: member="vigra::Shape3" ref="gac70cfe6730d928789a2b3ce1f37ae379" args="" -->
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; 3 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shape type for MultiArray&lt;3, T&gt; <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32d5611234a997a33e239ff31b773628"></a><!-- doxytag: member="vigra::Shape4" ref="ga32d5611234a997a33e239ff31b773628" args="" -->
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; 4 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga32d5611234a997a33e239ff31b773628">Shape4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shape type for MultiArray&lt;4, T&gt; <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5eb712151ca3fc644d569dee5723f67c"></a><!-- doxytag: member="vigra::Shape5" ref="ga5eb712151ca3fc644d569dee5723f67c" args="" -->
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; 5 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga5eb712151ca3fc644d569dee5723f67c">Shape5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shape type for MultiArray&lt;5, T&gt; <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga37ecc0a8cab40177174b3a7cf6e07aa3">Int16</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga8553d180f7b500092428c0dfef36bdf0">SImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga37ecc0a8cab40177174b3a7cf6e07aa3">Int16</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga95efef10274ee7082b8a687e76fa3671">SRGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1RandomNumberGenerator.html">RandomNumberGenerator</a><br class="typebreak"/>
&lt; detail::RandomState<br class="typebreak"/>
&lt; detail::TT800 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RandomNumberGeneration.html#ga4215c662603bda40aacfaebe937cdce3">TemperedTwister</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7480021744e4059993dccb113a029d51"></a><!-- doxytag: member="vigra::UInt16" ref="ga7480021744e4059993dccb113a029d51" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 16, detail::UnsignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga7480021744e4059993dccb113a029d51">UInt16</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga7480021744e4059993dccb113a029d51">UInt16</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga08a5639ad5cfd1116fb6a54ba6bb5566">UInt16Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga7480021744e4059993dccb113a029d51">UInt16</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga77cdcb7ef56633a347f2a52e07dbb3f7">UInt16RGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad055e2244a667a1a5a5c1ee4397c07f9"></a><!-- doxytag: member="vigra::UInt32" ref="gad055e2244a667a1a5a5c1ee4397c07f9" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 32, detail::UnsignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gaead9b0da438c09d8f98a5970a7b59b20">UInt32Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#gadfd8cf7696f2354d7fd792999d743def">UInt32RGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa897f21c91623c6bf10666606a92408"></a><!-- doxytag: member="vigra::UInt64" ref="gaaa897f21c91623c6bf10666606a92408" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 64, detail::UnsignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#gaaa897f21c91623c6bf10666606a92408">UInt64</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7332da5f8bfdbeecdfd09d4ed602288d"></a><!-- doxytag: member="vigra::UInt8" ref="ga7332da5f8bfdbeecdfd09d4ed602288d" args="" -->
typedef <br class="typebreak"/>
detail::SelectIntegerType<br class="typebreak"/>
&lt; 8, detail::UnsignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">UInt8</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned int <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">UInt8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga1b553cb653e4e5b3d0daf4c925a06dfd">UInt8Image</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1BasicImage.html">BasicImage</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a><br class="typebreak"/>
&lt; <a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">UInt8</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StandardImageTypes.html#ga29df47ed6b0437d0a7fc6b05c7a242e7">UInt8RGBImage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga777bb6d03e37c030dd58d64e781cdff6"></a><!-- doxytag: member="vigra::UIntBiggest" ref="ga777bb6d03e37c030dd58d64e781cdff6" args="" -->
typedef <br class="typebreak"/>
detail::SelectBiggestIntegerType<br class="typebreak"/>
&lt; detail::UnsignedIntTypes &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FixedSizeInt.html#ga777bb6d03e37c030dd58d64e781cdff6">UIntBiggest</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the biggest unsigned integer type of the system <br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">AtImageBorder</a> { <br/>
&#160;&#160;<a class="el" href="group__PixelNeighborhood.html#gga745167948a746ad025601aff865383efadd0b3930f6439e66289c9faf2dfc3d8a">NotAtBorder</a> =  0, 
<a class="el" href="group__PixelNeighborhood.html#gga745167948a746ad025601aff865383efa134b66be3b1cd3774594b53e45804429">RightBorder</a> =  1, 
<a class="el" href="group__PixelNeighborhood.html#gga745167948a746ad025601aff865383efa34316511ca3c7190e9ae57111dc6d485">LeftBorder</a> =  2, 
<a class="el" href="group__PixelNeighborhood.html#gga745167948a746ad025601aff865383efa3967342e24cebf96b6de2d2ffedd0894">TopBorder</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="group__PixelNeighborhood.html#gga745167948a746ad025601aff865383efaeb17e250de21fa5677f2b5ed49767e13">BottomBorder</a> =  8, 
<a class="el" href="group__PixelNeighborhood.html#gga745167948a746ad025601aff865383efadeb1b7c0231daf2ff4fb325be1272053">FrontBorder</a> =  16
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode whether a point is near the image border.  <a href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga9d75de3edc093f215c3f4d42a966167a">NeighborhoodType</a> { <a class="el" href="group__MultiIteratorGroup.html#gga9d75de3edc093f215c3f4d42a966167aaf5b533c53c0491107c6c9b890b635372">DirectNeighborhood</a> = 0, 
<a class="el" href="group__MultiIteratorGroup.html#gga9d75de3edc093f215c3f4d42a966167aabee0bb96274e332d294c1aa2893f6cac">IndirectNeighborhood</a> = 1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the neighborhood system in a dimension-independent way.  <a href="group__MultiIteratorGroup.html#ga9d75de3edc093f215c3f4d42a966167a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MachineLearning.html#ga362f1d354d5330231ea89d7551b17037">Problem_t</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">problem types <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra.html#ab929a955ebe9b33e718a13a08020700a">RF_OptionTag</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga01b5439c31bc7008fe4b8b280dd12bf2">SRGType</a> </td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae9ca079686cdebf4fbe92a666b72598a"></a><!-- doxytag: member="vigra::abs" ref="gae9ca079686cdebf4fbe92a666b72598a" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gae9ca079686cdebf4fbe92a666b72598a">abs</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabf091b1364939ab599de2c976da41760"></a><!-- doxytag: member="vigra::abs" ref="gabf091b1364939ab599de2c976da41760" args="(Quaternion&lt; Type &gt; const &amp;q)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gabf091b1364939ab599de2c976da41760">abs</a> (<a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; const &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">norm <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaba00245aebd1c55103070dcd45a77483"></a><!-- doxytag: member="vigra::abs" ref="gaba00245aebd1c55103070dcd45a77483" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gaba00245aebd1c55103070dcd45a77483">abs</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7edfb83a987112c5626583965c8c51d5"></a><!-- doxytag: member="vigra::abs" ref="ga7edfb83a987112c5626583965c8c51d5" args="(RGBValue&lt; T, RIDX, GIDX, BIDX &gt; const &amp;v)" -->
template&lt;class T , unsigned int RIDX, unsigned int GIDX, unsigned int BIDX&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; T, RIDX, GIDX, BIDX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga7edfb83a987112c5626583965c8c51d5">abs</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; T, RIDX, GIDX, BIDX &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise absolute value <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6f4ef274842b6153923f02a6cd264576"></a><!-- doxytag: member="vigra::abs" ref="ga6f4ef274842b6153923f02a6cd264576" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576">abs</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value (= magnitude) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaad996c0c0cd7877767d3e72097976c5b"></a><!-- doxytag: member="vigra::abs" ref="gaad996c0c0cd7877767d3e72097976c5b" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, <br class="typebreak"/>
OverflowHandling &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gaad996c0c0cd7877767d3e72097976c5b">abs</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga739deb1c35a7b178dfd7b7e2402dff08"></a><!-- doxytag: member="vigra::abs" ref="ga739deb1c35a7b178dfd7b7e2402dff08" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;v)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga739deb1c35a7b178dfd7b7e2402dff08">abs</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise absolute value <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga95690fd14be4c66dbf3d3afbc852b15c"></a><!-- doxytag: member="vigra::add" ref="ga95690fd14be4c66dbf3d3afbc852b15c" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r, FixedPoint&lt; IntBits3, FracBits3 &gt; &amp;result)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2, unsigned IntBits3, unsigned FracBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga95690fd14be4c66dbf3d3afbc852b15c">add</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits3, FracBits3 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6c46b7a1b6bcad18a2a818143c8de239"></a><!-- doxytag: member="vigra::add" ref="ga6c46b7a1b6bcad18a2a818143c8de239" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r, FixedPoint16&lt; IntBits3, OverflowHandling &gt; &amp;result)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2, int IntBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, <br class="typebreak"/>
OverflowHandling &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga6c46b7a1b6bcad18a2a818143c8de239">add</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, OverflowHandling &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SrcIterator , class DestIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Registration.html#ga332c8027c4b52ab27d85f3eaac4639fa">affineMatrix2DFromCorrespondingPoints</a> (SrcIterator s, SrcIterator send, DestIterator d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix that maps corresponding points onto each other.  <a href="group__Registration.html#ga332c8027c4b52ab27d85f3eaac4639fa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga8b1b4684a0bb3572df7b580f05ecd07c">affineWarpImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Warp an image according to an affine transformation.  <a href="group__GeometricTransformations.html#ga8b1b4684a0bb3572df7b580f05ecd07c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GaborFilter.html#ga13db00f23091ea0efcb948c9727cc419">angularGaborSigma</a> (int directionCount, double centerFrequency)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sensible angular sigma for given parameters.  <a href="group__GaborFilter.html#ga13db00f23091ea0efcb948c9727cc419"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NonLinearDiffusion.html#gab03d88e6a6ccf3dd060534d58b8db5b8">anisotropicTotalVariationFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Anisotropic Total Variation Regularization.  <a href="group__NonLinearDiffusion.html#gab03d88e6a6ccf3dd060534d58b8db5b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#gad51931cfe91ece316e28ff9d7ff28377">applyFourierFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a filter (defined in the frequency domain) to an image.  <a href="group__FourierTransform.html#gad51931cfe91ece316e28ff9d7ff28377"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#ga615ea159a1ac4328600ee44cbaa9a343">applyFourierFilterFamily</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an array of filters (defined in the frequency domain) to an image.  <a href="group__FourierTransform.html#ga615ea159a1ac4328600ee44cbaa9a343"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class IndexIterator , class InIterator , class OutIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10">applyPermutation</a> (IndexIterator index_first, IndexIterator index_last, InIterator in, OutIterator out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array according to the given index permutation.  <a href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadde71f2f7d25b483924dedacc36b2b2d"></a><!-- doxytag: member="vigra::arg" ref="gadde71f2f7d25b483924dedacc36b2b2d" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d">arg</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pahse <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf658d43400902a049a289c4e5ded84d9">argMax</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum element in a sequence.  <a href="group__MathFunctions.html#gaf658d43400902a049a289c4e5ded84d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator , class UnaryFunctor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gafe67abfb62abdfc09a8e1e47a87485ea">argMaxIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum element in a sequence conforming to a condition.  <a href="group__MathFunctions.html#gafe67abfb62abdfc09a8e1e47a87485ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad84c74edbd392ac2035df2a6d583fc05">argMin</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum element in a sequence.  <a href="group__MathFunctions.html#gad84c74edbd392ac2035df2a6d583fc05"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator , class UnaryFunctor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga45d791e8c9cac48509aa4e1557ecf676">argMinIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum element in a sequence conforming to a condition.  <a href="group__MathFunctions.html#ga45d791e8c9cac48509aa4e1557ecf676"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a> (T t)(...)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae83e1ae2e3dae6dc462c69a7c8175fc5"></a><!-- doxytag: member="vigra::atan2" ref="gae83e1ae2e3dae6dc462c69a7c8175fc5" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; y, FixedPoint16&lt; IntBits, OverflowHandling &gt; x)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; 2, OverflowHandling &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gae83e1ae2e3dae6dc462c69a7c8175fc5">atan2</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; y, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Arctangent. Accuracy better than 1/3 degree (9 significant bits). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CornerDetection.html#ga0c750a26d679a2ea13fd697dac73a123">beaudetCornerDetector</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find corners in an image (4).  <a href="group__CornerDetection.html#ga0c750a26d679a2ea13fd697dac73a123"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga372f1a443c561d454cf46a517f0425e0">beautifyCrackEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Beautify crack edge image for visualization.  <a href="group__EdgeDetection.html#ga372f1a443c561d454cf46a517f0425e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga9cf8d64d518f2d493bee81d886906cdf">besselJ</a> (int n, double x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of the first kind.  <a href="group__MathFunctions.html#ga9cf8d64d518f2d493bee81d886906cdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga84d85515af4527b6922f14a853fe40d3">besselY</a> (int n, double x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of the second kind.  <a href="group__MathFunctions.html#ga84d85515af4527b6922f14a853fe40d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gab4ee0f19130a109119cc9cbc594ed1b7">boundaryTensor</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the boundary tensor for a scalar valued image.  <a href="group__TensorImaging.html#gab4ee0f19130a109119cc9cbc594ed1b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#ga09752d76329cf689fcc427c8c6b5be96">boundaryTensor1</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary tensor variant.  <a href="group__TensorImaging.html#ga09752d76329cf689fcc427c8c6b5be96"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga729ddcc1323a9c0fd31c52812f08adb6">cannyEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and mark edges in an edge image using Canny's algorithm.  <a href="group__EdgeDetection.html#ga729ddcc1323a9c0fd31c52812f08adb6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#gad24417dac847a49d349da6092d86fa7f">cannyEdgeImageFromGradWithThinning</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and mark edges in an edge image using Canny's algorithm.  <a href="group__EdgeDetection.html#gad24417dac847a49d349da6092d86fa7f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga9aa609d12e327e0d633047b78d61c84e">cannyEdgeImageWithThinning</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and mark edges in an edge image using Canny's algorithm.  <a href="group__EdgeDetection.html#ga9aa609d12e327e0d633047b78d61c84e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#gaf2233c5ec0e42a15134feda453f6fca5">cannyEdgelList</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of Canny's edge detector.  <a href="group__EdgeDetection.html#gaf2233c5ec0e42a15134feda453f6fca5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga04e860482291f33d59c0992b479041e6">cannyEdgelList3x3</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improved implementation of Canny's edge detector.  <a href="group__EdgeDetection.html#ga04e860482291f33d59c0992b479041e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga23436177c86663716d99e7dd43b6620f">cannyEdgelList3x3Threshold</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improved implementation of Canny's edge detector with thresholding.  <a href="group__EdgeDetection.html#ga23436177c86663716d99e7dd43b6620f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga56f43f065071a98fa8785867a70e2a67">cannyEdgelListThreshold</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Canny's edge detector with thresholding.  <a href="group__EdgeDetection.html#ga56f43f065071a98fa8785867a70e2a67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9c3bc30f7e0a5dea1bdcb60d3dee04c5"></a><!-- doxytag: member="vigra::ceil" ref="ga9c3bc30f7e0a5dea1bdcb60d3dee04c5" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga9c3bc30f7e0a5dea1bdcb60d3dee04c5">ceil</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">smallest integer not smaller than <code>r</code> <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga14fe7b9ffa21e091c6ff4ede68717c30"></a><!-- doxytag: member="vigra::ceil" ref="ga14fe7b9ffa21e091c6ff4ede68717c30" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga14fe7b9ffa21e091c6ff4ede68717c30">ceil</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding up. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , unsigned int RIDX, unsigned int GIDX, unsigned int BIDX&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gaa1736289df97804e23bcb42dcc077d5a">ceil</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt; const &amp;r)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3de623a9fcd9aa5b8515d2e602ad3441"></a><!-- doxytag: member="vigra::ceil" ref="ga3de623a9fcd9aa5b8515d2e602ad3441" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga3de623a9fcd9aa5b8515d2e602ad3441">ceil</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding up. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga4e0bd0391f6a2d5e9347c2daa7a8d05e">ceil</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2</a> (<a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to the nearest power of 2.  <a href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga482d2e82f374a8758cd516d19f4c3424">checksum</a> (const char *data, unsigned int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CRC-32 checksum of a byte array.  <a href="group__MathFunctions.html#ga482d2e82f374a8758cd516d19f4c3424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0f6a2804ceaf785495472fb9bf2dd5bc">chi2</a> (unsigned int degreesOfFreedom, double <a class="el" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d">arg</a>, double accuracy=1e-7)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Chi square distribution.  <a href="group__MathFunctions.html#ga0f6a2804ceaf785495472fb9bf2dd5bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaa94c7af27b4aecda8a764beb89dbc2a6">chi2CDF</a> (unsigned int degreesOfFreedom, double <a class="el" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d">arg</a>, double accuracy=1e-7)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative chi square distribution.  <a href="group__MathFunctions.html#gaa94c7af27b4aecda8a764beb89dbc2a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7">closeAtTolerance</a> (T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance based floating-point comparison.  <a href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#gab9c56ad0d2769ad7ddca5708e7adfee5">closeGapsInCrackEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close one-pixel wide gaps in a cell grid edge image.  <a href="group__EdgeDetection.html#gab9c56ad0d2769ad7ddca5708e7adfee5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CombineAlgo.html#ga9bbc3b2f05707a6d4734f5f63c3884e2">combineThreeImages</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine three source images into destination image.  <a href="group__CombineAlgo.html#ga9bbc3b2f05707a6d4734f5f63c3884e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga55f661c630e9ddca7cfd416de4a8cb3c">combineThreeMultiArrays</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine three multi-dimensional arrays into one using a ternary function or functor.  <a href="group__MultiPointoperators.html#ga55f661c630e9ddca7cfd416de4a8cb3c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23">combineTwoImages</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two source images into destination image.  <a href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CombineAlgo.html#ga1a58f278634940f993888ef804340017">combineTwoImagesIf</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine ROI of two source images into destination image.  <a href="group__CombineAlgo.html#ga1a58f278634940f993888ef804340017"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga14152b4ce55fee06cba896303ef0a539">combineTwoMultiArrays</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two multi-dimensional arrays into one using a binary function or functor.  <a href="group__MultiPointoperators.html#ga14152b4ce55fee06cba896303ef0a539"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga46be68464b972df67e1396fd3a398de7">concatenateChecksum</a> (<a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a> <a class="el" href="group__MathFunctions.html#ga482d2e82f374a8758cd516d19f4c3424">checksum</a>, const char *data, unsigned int size)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3f67ca45fd95f03638346b605c26b755"></a><!-- doxytag: member="vigra::conj" ref="ga3f67ca45fd95f03638346b605c26b755" args="(Quaternion&lt; ValueType &gt; const &amp;q)" -->
template&lt;class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga3f67ca45fd95f03638346b605c26b755">conj</a> (<a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; ValueType &gt; const &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create conjugate quaternion. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae7a58f4547192b979f7f8cd565bdf45b"></a><!-- doxytag: member="vigra::conj" ref="gae7a58f4547192b979f7f8cd565bdf45b" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gae7a58f4547192b979f7f8cd565bdf45b">conj</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">complex conjugate <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class PointArray1 , class PointArray2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8ba489a131e75016f32095b106659d22">convexHull</a> (const PointArray1 &amp;points, PointArray2 &amp;convex_hull)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull of a 2D polygon.  <a href="group__MathFunctions.html#ga8ba489a131e75016f32095b106659d22"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve an array with a kernel by means of the Fourier transform.  <a href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">convolveFFTComplex</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array by means of the Fourier transform.  <a href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">convolveFFTComplexMany</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform.  <a href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">convolveFFTMany</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.  <a href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve an image with the given kernel(s).  <a href="group__CommonConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#gaa1698618c44d0d5d5e0559212519b562">convolveImageWithMask</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a mask image.  <a href="group__CommonConvolutionFilters.html#gaa1698618c44d0d5d5e0559212519b562"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeparableConvolution.html#ga68b1efe52c497cfbaece1452515b6307">convolveLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1-dimensional convolution of the source signal using the given kernel.  <a href="group__SeparableConvolution.html#ga68b1efe52c497cfbaece1452515b6307"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution along a single dimension of a multi-dimensional arrays.  <a href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CopyAlgo.html#ga2624abed63bc46afcf7d2e482c156023">copyImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source image into destination image.  <a href="group__CopyAlgo.html#ga2624abed63bc46afcf7d2e482c156023"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CopyAlgo.html#ga6ff922dacba428e319cb0ae2ebbfedd0">copyImageIf</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source ROI into destination image.  <a href="group__CopyAlgo.html#ga6ff922dacba428e319cb0ae2ebbfedd0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga98ce45d5407d2db807cf88ecc9494555">copyMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a multi-dimensional array.  <a href="group__MultiPointoperators.html#ga98ce45d5407d2db807cf88ecc9494555"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CornerDetection.html#ga8ac6885918f92043c688fca04401248f">cornerResponseFunction</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find corners in an image (1).  <a href="group__CornerDetection.html#ga8ac6885918f92043c688fca04401248f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7ce9a27a70c7341a29c4637cddf26f8c">cos_pi</a> (REAL x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cos(pi*x).  <a href="group__MathFunctions.html#ga7ce9a27a70c7341a29c4637cddf26f8c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a>&lt; N &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#gaa4bf73ceca2081acb1353b88ced1388e">createCoupledIterator</a> (<a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; <a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>, N &gt; const &amp;shape)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, class T1 , class S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a>&lt; N1, T1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga88d0ea7e5931c797fde6764450950e2c">createCoupledIterator</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N1, T1, S1 &gt; const &amp;m1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, class T1 , class S1 , unsigned int N2, class T2 , class S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a>&lt; N1, T1, <br class="typebreak"/>
T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga673773de956e6237989e56249620abf2">createCoupledIterator</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N1, T1, S1 &gt; const &amp;m1, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N2, T2, S2 &gt; const &amp;m2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, class T1 , class S1 , unsigned int N2, class T2 , class S2 , unsigned int N3, class T3 , class S3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a>&lt; N1, T1, <br class="typebreak"/>
T2, T3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga74d497d5c64e618f8014b37a492b3a9a">createCoupledIterator</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N1, T1, S1 &gt; const &amp;m1, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N2, T2, S2 &gt; const &amp;m2, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N3, T3, S3 &gt; const &amp;m3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, class T1 , class S1 , unsigned int N2, class T2 , class S2 , unsigned int N3, class T3 , class S3 , unsigned int N4, class T4 , class S4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a>&lt; N1, T1, <br class="typebreak"/>
T2, T3, T4 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga42c4e24b81a5883ad6a8178e78fab46b">createCoupledIterator</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N1, T1, S1 &gt; const &amp;m1, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N2, T2, S2 &gt; const &amp;m2, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N3, T3, S3 &gt; const &amp;m3, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N4, T4, S4 &gt; const &amp;m4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, class T1 , class S1 , unsigned int N2, class T2 , class S2 , unsigned int N3, class T3 , class S3 , unsigned int N4, class T4 , class S4 , unsigned int N5, class T5 , class S5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvigra_1_1CoupledIteratorType.html">CoupledIteratorType</a>&lt; N1, T1, <br class="typebreak"/>
T2, T3, T4, T5 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga52a5371a58599f99f74646f8045ce5e3">createCoupledIterator</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N1, T1, S1 &gt; const &amp;m1, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N2, T2, S2 &gt; const &amp;m2, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N3, T3, S3 &gt; const &amp;m3, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N4, T4, S4 &gt; const &amp;m4, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N5, T5, S5 &gt; const &amp;m5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GaborFilter.html#ga01f6460f7a897e70c5e1470e5d48e3c4">createGaborFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a gabor filter in frequency space.  <a href="group__GaborFilter.html#ga01f6460f7a897e70c5e1470e5d48e3c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TIFFImpex.html#ga3eaac7e2a4200b63f2dcb31034a98f39">createRGBTiffImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3-band TiffImage from the given RGB image.  <a href="group__TIFFImpex.html#ga3eaac7e2a4200b63f2dcb31034a98f39"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TIFFImpex.html#ga5304acecf03804f7c0864fc5fe1e87bf">createScalarTiffImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a single-band TiffImage from the given scalar image.  <a href="group__TIFFImpex.html#ga5304acecf03804f7c0864fc5fe1e87bf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TIFFImpex.html#gae4dcba2a7ce002811d26440a6985a6f2">createTiffImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TiffImage from the given iterator range.  <a href="group__TIFFImpex.html#gae4dcba2a7ce002811d26440a6985a6f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga63c949faa1c424c07a7c3907f061b5f5"></a><!-- doxytag: member="vigra::cross" ref="ga63c949faa1c424c07a7c3907f061b5f5" args="(RGBValue&lt; V1, R, G, B &gt; const &amp;r1, RGBValue&lt; V2, R, G, B &gt; const &amp;r2)" -->
template&lt;class V1 , unsigned int R, unsigned int G, unsigned int B, class V2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, <br class="typebreak"/>
G, B &gt;, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga63c949faa1c424c07a7c3907f061b5f5">cross</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, G, B &gt; const &amp;r1, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cross product <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga170cec3becfca7bd00faa56db0e811f8"></a><!-- doxytag: member="vigra::cross" ref="ga170cec3becfca7bd00faa56db0e811f8" args="(TinyVectorBase&lt; V1, 3, D1, D2 &gt; const &amp;r1, TinyVectorBase&lt; V2, 3, D3, D4 &gt; const &amp;r2)" -->
template&lt;class V1 , class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; typename <br class="typebreak"/>
PromoteTraits&lt; V1, V2 &gt;<br class="typebreak"/>
::Promote, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga170cec3becfca7bd00faa56db0e811f8">cross</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, 3, D1, D2 &gt; const &amp;r1, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, 3, D3, D4 &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cross product <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad3c7573bdce62caf4167e7c797e5b0fc"></a><!-- doxytag: member="vigra::cumprod" ref="gad3c7573bdce62caf4167e7c797e5b0fc" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; typename <br class="typebreak"/>
NumericTraits&lt; V &gt;::Promote, <br class="typebreak"/>
SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gad3c7573bdce62caf4167e7c797e5b0fc">cumprod</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cumulative product of the vector's elements <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga66c60fc6c941a7461281dae96e15a378"></a><!-- doxytag: member="vigra::cumsum" ref="ga66c60fc6c941a7461281dae96e15a378" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; typename <br class="typebreak"/>
NumericTraits&lt; V &gt;::Promote, <br class="typebreak"/>
SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga66c60fc6c941a7461281dae96e15a378">cumsum</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cumulative sum of the vector's elements <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga52ce27e210e918ed15281dff03ee712e">differenceOfExponentialCrackEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector.  <a href="group__EdgeDetection.html#ga52ce27e210e918ed15281dff03ee712e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga82468161d9b270516e72ab0bc76f63b7">differenceOfExponentialEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector.  <a href="group__EdgeDetection.html#ga82468161d9b270516e72ab0bc76f63b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#gaa6b2b4e1d0fab80e25aa7bb349ac3da3">discDilation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply dilation (maximum) filter with disc of given radius to image.  <a href="group__Morphology.html#gaa6b2b4e1d0fab80e25aa7bb349ac3da3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#gab630e6ea20d029d5dd5823f276367d29">discDilationWithMask</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply dilation (maximum) filter with disc of given radius to image using a mask.  <a href="group__Morphology.html#gab630e6ea20d029d5dd5823f276367d29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#gaeaa85e48818f2026b07cbac969cc2390">discErosion</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply erosion (minimum) filter with disc of given radius to image.  <a href="group__Morphology.html#gaeaa85e48818f2026b07cbac969cc2390"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#ga6eb67a2fe627ccc4abc757c7aafffe2e">discErosionWithMask</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply erosion (minimum) filter with disc of given radius to image using a mask.  <a href="group__Morphology.html#ga6eb67a2fe627ccc4abc757c7aafffe2e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#ga6f7f27916f6f43016aa268e8730be59b">discMedian</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply median filter with disc of given radius to image.  <a href="group__Morphology.html#ga6f7f27916f6f43016aa268e8730be59b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#ga64d2e88ce00c13337e446e3c24be54a6">discMedianWithMask</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply median filter with disc of given radius to image using a mask.  <a href="group__Morphology.html#ga64d2e88ce00c13337e446e3c24be54a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rank order filter with disc structuring function to the image.  <a href="group__Morphology.html#gac7b008c2289213251fe917f8855f9667"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Morphology.html#gad40782f8126b8b9b4a009fe8d8ddaaa3">discRankOrderFilterWithMask</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rank order filter with disc structuring function to the image using a mask.  <a href="group__Morphology.html#gad40782f8126b8b9b4a009fe8d8ddaaa3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DistanceTransform.html#gad481d272471bfa808196959dffca524b">distanceTransform</a> (...)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac71b069a80f6decdb6fad1cfd508f5f8"></a><!-- doxytag: member="vigra::div" ref="gac71b069a80f6decdb6fad1cfd508f5f8" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r, FixedPoint16&lt; IntBits3, OverflowHandling &gt; &amp;result)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2, int IntBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, <br class="typebreak"/>
OverflowHandling &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8">div</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, OverflowHandling &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">division with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7f6e870704c4feed9cb10b4e6a88f537"></a><!-- doxytag: member="vigra::div" ref="ga7f6e870704c4feed9cb10b4e6a88f537" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l, V v)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga7f6e870704c4feed9cb10b4e6a88f537">div</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l, V v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise scalar division without type promotion <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaabe9d910ba7a54cbf606254a81e409e6"></a><!-- doxytag: member="vigra::dot" ref="gaabe9d910ba7a54cbf606254a81e409e6" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; const &amp;r1, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r2)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; V1, V2 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gaabe9d910ba7a54cbf606254a81e409e6">dot</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; const &amp;r1, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5daa9ccf920ad84e68f5eb0d2df5be53"></a><!-- doxytag: member="vigra::dot" ref="ga5daa9ccf920ad84e68f5eb0d2df5be53" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; V1, V2 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga5daa9ccf920ad84e68f5eb0d2df5be53">dot</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga876ce07d607656544570073d92bf14bf"></a><!-- doxytag: member="vigra::dual_frac" ref="ga876ce07d607656544570073d92bf14bf" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; 0, FracBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga876ce07d607656544570073d92bf14bf">dual_frac</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dual fractional part: <code>1 - frac(v)</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac21c347588d5301b43d42cce346995e8"></a><!-- doxytag: member="vigra::dual_frac" ref="gac21c347588d5301b43d42cce346995e8" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, <br class="typebreak"/>
OverflowHandling &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gac21c347588d5301b43d42cce346995e8">dual_frac</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dual fractional part. (1 - frac(v)) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga29d6193bd95ec54c5f25dd0470f58215">ellipticIntegralE</a> (double x, double k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The incomplete elliptic integral of the second kind.  <a href="group__MathFunctions.html#ga29d6193bd95ec54c5f25dd0470f58215"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7e909bd1d07e846d5d3ba78eaed7c520">ellipticIntegralF</a> (double x, double k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The incomplete elliptic integral of the first kind.  <a href="group__MathFunctions.html#ga7e909bd1d07e846d5d3ba78eaed7c520"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Registration.html#ga1925c4f671a63939ef8b0c0ad44c646c">estimateAffineTransform</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the optical flow between two images according to an affine transform model (e.g. translation, rotation, non-uniform scaling, and shearing).  <a href="group__Registration.html#ga1925c4f671a63939ef8b0c0ad44c646c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Registration.html#gab62f13083f74c790bce36b00d5d9bf4e">estimateSimilarityTransform</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the optical flow between two images according to a similarity transform model (e.g. translation, rotation, and uniform scaling).  <a href="group__Registration.html#gab62f13083f74c790bce36b00d5d9bf4e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Registration.html#ga30117911d58b1b31ac2249709b21edb4">estimateTranslation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the optical flow between two images according to a translation model.  <a href="group__Registration.html#ga30117911d58b1b31ac2249709b21edb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115">even</a> (int t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an integer is even.  <a href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3">exportImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an image to a file.  <a href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#ga49740e4e75cbfa7ffc12b4a149281a06">exportImageAlpha</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the image and its alpha channel to a file.  <a href="group__VigraImpex.html#ga49740e4e75cbfa7ffc12b4a149281a06"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VolumeImpex.html#gac9a23a3dac8373296367f882493d2d60">exportVolume</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for exporting a 3D volume.  <a href="group__VolumeImpex.html#gac9a23a3dac8373296367f882493d2d60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#gacf065fa5d3b1f0e8b2b6eedc742e117a">extendedLocalMaxima</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local maximal regions in an array.  <a href="group__LocalMinMax.html#gacf065fa5d3b1f0e8b2b6eedc742e117a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#ga0db91012c965e9950ae09ab25ec2c786">extendedLocalMaxima3D</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local maximal regions in 3D multi array.  <a href="group__LocalMinMax.html#ga0db91012c965e9950ae09ab25ec2c786"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#ga5d85854a266cf6f5d4bff98b34e123fb">extendedLocalMinima</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local minimal regions (plateaus) in an array.  <a href="group__LocalMinMax.html#ga5d85854a266cf6f5d4bff98b34e123fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#gad1280b5f8335ebdadbb45a1b8cf8e8f5">extendedLocalMinima3D</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local minimal regions in a volume.  <a href="group__LocalMinMax.html#gad1280b5f8335ebdadbb45a1b8cf8e8f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8">fftwCorrespondingShapeR2C</a> (<a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; T, N &gt; shape)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find frequency domain shape for a R2C Fourier transform.  <a href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">TARGET&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga4ab4a9ac3f89439366bbbcb41e1aed78">fixed_point_cast</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">TARGET&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gac12bb448fd83be21e6e529cd1994abb3">fixed_point_cast</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga00dbbcef01fb68816089d85e6332dbe5"></a><!-- doxytag: member="vigra::floor" ref="ga00dbbcef01fb68816089d85e6332dbe5" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga00dbbcef01fb68816089d85e6332dbe5">floor</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">largest integer not larger than <code>r</code> <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf8fe85520fc0bc2d77ec8e6cf26f3c5d"></a><!-- doxytag: member="vigra::floor" ref="gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d">floor</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding down. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , unsigned int RIDX, unsigned int GIDX, unsigned int BIDX&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gad41a8c5b0474ab55a79ab3e44a3db7ae">floor</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt; const &amp;r)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf9acd2d5db732d3d15b3d30e7b70671d"></a><!-- doxytag: member="vigra::floor" ref="gaf9acd2d5db732d3d15b3d30e7b70671d" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gaf9acd2d5db732d3d15b3d30e7b70671d">floor</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding down. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gae9236ef4cc1620991693a0ed032042f0">floor</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329">floorPower2</a> (<a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Round down to the nearest power of 2.  <a href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CornerDetection.html#gab70e0f0cec3312e4b0df415c6b2a733b">foerstnerCornerDetector</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find corners in an image (2).  <a href="group__CornerDetection.html#gab70e0f0cec3312e4b0df415c6b2a733b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#gadd9dce5cef45cda228466002d00a0666">fourierTransform</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute forward and inverse Fourier transforms.  <a href="group__FourierTransform.html#gadd9dce5cef45cda228466002d00a0666"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#ga478712099cf479694c81ccc5918aca73">fourierTransformInverse</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse Fourier transforms.  <a href="group__FourierTransform.html#ga478712099cf479694c81ccc5918aca73"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#ga99f1f190a25ea2dbdc78c4e18c25699d">fourierTransformReal</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Real Fourier transforms for even and odd boundary conditions (aka. cosine and sine transforms).  <a href="group__FourierTransform.html#ga99f1f190a25ea2dbdc78c4e18c25699d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadc20c2a584e4c99a7333bbfac71fe202"></a><!-- doxytag: member="vigra::frac" ref="gadc20c2a584e4c99a7333bbfac71fe202" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; 0, FracBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gadc20c2a584e4c99a7333bbfac71fe202">frac</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fractional part. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga51bbe37b56a46473c8041924e52b9826"></a><!-- doxytag: member="vigra::frac" ref="ga51bbe37b56a46473c8041924e52b9826" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, <br class="typebreak"/>
OverflowHandling &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga51bbe37b56a46473c8041924e52b9826">frac</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fractional part. (difference between v and its floor) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976">gamma</a> (double x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The gamma function.  <a href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient vector by means of a 1st derivatives of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter.  <a href="group__CommonConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient magnitude by means of a 1st derivatives of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter.  <a href="group__CommonConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays.  <a href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sharpening function with gaussian filter.  <a href="group__CommonConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> convolution.  <a href="group__CommonConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays.  <a href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga5825d3973169fc0c90404849a5906697">gcd</a> (IntType n, IntType m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga704fac970031b32d42d5cc5ea5980751">generateSlicSeeds</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate seeds for SLIC superpixel computation in arbitrary dimensions.  <a href="group__SeededRegionGrowing.html#ga704fac970031b32d42d5cc5ea5980751"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga3fdf604e9584a7bdd39e4ee6bd620cbc">generateWatershedSeeds</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate seeds for watershed computation and seeded region growing.  <a href="group__SeededRegionGrowing.html#ga3fdf604e9584a7bdd39e4ee6bd620cbc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int TARGET_INDEX, class Handle &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CoupledHandleCast<br class="typebreak"/>
&lt; TARGET_INDEX, Handle &gt;<br class="typebreak"/>
::type::reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga485f0889b41388545ac47dd86b2cceca">get</a> (Handle &amp;handle)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int TARGET_INDEX, class Handle &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CoupledHandleCast<br class="typebreak"/>
&lt; TARGET_INDEX, Handle &gt;<br class="typebreak"/>
::type::const_reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiIteratorGroup.html#ga3c482055004a2f66bd08a7ca72fefab8">get</a> (Handle const &amp;handle)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NonLinearDiffusion.html#ga826a11a3e56ff35a8f3dc38f2c7c9a5e">getAnisotropy</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up directional data for anisotropic regularization.  <a href="group__NonLinearDiffusion.html#ga826a11a3e56ff35a8f3dc38f2c7c9a5e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformAlgo.html#ga36fbe70cf44cf9289ca012b726f449d6">gradientBasedTransform</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a function of the image gradient.  <a href="group__TransformAlgo.html#ga36fbe70cf44cf9289ca012b726f449d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#ga7635aadbeaf4383498850941c5286366">gradientEnergyTensor</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient energy tensor for a scalar valued image.  <a href="group__TensorImaging.html#ga7635aadbeaf4383498850941c5286366"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#gada2a320ba52c347f03c02ef173e346cd">hessianMatrixOfGaussian</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image with the 2nd derivatives of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> at the given scale to get the Hessian matrix.  <a href="group__CommonConvolutionFilters.html#gada2a320ba52c347f03c02ef173e346cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gae34b2f441aa2b256574ae43dc2991294">hourGlassFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Anisotropic tensor smoothing with the hourglass filter.  <a href="group__TensorImaging.html#gae34b2f441aa2b256574ae43dc2991294"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac462ab7aeaeaa2af19c524e89c9ee1fd"></a><!-- doxytag: member="vigra::hypot" ref="gac462ab7aeaeaa2af19c524e89c9ee1fd" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v1, FixedPoint16&lt; IntBits, OverflowHandling &gt; v2)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, <br class="typebreak"/>
OverflowHandling &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gac462ab7aeaeaa2af19c524e89c9ee1fd">hypot</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v1, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of hypotenuse. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8a3bba029e1ba026bd968786cfcf4546"></a><!-- doxytag: member="vigra::imag" ref="ga8a3bba029e1ba026bd968786cfcf4546" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga8a3bba029e1ba026bd968786cfcf4546">imag</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">imaginary part <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#gacdb09d8057559d89daf02641924d1e3b">impexListExtensions</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List the file extension VIGRA understands.  <a href="group__VigraImpex.html#gacdb09d8057559d89daf02641924d1e3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#ga1f42a533f86021968b8ca4d9d9644279">impexListFormats</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List the image formats VIGRA can read and write.  <a href="group__VigraImpex.html#ga1f42a533f86021968b8ca4d9d9644279"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e">importImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an image from a file.  <a href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#ga1a3e91752dac6d0a9be46fe10f337530">importImageAlpha</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the image specified by the given <a class="el" href="classvigra_1_1ImageImportInfo.html">vigra::ImageImportInfo</a> object including its alpha channel.  <a href="group__VigraImpex.html#ga1a3e91752dac6d0a9be46fe10f337530"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TIFFImpex.html#gaeab1bcb8f4a3e708b4a54a6e52cb43ff">importTiffImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a given TIFF image.  <a href="group__TIFFImpex.html#gaeab1bcb8f4a3e708b4a54a6e52cb43ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VolumeImpex.html#gaa8328600a03da4d2849fe33f2a080705">importVolume</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for importing a 3D volume.  <a href="group__VolumeImpex.html#gaa8328600a03da4d2849fe33f2a080705"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator , class IndexIterator , class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort</a> (Iterator first, Iterator last, IndexIterator index_first, Compare c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index permutation that would sort the input array.  <a href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InitAlgo.html#gaf6b3011611521bbc1c3e4dc619d1481e">initImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to every pixel in an image or rectangular ROI.  <a href="group__InitAlgo.html#gaf6b3011611521bbc1c3e4dc619d1481e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InitAlgo.html#gac8aaba3c94bd12dca0ffc3b785441665">initImageBorder</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write value to the specified border pixels in the image.  <a href="group__InitAlgo.html#gac8aaba3c94bd12dca0ffc3b785441665"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InitAlgo.html#ga60e83126eb93647e7615d7e50830ae33">initImageIf</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write value to pixel in the image if mask is true.  <a href="group__InitAlgo.html#ga60e83126eb93647e7615d7e50830ae33"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InitAlgo.html#gabae1fd1bcc1be861f086b347fefbf355">initImageWithFunctor</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the result of a functor call to every pixel in an image or rectangular ROI.  <a href="group__InitAlgo.html#gabae1fd1bcc1be861f086b347fefbf355"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga67ea3b211a208ad10866c127f93860c8">initMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to every element in a multi-dimensional array.  <a href="group__MultiPointoperators.html#ga67ea3b211a208ad10866c127f93860c8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga8a92b7fdbfe1ef87b9024892d3c9ff7d">initMultiArrayBorder</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write values to the specified border values in the array.  <a href="group__MultiPointoperators.html#ga8a92b7fdbfe1ef87b9024892d3c9ff7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452">inspectImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply read-only functor to every pixel in the image.  <a href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InspectAlgo.html#ga8fb06f2d379b65eb3e2a970e38964ecd">inspectImageIf</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply read-only functor to every pixel in the ROI.  <a href="group__InspectAlgo.html#ga8fb06f2d379b65eb3e2a970e38964ecd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga40ad7d2006bb841fd422b2f3a28447c6">inspectMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an analyzing functor at every element of a multi-dimensional array.  <a href="group__MultiPointoperators.html#ga40ad7d2006bb841fd422b2f3a28447c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77">inspectSequence</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an analyzing functor at every element of a sequence.  <a href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InspectAlgo.html#gad70a53a9ab68eab8c6d3371b1269b6ac">inspectTwoImages</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply read-only functor to every pixel of both images.  <a href="group__InspectAlgo.html#gad70a53a9ab68eab8c6d3371b1269b6ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__InspectAlgo.html#gade5a57c06d2ab13ddf4522c931d9e757">inspectTwoImagesIf</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply read-only functor to those pixels of both images where the mask image is non-zero.  <a href="group__InspectAlgo.html#gade5a57c06d2ab13ddf4522c931d9e757"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga35f8cd56d1be02745894e61cfcc096e9">inspectTwoMultiArrays</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an analyzing functor at all corresponding elements of two multi-dimensional arrays.  <a href="group__MultiPointoperators.html#ga35f8cd56d1be02745894e61cfcc096e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InIterator , class OutIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga89c0801ae0f386bade8dbc77fa485301">inversePermutation</a> (InIterator first, InIterator last, OutIterator out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a given permutation.  <a href="group__MathFunctions.html#ga89c0801ae0f386bade8dbc77fa485301"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">AtImageBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PixelNeighborhood.html#gafb116a5d0d69abccd640856eb742f639">isAtImageBorder</a> (int x, int y, int width, int height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether a point is at the image border.  <a href="group__PixelNeighborhood.html#gafb116a5d0d69abccd640856eb742f639"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">AtVolumeBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#gac33681b57ef0dbc13a5ca592e899c619">isAtVolumeBorder</a> (int x, int y, int z, int width, int height, int depth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether a voxel is at the volume border.  <a href="group__VoxelNeighborhood.html#gac33681b57ef0dbc13a5ca592e899c619"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">AtVolumeBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#gadd905565288fd29d2228179f4f5971a9">isAtVolumeBorderAntiCausal</a> (int x, int y, int z, int width, int height, int depth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether a voxel is at a scan-order relevant volume border. This function checks if <em>x</em> == 0 or <em>y</em> == 0 or <em>z</em> == <em>0</em> and returns the appropriate value of <a class="el" href="group__VoxelNeighborhood.html#ga4cc579294aeb92b2639e0f4d8744fc58">vigra::AtVolumeBorder</a>, or zero when the voxel is not at te volume border. The behavior of the function is undefined if (x,y,z) is not inside the volume.  <a href="group__VoxelNeighborhood.html#gadd905565288fd29d2228179f4f5971a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3d76dcc3681ef0aab964c49657283fa6"></a><!-- doxytag: member="vigra::isAtVolumeBorderCausal" ref="ga3d76dcc3681ef0aab964c49657283fa6" args="(int x, int y, int z, int width, int height, int)" -->
<a class="el" href="group__PixelNeighborhood.html#ga745167948a746ad025601aff865383ef">AtVolumeBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VoxelNeighborhood.html#ga3d76dcc3681ef0aab964c49657283fa6">isAtVolumeBorderCausal</a> (int x, int y, int z, int width, int height, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether a voxel is at a scan-order relevant volume border. This function checks if <em>x</em> == 0 or <em>y</em> == 0 or <em>z</em> == <em>0</em> and returns the appropriate value of <a class="el" href="group__VoxelNeighborhood.html#ga4cc579294aeb92b2639e0f4d8744fc58">vigra::AtVolumeBorder</a>, or zero when the voxel is not at te volume border. The behavior of the function is undefined if (x,y,z) is not inside the volume. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab84581fb60f16dcd7976476bfb24752c"></a><!-- doxytag: member="vigra::isHDF5" ref="gab84581fb60f16dcd7976476bfb24752c" args="(char const *filename)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#gab84581fb60f16dcd7976476bfb24752c">isHDF5</a> (char const *filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given filename refers to a HDF5 file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraImpex.html#gad4a8e5a893f386a859e7f26748db025d">isImage</a> (char const *filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a file is an image format known to VIGRA.  <a href="group__VigraImpex.html#gad4a8e5a893f386a859e7f26748db025d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#ga7ac70bee121e35247722c80fa20a9232">lab2Polar</a> (V const &amp;lab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polar representation form L*a*b*.  <a href="group__PolarColors.html#ga7ac70bee121e35247722c80fa20a9232"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga25fed81e4512334de2cfa257d38972b2">labelImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a segmented image.  <a href="group__Labeling.html#ga25fed81e4512334de2cfa257d38972b2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#gad8d7c944ead026988c0a3bcadd8076b6">labelImageWithBackground</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a segmented image, excluding the background from labeling.  <a href="group__Labeling.html#gad8d7c944ead026988c0a3bcadd8076b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga8692820fcfdc8adb7ad57582bbb20392">labelMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a> with arbitrary many dimensions.  <a href="group__Labeling.html#ga8692820fcfdc8adb7ad57582bbb20392"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#gacab3be2814f7ca04b10136257dc05c81">labelMultiArrayWithBackground</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a> with arbitrary many dimensions, excluding the background from labeling.  <a href="group__Labeling.html#gacab3be2814f7ca04b10136257dc05c81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga89a6b1e5784831c7145612bd738f3112">labelVolume</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a segmented volume.  <a href="group__Labeling.html#ga89a6b1e5784831c7145612bd738f3112"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SrcIterator , class SrcAccessor , class SrcShape , class DestIterator , class DestAccessor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga290823a39ffaae962651442a9de0f445">labelVolumeSix</a> (triple&lt; SrcIterator, SrcShape, SrcAccessor &gt; src, pair&lt; DestIterator, DestAccessor &gt; dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a segmented volume using the 6-neighborhood.  <a href="group__Labeling.html#ga290823a39ffaae962651442a9de0f445"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga9ea391a72baa327cf6b3c7ac555d1c75">labelVolumeWithBackground</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the connected components of a segmented volume, excluding the background from labeling.  <a href="group__Labeling.html#ga9ea391a72baa327cf6b3c7ac555d1c75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#gabf286ebb8c18843d9989f624b187ec30">laplacianOfGaussian</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image with the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> operator at the given scale.  <a href="group__CommonConvolutionFilters.html#gabf286ebb8c18843d9989f624b187ec30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga1aa613671eda401daa90a686497c27da">lcm</a> (IntType n, IntType m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b">legendre</a> (unsigned int l, int m, REAL x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated Legendre polynomial.  <a href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0197e622433399bc9792bb1a884c0b8d">legendre</a> (unsigned int l, REAL x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre polynomial.  <a href="group__MathFunctions.html#ga0197e622433399bc9792bb1a884c0b8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Multiplier , class DestValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LinearIntensityTransform<br class="typebreak"/>
&lt; DestValueType, Multiplier &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformFunctor.html#gaf4b4d2cc02b2dd950838a452847dee0e">linearIntensityTransform</a> (Multiplier scale, DestValueType offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a linear transform to the source pixel values.  <a href="group__TransformFunctor.html#gaf4b4d2cc02b2dd950838a452847dee0e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NoiseNormalization.html#ga98960448c1bac4e2e068e7dd6ffdfe66">linearNoiseNormalization</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Noise normalization by means of an estimated or given linear noise model.  <a href="group__NoiseNormalization.html#ga98960448c1bac4e2e068e7dd6ffdfe66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SrcValueType , class DestValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LinearIntensityTransform<br class="typebreak"/>
&lt; DestValueType, typename <br class="typebreak"/>
NumericTraits&lt; DestValueType &gt;<br class="typebreak"/>
::RealPromote &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformFunctor.html#ga500478e445d819abfc4dc9a748dcba5d">linearRangeMapping</a> (SrcValueType src_min, SrcValueType src_max, DestValueType dest_min, DestValueType dest_max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a source intensity range linearly to a destination range.  <a href="group__TransformFunctor.html#ga500478e445d819abfc4dc9a748dcba5d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad4ed6110df5e4258d0a4541bcf85c762">linearSequence</a> (Iterator first, Iterator last, Value start, Value step)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with a sequence of numbers.  <a href="group__MathFunctions.html#gad4ed6110df5e4258d0a4541bcf85c762"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local maxima in an image or multi-dimensional array.  <a href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#gaf7d58b90367742c7d20d9b47b82129b6">localMaxima3D</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local maxima in a 3D multi array.  <a href="group__LocalMinMax.html#gaf7d58b90367742c7d20d9b47b82129b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#ga527dfba5468e97ca7f1d676d34bc7162">localMinima</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local minima in an image or multi-dimensional array.  <a href="group__LocalMinMax.html#ga527dfba5468e97ca7f1d676d34bc7162"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LocalMinMax.html#gac845c0bf489cfea8b5caabb8ac827609">localMinima3D</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local minima in a 3D multi array.  <a href="group__LocalMinMax.html#gac845c0bf489cfea8b5caabb8ac827609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83">log2i</a> (<a class="el" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9">UInt32</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-2 logarithm of an integer.  <a href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26">loggamma</a> (double x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the gamma function.  <a href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#ga66419f33a9597d249c04c4e52e92fa00">luv2Polar</a> (V const &amp;luv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polar representation form L*u*v*.  <a href="group__PolarColors.html#ga66419f33a9597d249c04c4e52e92fa00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Stride &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1BasicImageView.html">BasicImageView</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayToImage.html#ga20182bff7c3666046c7f33092bdcdc56">makeBasicImageView</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, Stride &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1BasicImageView.html">BasicImageView</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayToImage.html#ga7b7a8071c5d61465fe214820fa643a6a">makeBasicImageView</a> (<a class="el" href="classvigra_1_1MultiArray.html">MultiArray</a>&lt; 3, T &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Stride &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1BasicImageView.html">BasicImageView</a>&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayToImage.html#gada975249a1858a344d637e9b495826d9">makeRGBImageView</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 3, T, Stride &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5bc03ab0e1ce5b0a6560bcb19d6b3a66"></a><!-- doxytag: member="vigra::max" ref="ga5bc03ab0e1ce5b0a6560bcb19d6b3a66" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; typename <br class="typebreak"/>
PromoteTraits&lt; V1, V2 &gt;<br class="typebreak"/>
::Promote, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga5bc03ab0e1ce5b0a6560bcb19d6b3a66">max</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">element-wise maximum <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga79c34e138b3cea6683b4ffae03deaf1d"></a><!-- doxytag: member="vigra::max" ref="ga79c34e138b3cea6683b4ffae03deaf1d" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">V const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga79c34e138b3cea6683b4ffae03deaf1d">max</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum element <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">triple&lt; <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a>, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a>, <br class="typebreak"/>
<a class="el" href="structvigra_1_1MeshGridAccessor.html">MeshGridAccessor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#gae808cc0b904cf1dc0a5f79477b85ea8b">meshGrid</a> (<a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> upperLeft, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> lowerRight)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga22d93f30188e8ad29c37bd614b26b510"></a><!-- doxytag: member="vigra::min" ref="ga22d93f30188e8ad29c37bd614b26b510" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; typename <br class="typebreak"/>
PromoteTraits&lt; V1, V2 &gt;<br class="typebreak"/>
::Promote, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga22d93f30188e8ad29c37bd614b26b510">min</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">element-wise minimum <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad64049e837827b5ee36a30be305bf459"></a><!-- doxytag: member="vigra::min" ref="gad64049e837827b5ee36a30be305bf459" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">V const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gad64049e837827b5ee36a30be305bf459">min</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum element <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#gaecb29642aab8a911b4f53e289d31e5e5">moveDCToCenter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearrange the quadrants of a Fourier image so that the origin is in the image center.  <a href="group__FourierTransform.html#gaecb29642aab8a911b4f53e289d31e5e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb">moveDCToUpperLeft</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearrange the quadrants of a Fourier image so that the origin is in the image's upper left.  <a href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SlantedEdgeMTF.html#gab9793ce908aa2693c05ac0244d37dd20">mtfFitGaussian</a> (Vector const &amp;mtf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function to a given MTF.  <a href="group__SlantedEdgeMTF.html#gab9793ce908aa2693c05ac0244d37dd20"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga71573012351636ef982341cf3eb1d669"></a><!-- doxytag: member="vigra::mul" ref="ga71573012351636ef982341cf3eb1d669" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r, FixedPoint&lt; IntBits3, FracBits3 &gt; &amp;result)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2, unsigned IntBits3, unsigned FracBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga71573012351636ef982341cf3eb1d669">mul</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits3, FracBits3 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7a7b91fe8e1da3a17615e9ac1adc4182"></a><!-- doxytag: member="vigra::mul" ref="ga7a7b91fe8e1da3a17615e9ac1adc4182" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r, FixedPoint16&lt; IntBits3, OverflowHandling &gt; &amp;result)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2, int IntBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, <br class="typebreak"/>
OverflowHandling &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga7a7b91fe8e1da3a17615e9ac1adc4182">mul</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, OverflowHandling &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary dilation on multi-dimensional arrays.  <a href="group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary erosion on multi-dimensional arrays.  <a href="group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parabolic grayscale dilation on multi-dimensional arrays.  <a href="group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parabolic grayscale erosion on multi-dimensional arrays.  <a href="group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NoiseNormalization.html#ga78d48b96e66ee00680567fe9b84d2b71">noiseVarianceClustering</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the noise variance as a function of the image intensity and cluster the results.  <a href="group__NoiseNormalization.html#ga78d48b96e66ee00680567fe9b84d2b71"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NoiseNormalization.html#gac7a0f3b1b8de238ad40a4925f9e62d3f">noiseVarianceEstimation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the noise variance as a function of the image intensity.  <a href="group__NoiseNormalization.html#gac7a0f3b1b8de238ad40a4925f9e62d3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga074ace0a87d00243c85a52e5071a1ad4">noncentralChi2</a> (unsigned int degreesOfFreedom, double noncentrality, double <a class="el" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d">arg</a>, double accuracy=1e-7)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-central chi square distribution.  <a href="group__MathFunctions.html#ga074ace0a87d00243c85a52e5071a1ad4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226">noncentralChi2CDF</a> (unsigned int degreesOfFreedom, double noncentrality, double <a class="el" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d">arg</a>, double accuracy=1e-7)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative non-central chi square distribution.  <a href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb">noncentralChi2CDFApprox</a> (unsigned int degreesOfFreedom, double noncentrality, double <a class="el" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d">arg</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative non-central chi square distribution (approximate).  <a href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NonLinearDiffusion.html#ga682a281ec8f2abbf2e3b18aaa7753c60">nonlinearDiffusion</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform edge-preserving smoothing at the given scale.  <a href="group__NonLinearDiffusion.html#ga682a281ec8f2abbf2e3b18aaa7753c60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NonLinearDiffusion.html#ga8c9b70b56775668688417757be6fc53c">nonlinearDiffusionExplicit</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform edge-preserving smoothing at the given scale using an explicit scheme.  <a href="group__NonLinearDiffusion.html#ga8c9b70b56775668688417757be6fc53c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252">nonlinearLeastSquares</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a non-linear model to given data by minimizing least squares loss.  <a href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NoiseNormalization.html#ga1d937331b5773114d6c1187560bb901e">nonparametricNoiseNormalization</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Noise normalization by means of an estimated non-parametric noise model.  <a href="group__NoiseNormalization.html#ga1d937331b5773114d6c1187560bb901e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9ddeb69f0746e04e95bc94055e787156"></a><!-- doxytag: member="vigra::norm" ref="ga9ddeb69f0746e04e95bc94055e787156" args="(FixedPoint&lt; IntBits, FracBits &gt; const &amp;v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga9ddeb69f0746e04e95bc94055e787156">norm</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">norm (same as abs). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NormTraits&lt; T &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga794eb2a920016363c5e9653b6b2b6eb2">norm</a> (T const &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The norm of a numerical object.  <a href="group__MathFunctions.html#ga794eb2a920016363c5e9653b6b2b6eb2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga396baa79e8bd78a178597d32d5152041"></a><!-- doxytag: member="vigra::norm" ref="ga396baa79e8bd78a178597d32d5152041" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga396baa79e8bd78a178597d32d5152041">norm</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">norm (= magnitude) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9c83ada5074f95e030cf5e774d9ccf1"></a><!-- doxytag: member="vigra::norm" ref="gad9c83ada5074f95e030cf5e774d9ccf1" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gad9c83ada5074f95e030cf5e774d9ccf1">norm</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">norm (same as <code>abs(r)</code>) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9bc8f44c220da2d20d812be973983bb4"></a><!-- doxytag: member="vigra::norm" ref="ga9bc8f44c220da2d20d812be973983bb4" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; const &amp;v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NormTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits, OverflowHandling &gt;<br class="typebreak"/>
 &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga9bc8f44c220da2d20d812be973983bb4">norm</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">norm (same as abs). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image.  <a href="group__CommonConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">normalizeString</a> (std::string const &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145">odd</a> (int t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an integer is odd.  <a href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga92ee5bb83f2c0f62df5f69c3cc1b109a"></a><!-- doxytag: member="vigra::operator!=" ref="ga92ee5bb83f2c0f62df5f69c3cc1b109a" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; const &amp;l, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga92ee5bb83f2c0f62df5f69c3cc1b109a">operator!=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; const &amp;l, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9e4bf57b03373af7a703d55f339bae6f"></a><!-- doxytag: member="vigra::operator!=" ref="ga9e4bf57b03373af7a703d55f339bae6f" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga9e4bf57b03373af7a703d55f339bae6f">operator!=</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab6fe0235404f2cfe54c027ce7cb1c048"></a><!-- doxytag: member="vigra::operator!=" ref="gab6fe0235404f2cfe54c027ce7cb1c048" args="(FFTWComplex&lt; R &gt; const &amp;a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gab6fe0235404f2cfe54c027ce7cb1c048">operator!=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; const &amp;a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1eca0411f714d8579230c7b1b09004ec"></a><!-- doxytag: member="vigra::operator!=" ref="ga1eca0411f714d8579230c7b1b09004ec" args="(FFTWComplex&lt; R &gt; const &amp;a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga1eca0411f714d8579230c7b1b09004ec">operator!=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; const &amp;a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga06c354606272eb026fb58c9ea104b929"></a><!-- doxytag: member="vigra::operator!=" ref="ga06c354606272eb026fb58c9ea104b929" args="(double a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga06c354606272eb026fb58c9ea104b929">operator!=</a> (double a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga97958d015915989451ddc7c28daa0c8c"></a><!-- doxytag: member="vigra::operator!=" ref="ga97958d015915989451ddc7c28daa0c8c" args="(Rational&lt; IntType1 &gt; const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga97958d015915989451ddc7c28daa0c8c">operator!=</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa0e894d0367337f440c7b9eb5e045157"></a><!-- doxytag: member="vigra::operator!=" ref="gaa0e894d0367337f440c7b9eb5e045157" args="(const Rational&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gaa0e894d0367337f440c7b9eb5e045157">operator!=</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality with right-hand <code>IntType2</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5bfb2105733941a385882631be999bee"></a><!-- doxytag: member="vigra::operator!=" ref="ga5bfb2105733941a385882631be999bee" args="(IntType1 const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga5bfb2105733941a385882631be999bee">operator!=</a> (IntType1 const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality with left-hand <code>IntType1</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae697cc76c952868b590f677c4e9f5087"></a><!-- doxytag: member="vigra::operator!=" ref="gae697cc76c952868b590f677c4e9f5087" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gae697cc76c952868b590f677c4e9f5087">operator!=</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab061d27e4a29a3151a334ed02cf5cfa5"></a><!-- doxytag: member="vigra::operator!=" ref="gab061d27e4a29a3151a334ed02cf5cfa5" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gab061d27e4a29a3151a334ed02cf5cfa5">operator!=</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">not equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga23f91625bf3cabfdfbe5a39af589690c"></a><!-- doxytag: member="vigra::operator%" ref="ga23f91625bf3cabfdfbe5a39af589690c" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V1, <br class="typebreak"/>
SIZE &gt;, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V2, SIZE &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga23f91625bf3cabfdfbe5a39af589690c">operator%</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise modulo <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gacb9a134a0b55404cacccfa0184957ce0"></a><!-- doxytag: member="vigra::operator*" ref="gacb9a134a0b55404cacccfa0184957ce0" args="(const Quaternion&lt; Type &gt; &amp;t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gacb9a134a0b55404cacccfa0184957ce0">operator*</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gafaf0b3495a12470fed33a0b4be1dc726"></a><!-- doxytag: member="vigra::operator*" ref="gafaf0b3495a12470fed33a0b4be1dc726" args="(const Quaternion&lt; Type &gt; &amp;t1, double t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gafaf0b3495a12470fed33a0b4be1dc726">operator*</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, double t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with a scalar on the right. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7baf712a64500ab621dbfef7e867d01d"></a><!-- doxytag: member="vigra::operator*" ref="ga7baf712a64500ab621dbfef7e867d01d" args="(double t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga7baf712a64500ab621dbfef7e867d01d">operator*</a> (double t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with a scalar on the left. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga10a6b2f01e72815d91a4ddb93d087c05"></a><!-- doxytag: member="vigra::operator*" ref="ga10a6b2f01e72815d91a4ddb93d087c05" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FixedPointTraits&lt; <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a><br class="typebreak"/>
&lt; IntBits1, FracBits1 &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, <br class="typebreak"/>
FracBits2 &gt; &gt;::MultipliesType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga10a6b2f01e72815d91a4ddb93d087c05">operator*</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga052cd0fea0574ab6ffdd0ec3e66ae64b"></a><!-- doxytag: member="vigra::operator*" ref="ga052cd0fea0574ab6ffdd0ec3e66ae64b" args="(RGBValue&lt; V1, R, G, B &gt; const &amp;r1, RGBValue&lt; V2, R, G, B &gt; const &amp;r2)" -->
template&lt;class V1 , unsigned int R, unsigned int G, unsigned int B, class V2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, <br class="typebreak"/>
G, B &gt;, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga052cd0fea0574ab6ffdd0ec3e66ae64b">operator*</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, G, B &gt; const &amp;r1, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad7e796faf19e900659765bdb3d10f7d5"></a><!-- doxytag: member="vigra::operator*" ref="gad7e796faf19e900659765bdb3d10f7d5" args="(double v, RGBValue&lt; V, R, G, B &gt; const &amp;r)" -->
template&lt;class V , unsigned int R, unsigned int G, unsigned int B&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, R, <br class="typebreak"/>
G, B &gt; &gt;::RealPromote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gad7e796faf19e900659765bdb3d10f7d5">operator*</a> (double v, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, R, G, B &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise left scalar multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0684221edd4f4d178ed2e5f9711e0e61"></a><!-- doxytag: member="vigra::operator*" ref="ga0684221edd4f4d178ed2e5f9711e0e61" args="(RGBValue&lt; V, R, G, B &gt; const &amp;r, double v)" -->
template&lt;class V , unsigned int R, unsigned int G, unsigned int B&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, R, <br class="typebreak"/>
G, B &gt; &gt;::RealPromote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga0684221edd4f4d178ed2e5f9711e0e61">operator*</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, R, G, B &gt; const &amp;r, double v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise right scalar multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4db72780e2c1065114e179823754f133"></a><!-- doxytag: member="vigra::operator*" ref="ga4db72780e2c1065114e179823754f133" args="(Rational&lt; IntType &gt; l, Rational&lt; IntType &gt; const &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga4db72780e2c1065114e179823754f133">operator*</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf0329f6f30df694d802591c667810f15"></a><!-- doxytag: member="vigra::operator*" ref="gaf0329f6f30df694d802591c667810f15" args="(Rational&lt; IntType &gt; l, typename Rational&lt; IntType &gt;::param_type r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gaf0329f6f30df694d802591c667810f15">operator*</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with right-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0255914f77a9d75aa0f0437bd352c0c8"></a><!-- doxytag: member="vigra::operator*" ref="ga0255914f77a9d75aa0f0437bd352c0c8" args="(typename Rational&lt; IntType &gt;::param_type l, Rational&lt; IntType &gt; r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga0255914f77a9d75aa0f0437bd352c0c8">operator*</a> (typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with left-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab55f8a693ead764f2f9a9c8cdd42be17"></a><!-- doxytag: member="vigra::operator*" ref="gab55f8a693ead764f2f9a9c8cdd42be17" args="(FFTWComplex&lt; R &gt; a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gab55f8a693ead764f2f9a9c8cdd42be17">operator*</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga28d94b780c4e1e1af11a80e101231c5a"></a><!-- doxytag: member="vigra::operator*" ref="ga28d94b780c4e1e1af11a80e101231c5a" args="(FFTWComplex&lt; R &gt; a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga28d94b780c4e1e1af11a80e101231c5a">operator*</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">right multiplication with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa20f36e7c7609dcce4a2521c9c8584bd"></a><!-- doxytag: member="vigra::operator*" ref="gaa20f36e7c7609dcce4a2521c9c8584bd" args="(double a, FFTWComplex&lt; R &gt; b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gaa20f36e7c7609dcce4a2521c9c8584bd">operator*</a> (double a, <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">left multiplication with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1ca6e0e0fb80c2f350dda56853ac683a"></a><!-- doxytag: member="vigra::operator*" ref="ga1ca6e0e0fb80c2f350dda56853ac683a" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits1, OverflowHandling &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, <br class="typebreak"/>
OverflowHandling &gt; &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga1ca6e0e0fb80c2f350dda56853ac683a">operator*</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1831eb2cff2b875b02a852a45132ccfe"></a><!-- doxytag: member="vigra::operator*" ref="ga1831eb2cff2b875b02a852a45132ccfe" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V1, <br class="typebreak"/>
SIZE &gt;, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V2, SIZE &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga1831eb2cff2b875b02a852a45132ccfe">operator*</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8e3fd2ac6dc4d55ec2725743ec69a9b6"></a><!-- doxytag: member="vigra::operator*" ref="ga8e3fd2ac6dc4d55ec2725743ec69a9b6" args="(double v, TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;r)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, <br class="typebreak"/>
SIZE &gt; &gt;::RealPromote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga8e3fd2ac6dc4d55ec2725743ec69a9b6">operator*</a> (double v, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise left scalar multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaba145924900b8d5cc36c8ba6e404a036"></a><!-- doxytag: member="vigra::operator*" ref="gaba145924900b8d5cc36c8ba6e404a036" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l, double v)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, <br class="typebreak"/>
SIZE &gt; &gt;::RealPromote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gaba145924900b8d5cc36c8ba6e404a036">operator*</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l, double v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise right scalar multiplication <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7c6785fdcadae251e827601225613afe"></a><!-- doxytag: member="vigra::operator*=" ref="ga7c6785fdcadae251e827601225613afe" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, <br class="typebreak"/>
BIDX1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga7c6785fdcadae251e827601225613afe">operator*=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">componentwise multiply-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac938fde349795c7905c06b521a42d0b0"></a><!-- doxytag: member="vigra::operator*=" ref="gac938fde349795c7905c06b521a42d0b0" args="(RGBValue&lt; V, RIDX, GIDX, BIDX &gt; &amp;l, double r)" -->
template&lt;class V , unsigned int RIDX, unsigned int GIDX, unsigned int BIDX&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gac938fde349795c7905c06b521a42d0b0">operator*=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt; &amp;l, double r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">componentwise scalar multiply-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabf60a2bcc061ec2ab4d80373afb143f8"></a><!-- doxytag: member="vigra::operator*=" ref="gabf60a2bcc061ec2ab4d80373afb143f8" args="(FFTWComplex&lt; R &gt; &amp;a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gabf60a2bcc061ec2ab4d80373afb143f8">operator*=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga33afa3caf66c8b99ec3336505b9f1685"></a><!-- doxytag: member="vigra::operator*=" ref="ga33afa3caf66c8b99ec3336505b9f1685" args="(FFTWComplex&lt; R &gt; &amp;a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga33afa3caf66c8b99ec3336505b9f1685">operator*=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply-assignment with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5c5a2e62c1e2be530e47c445cea50f5a"></a><!-- doxytag: member="vigra::operator+" ref="ga5c5a2e62c1e2be530e47c445cea50f5a" args="(const Quaternion&lt; Type &gt; &amp;t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga5c5a2e62c1e2be530e47c445cea50f5a">operator+</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44f40bb9de51c68a79819837269854db"></a><!-- doxytag: member="vigra::operator+" ref="ga44f40bb9de51c68a79819837269854db" args="(const Quaternion&lt; Type &gt; &amp;t1, const Type &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga44f40bb9de51c68a79819837269854db">operator+</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, const Type &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a scalar on the right. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae5d5ba66a0302d5c9f04beb913ddfb86"></a><!-- doxytag: member="vigra::operator+" ref="gae5d5ba66a0302d5c9f04beb913ddfb86" args="(const Type &amp;t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gae5d5ba66a0302d5c9f04beb913ddfb86">operator+</a> (const Type &amp;t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a scalar on the left. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5118563b514d92b592eda37c2a3e7fa7"></a><!-- doxytag: member="vigra::operator+" ref="ga5118563b514d92b592eda37c2a3e7fa7" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FixedPointTraits&lt; <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a><br class="typebreak"/>
&lt; IntBits1, FracBits1 &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, <br class="typebreak"/>
FracBits2 &gt; &gt;::PlusType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga5118563b514d92b592eda37c2a3e7fa7">operator+</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#gaae0d5ddc9e1bb121fcd46339a797795d">operator+</a> (<a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;a, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Size2D.html">Size2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#gace64ef530856786069247a7c00ce8fad">operator+</a> (<a class="el" href="classvigra_1_1Size2D.html">Size2D</a> const &amp;a, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Point2D.html">Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#ga4430863eae6524da4517e5b502273a3d">operator+</a> (<a class="el" href="classvigra_1_1Point2D.html">Point2D</a> const &amp;a, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Point2D.html">Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#gae44be824bacf379602984eefe2d14675">operator+</a> (<a class="el" href="classvigra_1_1Size2D.html">Size2D</a> const &amp;s, <a class="el" href="classvigra_1_1Point2D.html">Point2D</a> const &amp;p)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadcec7639c72d2f24ab78add2ae643a8c"></a><!-- doxytag: member="vigra::operator+" ref="gadcec7639c72d2f24ab78add2ae643a8c" args="(RGBValue&lt; V1, R, G, B &gt; const &amp;r1, RGBValue&lt; V2, R, G, B &gt; const &amp;r2)" -->
template&lt;class V1 , unsigned int R, unsigned int G, unsigned int B, class V2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, <br class="typebreak"/>
G, B &gt;, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gadcec7639c72d2f24ab78add2ae643a8c">operator+</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, G, B &gt; const &amp;r1, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise addition <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabb5ab7ca8675f3ceb1364aed2790b931"></a><!-- doxytag: member="vigra::operator+" ref="gabb5ab7ca8675f3ceb1364aed2790b931" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gabb5ab7ca8675f3ceb1364aed2790b931">operator+</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">unary plus <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf0c389a2806529a1c3180011b8d43430"></a><!-- doxytag: member="vigra::operator+" ref="gaf0c389a2806529a1c3180011b8d43430" args="(Rational&lt; IntType &gt; l, Rational&lt; IntType &gt; const &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gaf0c389a2806529a1c3180011b8d43430">operator+</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gafa0019d0c7c5570da496e8cc1d532ee4"></a><!-- doxytag: member="vigra::operator+" ref="gafa0019d0c7c5570da496e8cc1d532ee4" args="(Rational&lt; IntType &gt; l, typename Rational&lt; IntType &gt;::param_type r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gafa0019d0c7c5570da496e8cc1d532ee4">operator+</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition of right-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0c566c857a355a5e8920eabf8d320891"></a><!-- doxytag: member="vigra::operator+" ref="ga0c566c857a355a5e8920eabf8d320891" args="(typename Rational&lt; IntType &gt;::param_type l, Rational&lt; IntType &gt; r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga0c566c857a355a5e8920eabf8d320891">operator+</a> (typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition of left-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaffaee579a6dd0df78e0b676f87fb8141"></a><!-- doxytag: member="vigra::operator+" ref="gaffaee579a6dd0df78e0b676f87fb8141" args="(FFTWComplex&lt; R &gt; a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gaffaee579a6dd0df78e0b676f87fb8141">operator+</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2b43aa3a355c72ca321a0f4586736947"></a><!-- doxytag: member="vigra::operator+" ref="ga2b43aa3a355c72ca321a0f4586736947" args="(FFTWComplex&lt; R &gt; a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga2b43aa3a355c72ca321a0f4586736947">operator+</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">right addition with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga978fc1395d6135ec7e374d36ae3b8630"></a><!-- doxytag: member="vigra::operator+" ref="ga978fc1395d6135ec7e374d36ae3b8630" args="(double a, FFTWComplex&lt; R &gt; b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga978fc1395d6135ec7e374d36ae3b8630">operator+</a> (double a, <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">left addition with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9696782c029526a08b62fcdd4d1cd64b"></a><!-- doxytag: member="vigra::operator+" ref="ga9696782c029526a08b62fcdd4d1cd64b" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits1, OverflowHandling &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, <br class="typebreak"/>
OverflowHandling &gt; &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga9696782c029526a08b62fcdd4d1cd64b">operator+</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addition with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga74f6096f6858b0a6c41d22d5e653a2ba"></a><!-- doxytag: member="vigra::operator+" ref="ga74f6096f6858b0a6c41d22d5e653a2ba" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V1, <br class="typebreak"/>
SIZE &gt;, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V2, SIZE &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga74f6096f6858b0a6c41d22d5e653a2ba">operator+</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise addition <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0eeb1363c0564a367c21e7b5c9846571"></a><!-- doxytag: member="vigra::operator+=" ref="ga0eeb1363c0564a367c21e7b5c9846571" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, <br class="typebreak"/>
BIDX1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga0eeb1363c0564a367c21e7b5c9846571">operator+=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">componentwise add-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga23c9113f38123caf2ae30a59a1a5cfc5"></a><!-- doxytag: member="vigra::operator+=" ref="ga23c9113f38123caf2ae30a59a1a5cfc5" args="(FFTWComplex&lt; R &gt; &amp;a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5">operator+=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">add-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44144b15946ebece5f01e534b9f19428"></a><!-- doxytag: member="vigra::operator+=" ref="ga44144b15946ebece5f01e534b9f19428" args="(FFTWComplex&lt; R &gt; &amp;a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga44144b15946ebece5f01e534b9f19428">operator+=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">add-assignment with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa7a03fac9fd41f7d29a4c7ee8a93c1a0"></a><!-- doxytag: member="vigra::operator&#45;" ref="gaa7a03fac9fd41f7d29a4c7ee8a93c1a0" args="(const Quaternion&lt; Type &gt; &amp;t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gaa7a03fac9fd41f7d29a4c7ee8a93c1a0">operator-</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga84042eeb1c416570b41830cdf1a3332b"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga84042eeb1c416570b41830cdf1a3332b" args="(const Quaternion&lt; Type &gt; &amp;t1, const Type &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga84042eeb1c416570b41830cdf1a3332b">operator-</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, const Type &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of a scalar on the right. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab30f374d9d31ad2b8e9549d892db326b"></a><!-- doxytag: member="vigra::operator&#45;" ref="gab30f374d9d31ad2b8e9549d892db326b" args="(const Type &amp;t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gab30f374d9d31ad2b8e9549d892db326b">operator-</a> (const Type &amp;t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of a scalar on the left. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa3204b9190ad43595261ccb307ed1d17"></a><!-- doxytag: member="vigra::operator&#45;" ref="gaa3204b9190ad43595261ccb307ed1d17" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FixedPointTraits&lt; <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a><br class="typebreak"/>
&lt; IntBits1, FracBits1 &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, <br class="typebreak"/>
FracBits2 &gt; &gt;::MinusType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gaa3204b9190ad43595261ccb307ed1d17">operator-</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#ga8bc0dbe52072019f3c87980a96db2ddd">operator-</a> (<a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;a, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Size2D.html">Size2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#ga6d96485f9b1640e73f9407fd32408552">operator-</a> (<a class="el" href="classvigra_1_1Size2D.html">Size2D</a> const &amp;s, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Point2D.html">Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#gafafe8f38862e3f3dc310a2e0d30ee515">operator-</a> (<a class="el" href="classvigra_1_1Point2D.html">Point2D</a> const &amp;s, <a class="el" href="classvigra_1_1Diff2D.html">Diff2D</a> const &amp;offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Size2D.html">Size2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RangesAndPoints.html#ga16d6d97fb37e5f351eb9726d8c9a2e73">operator-</a> (<a class="el" href="classvigra_1_1Point2D.html">Point2D</a> const &amp;s, <a class="el" href="classvigra_1_1Point2D.html">Point2D</a> const &amp;p)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabf4d9e322064d3c423f2380067805b02"></a><!-- doxytag: member="vigra::operator&#45;" ref="gabf4d9e322064d3c423f2380067805b02" args="(RGBValue&lt; V1, R, G, B &gt; const &amp;r1, RGBValue&lt; V2, R, G, B &gt; const &amp;r2)" -->
template&lt;class V1 , unsigned int R, unsigned int G, unsigned int B, class V2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, <br class="typebreak"/>
G, B &gt;, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gabf4d9e322064d3c423f2380067805b02">operator-</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, G, B &gt; const &amp;r1, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise subtraction <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0809bb4cb9a7b804fce33ba1ec74cbf9"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga0809bb4cb9a7b804fce33ba1ec74cbf9" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga0809bb4cb9a7b804fce33ba1ec74cbf9">operator-</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">unary minus (negation) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6a3a4787f12788a01707347ffcc0d213"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga6a3a4787f12788a01707347ffcc0d213" args="(Rational&lt; IntType &gt; l, Rational&lt; IntType &gt; const &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga6a3a4787f12788a01707347ffcc0d213">operator-</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2fe238c8ba5f3173a66ba7a6cde7bbe4"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga2fe238c8ba5f3173a66ba7a6cde7bbe4" args="(Rational&lt; IntType &gt; l, typename Rational&lt; IntType &gt;::param_type r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga2fe238c8ba5f3173a66ba7a6cde7bbe4">operator-</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction of right-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8dc3bdc13d09ae15c2b7e1e2a1cf91cb"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga8dc3bdc13d09ae15c2b7e1e2a1cf91cb" args="(typename Rational&lt; IntType &gt;::param_type l, Rational&lt; IntType &gt; const &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga8dc3bdc13d09ae15c2b7e1e2a1cf91cb">operator-</a> (typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction from left-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga877385dc1d7333ce014514162cb3d640"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga877385dc1d7333ce014514162cb3d640" args="(FFTWComplex&lt; R &gt; a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga877385dc1d7333ce014514162cb3d640">operator-</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga01179d1bd47c2489c8e41f05b206da1f"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga01179d1bd47c2489c8e41f05b206da1f" args="(FFTWComplex&lt; R &gt; a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga01179d1bd47c2489c8e41f05b206da1f">operator-</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">right subtraction with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6076134b0df86cbf145fe0580f818a18"></a><!-- doxytag: member="vigra::operator&#45;" ref="ga6076134b0df86cbf145fe0580f818a18" args="(double a, FFTWComplex&lt; R &gt; const &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga6076134b0df86cbf145fe0580f818a18">operator-</a> (double a, <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; const &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">left subtraction with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9f66cf8e4b6e5c5440a76bf44a19920"></a><!-- doxytag: member="vigra::operator&#45;" ref="gad9f66cf8e4b6e5c5440a76bf44a19920" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits1, OverflowHandling &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, <br class="typebreak"/>
OverflowHandling &gt; &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gad9f66cf8e4b6e5c5440a76bf44a19920">operator-</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaba242b4501a425ad4499e0a24f76c502"></a><!-- doxytag: member="vigra::operator&#45;" ref="gaba242b4501a425ad4499e0a24f76c502" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V1, <br class="typebreak"/>
SIZE &gt;, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V2, SIZE &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gaba242b4501a425ad4499e0a24f76c502">operator-</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise subtraction <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gae825420f3495f62f52712f8d3d0cd68e">operator-</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga69690a95db5749c31fdd17799464da3f"></a><!-- doxytag: member="vigra::operator&#45;=" ref="ga69690a95db5749c31fdd17799464da3f" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, <br class="typebreak"/>
BIDX1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga69690a95db5749c31fdd17799464da3f">operator-=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">componentwise subtract-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5f4de017fa0a604ec08a41a1b12d9ae1"></a><!-- doxytag: member="vigra::operator&#45;=" ref="ga5f4de017fa0a604ec08a41a1b12d9ae1" args="(FFTWComplex&lt; R &gt; &amp;a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga5f4de017fa0a604ec08a41a1b12d9ae1">operator-=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga856da547ecd3c32c6fbec9ed770d1af6"></a><!-- doxytag: member="vigra::operator&#45;=" ref="ga856da547ecd3c32c6fbec9ed770d1af6" args="(FFTWComplex&lt; R &gt; &amp;a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga856da547ecd3c32c6fbec9ed770d1af6">operator-=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract-assignment with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7ae7b34c5f22d9f6a275e733949b7f0c"></a><!-- doxytag: member="vigra::operator/" ref="ga7ae7b34c5f22d9f6a275e733949b7f0c" args="(const Quaternion&lt; Type &gt; &amp;t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga7ae7b34c5f22d9f6a275e733949b7f0c">operator/</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga401bda47b1b931d0391e6e12c88ba0a5"></a><!-- doxytag: member="vigra::operator/" ref="ga401bda47b1b931d0391e6e12c88ba0a5" args="(const Quaternion&lt; Type &gt; &amp;t1, double t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga401bda47b1b931d0391e6e12c88ba0a5">operator/</a> (const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t1, double t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a scalar. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8f28681aa28041cfd29a5b23e7ab7d62"></a><!-- doxytag: member="vigra::operator/" ref="ga8f28681aa28041cfd29a5b23e7ab7d62" args="(double t1, const Quaternion&lt; Type &gt; &amp;t2)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#ga8f28681aa28041cfd29a5b23e7ab7d62">operator/</a> (double t1, const <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of a scalar by a <a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga021b148acc7fccbe8c1ad956f7f4db3b"></a><!-- doxytag: member="vigra::operator/" ref="ga021b148acc7fccbe8c1ad956f7f4db3b" args="(RGBValue&lt; V1, R, G, B &gt; const &amp;r1, RGBValue&lt; V2, R, G, B &gt; const &amp;r2)" -->
template&lt;class V1 , unsigned int R, unsigned int G, unsigned int B, class V2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, <br class="typebreak"/>
G, B &gt;, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga021b148acc7fccbe8c1ad956f7f4db3b">operator/</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, R, G, B &gt; const &amp;r1, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, R, G, B &gt; const &amp;r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise division <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9464662037b250d97b80bb12ac55cba"></a><!-- doxytag: member="vigra::operator/" ref="gad9464662037b250d97b80bb12ac55cba" args="(Rational&lt; IntType &gt; l, Rational&lt; IntType &gt; const &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gad9464662037b250d97b80bb12ac55cba">operator/</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">division <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6ae01e7b38ae1d9f38b7578d6c52649d"></a><!-- doxytag: member="vigra::operator/" ref="ga6ae01e7b38ae1d9f38b7578d6c52649d" args="(RGBValue&lt; V, R, G, B &gt; const &amp;r, double v)" -->
template&lt;class V , unsigned int R, unsigned int G, unsigned int B&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, R, <br class="typebreak"/>
G, B &gt; &gt;::RealPromote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga6ae01e7b38ae1d9f38b7578d6c52649d">operator/</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, R, G, B &gt; const &amp;r, double v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise scalar division <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5733c7dd1e51502d7f5c46fcbcb03a7c"></a><!-- doxytag: member="vigra::operator/" ref="ga5733c7dd1e51502d7f5c46fcbcb03a7c" args="(Rational&lt; IntType &gt; l, typename Rational&lt; IntType &gt;::param_type r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga5733c7dd1e51502d7f5c46fcbcb03a7c">operator/</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; l, typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">division by right-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab6ad7be37eb62b881e9d35565ab308e7"></a><!-- doxytag: member="vigra::operator/" ref="gab6ad7be37eb62b881e9d35565ab308e7" args="(typename Rational&lt; IntType &gt;::param_type l, Rational&lt; IntType &gt; const &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gab6ad7be37eb62b881e9d35565ab308e7">operator/</a> (typename <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;::param_type l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">division of left-hand <code>IntType</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6157aa4812880790195e256ef851ea85"></a><!-- doxytag: member="vigra::operator/" ref="ga6157aa4812880790195e256ef851ea85" args="(FFTWComplex&lt; R &gt; a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga6157aa4812880790195e256ef851ea85">operator/</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">division <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6abb61c23f29b9d361c10e617361951c"></a><!-- doxytag: member="vigra::operator/" ref="ga6abb61c23f29b9d361c10e617361951c" args="(FFTWComplex&lt; R &gt; a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga6abb61c23f29b9d361c10e617361951c">operator/</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">right division with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab8a9b5981320a7a71b908b1b4ba434ac"></a><!-- doxytag: member="vigra::operator/" ref="gab8a9b5981320a7a71b908b1b4ba434ac" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits1, OverflowHandling &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, <br class="typebreak"/>
OverflowHandling &gt; &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gab8a9b5981320a7a71b908b1b4ba434ac">operator/</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">division with automatic determination of the appropriate result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3fc9256d555f34a0668c51221601379b"></a><!-- doxytag: member="vigra::operator/" ref="ga3fc9256d555f34a0668c51221601379b" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PromoteTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V1, <br class="typebreak"/>
SIZE &gt;, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V2, SIZE &gt;<br class="typebreak"/>
 &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga3fc9256d555f34a0668c51221601379b">operator/</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise division <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2aa838f98ff3d77c35d48976b59c1f47"></a><!-- doxytag: member="vigra::operator/" ref="ga2aa838f98ff3d77c35d48976b59c1f47" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l, double v)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, <br class="typebreak"/>
SIZE &gt; &gt;::RealPromote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga2aa838f98ff3d77c35d48976b59c1f47">operator/</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l, double v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise scalar division <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac2deee25274085a804100cff8b71d73f"></a><!-- doxytag: member="vigra::operator/=" ref="gac2deee25274085a804100cff8b71d73f" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, <br class="typebreak"/>
BIDX1 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gac2deee25274085a804100cff8b71d73f">operator/=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; &amp;l, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">componentwise divide-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadb4aeae9b7a88182917fd395e929cbef"></a><!-- doxytag: member="vigra::operator/=" ref="gadb4aeae9b7a88182917fd395e929cbef" args="(RGBValue&lt; V, RIDX, GIDX, BIDX &gt; &amp;l, double r)" -->
template&lt;class V , unsigned int RIDX, unsigned int GIDX, unsigned int BIDX&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#gadb4aeae9b7a88182917fd395e929cbef">operator/=</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V, RIDX, GIDX, BIDX &gt; &amp;l, double r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">componentwise scalar divide-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2644cfc2c14bb28c5bb96a642abbd882"></a><!-- doxytag: member="vigra::operator/=" ref="ga2644cfc2c14bb28c5bb96a642abbd882" args="(FFTWComplex&lt; R &gt; &amp;a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga2644cfc2c14bb28c5bb96a642abbd882">operator/=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">divide-assignment <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gacb694b91843631ee19c5423300f7c901"></a><!-- doxytag: member="vigra::operator/=" ref="gacb694b91843631ee19c5423300f7c901" args="(FFTWComplex&lt; R &gt; &amp;a, double b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gacb694b91843631ee19c5423300f7c901">operator/=</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a, double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">divide-assignment with scalar double <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga59b7015d21fe02774a7663e6b663e3fc"></a><!-- doxytag: member="vigra::operator&lt;" ref="ga59b7015d21fe02774a7663e6b663e3fc" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga59b7015d21fe02774a7663e6b663e3fc">operator&lt;</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less than <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5dd4e237a725bb4353ab70f94132d266"></a><!-- doxytag: member="vigra::operator&lt;" ref="ga5dd4e237a725bb4353ab70f94132d266" args="(const Rational&lt; IntType1 &gt; &amp;l, const Rational&lt; IntType2 &gt; &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga5dd4e237a725bb4353ab70f94132d266">operator&lt;</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; &amp;l, const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less-than <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga42ecce5ecb66183a0b8095c86d511165"></a><!-- doxytag: member="vigra::operator&lt;" ref="ga42ecce5ecb66183a0b8095c86d511165" args="(const Rational&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga42ecce5ecb66183a0b8095c86d511165">operator&lt;</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less-than with right-hand <code>IntType2</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac83e993970f34eb305dde31c49fa34be"></a><!-- doxytag: member="vigra::operator&lt;" ref="gac83e993970f34eb305dde31c49fa34be" args="(IntType1 const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gac83e993970f34eb305dde31c49fa34be">operator&lt;</a> (IntType1 const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less-than with left-hand <code>IntType1</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaab9f59f79fcac91811fe216014d6721a"></a><!-- doxytag: member="vigra::operator&lt;" ref="gaab9f59f79fcac91811fe216014d6721a" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gaab9f59f79fcac91811fe216014d6721a">operator&lt;</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">lexicographical comparison <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga83e570cad80273f6ab3805176ba6efbd"></a><!-- doxytag: member="vigra::operator&lt;" ref="ga83e570cad80273f6ab3805176ba6efbd" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga83e570cad80273f6ab3805176ba6efbd">operator&lt;</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less than <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraSIFImport.html#ga4045e24531efe890492fa597ddd5dd5a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classvigra_1_1SIFImportInfo.html">SIFImportInfo</a> &amp;info)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabadf6d027d9060e22c4f1042f682febe"></a><!-- doxytag: member="vigra::operator&lt;&lt;" ref="gabadf6d027d9060e22c4f1042f682febe" args="(std::ostream &amp;out, TinyVectorBase&lt; V1, SIZE, DATA, DERIVED &gt; const &amp;l)" -->
template&lt;class V1 , int SIZE, class DATA , class DERIVED &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gabadf6d027d9060e22c4f1042f682febe">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, DATA, DERIVED &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">stream output <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7a2707122ac37df0e799ee89ff743791"></a><!-- doxytag: member="vigra::operator&lt;=" ref="ga7a2707122ac37df0e799ee89ff743791" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga7a2707122ac37df0e799ee89ff743791">operator&lt;=</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less or equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8c0e1e285247020c13726b99c1b33580"></a><!-- doxytag: member="vigra::operator&lt;=" ref="ga8c0e1e285247020c13726b99c1b33580" args="(Rational&lt; IntType1 &gt; const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga8c0e1e285247020c13726b99c1b33580">operator&lt;=</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less-equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaade2accfab99c5d97d43bbd85805ce23"></a><!-- doxytag: member="vigra::operator&lt;=" ref="gaade2accfab99c5d97d43bbd85805ce23" args="(Rational&lt; IntType1 &gt; const &amp;l, IntType2 const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gaade2accfab99c5d97d43bbd85805ce23">operator&lt;=</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; const &amp;l, IntType2 const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less-equal with right-hand <code>IntType2</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8b9d885c4a6d3ce993c44a79c5f382a2"></a><!-- doxytag: member="vigra::operator&lt;=" ref="ga8b9d885c4a6d3ce993c44a79c5f382a2" args="(IntType1 const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga8b9d885c4a6d3ce993c44a79c5f382a2">operator&lt;=</a> (IntType1 const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less-equal with left-hand <code>IntType1</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3fd04a99f83b89391848d284c9fe2c86"></a><!-- doxytag: member="vigra::operator&lt;=" ref="ga3fd04a99f83b89391848d284c9fe2c86" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga3fd04a99f83b89391848d284c9fe2c86">operator&lt;=</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">less or equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga840a1ef63a492fc281007880df2c10e7"></a><!-- doxytag: member="vigra::operator==" ref="ga840a1ef63a492fc281007880df2c10e7" args="(RGBValue&lt; V1, RIDX1, GIDX1, BIDX1 &gt; const &amp;l, RGBValue&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)" -->
template&lt;class V1 , unsigned int RIDX1, unsigned int GIDX1, unsigned int BIDX1, class V2 , unsigned int RIDX2, unsigned int GIDX2, unsigned int BIDX2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RGBValueOperators.html#ga840a1ef63a492fc281007880df2c10e7">operator==</a> (<a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V1, RIDX1, GIDX1, BIDX1 &gt; const &amp;l, <a class="el" href="classvigra_1_1RGBValue.html">RGBValue</a>&lt; V2, RIDX2, GIDX2, BIDX2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7959490c564db011ada37b265098ff1b"></a><!-- doxytag: member="vigra::operator==" ref="ga7959490c564db011ada37b265098ff1b" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga7959490c564db011ada37b265098ff1b">operator==</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga51aa30ebec3e036cbd162a05d9a34f7f"></a><!-- doxytag: member="vigra::operator==" ref="ga51aa30ebec3e036cbd162a05d9a34f7f" args="(FFTWComplex&lt; R &gt; const &amp;a, const FFTWComplex&lt; R &gt; &amp;b)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga51aa30ebec3e036cbd162a05d9a34f7f">operator==</a> (<a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; const &amp;a, const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae0f327c3a58e9a60ccae929aadf42bc3"></a><!-- doxytag: member="vigra::operator==" ref="gae0f327c3a58e9a60ccae929aadf42bc3" args="(const Rational&lt; IntType1 &gt; &amp;l, const Rational&lt; IntType2 &gt; &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gae0f327c3a58e9a60ccae929aadf42bc3">operator==</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; &amp;l, const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">equality <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5ef13c2d85b678100cf7df108ee40983"></a><!-- doxytag: member="vigra::operator==" ref="ga5ef13c2d85b678100cf7df108ee40983" args="(const Rational&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga5ef13c2d85b678100cf7df108ee40983">operator==</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">equality with right-hand <code>IntType2</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadd8b88ddbd3e4e9114e2907cbddd4872"></a><!-- doxytag: member="vigra::operator==" ref="gadd8b88ddbd3e4e9114e2907cbddd4872" args="(IntType1 const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gadd8b88ddbd3e4e9114e2907cbddd4872">operator==</a> (IntType1 const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">equality with left-hand <code>IntType1</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga523b7e8e929b8d7b2adc9997ab320511"></a><!-- doxytag: member="vigra::operator==" ref="ga523b7e8e929b8d7b2adc9997ab320511" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;l, TinyVectorBase&lt; V2, SIZE, D3, D4 &gt; const &amp;r)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 , class V2 , class D3 , class D4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga523b7e8e929b8d7b2adc9997ab320511">operator==</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;l, <a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V2, SIZE, D3, D4 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">component-wise equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf372af8944f118fcd7b755b60362d554"></a><!-- doxytag: member="vigra::operator==" ref="gaf372af8944f118fcd7b755b60362d554" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gaf372af8944f118fcd7b755b60362d554">operator==</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab8c9b89e1d7d338ca3243a0a6226a331"></a><!-- doxytag: member="vigra::operator&gt;" ref="gab8c9b89e1d7d338ca3243a0a6226a331" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gab8c9b89e1d7d338ca3243a0a6226a331">operator&gt;</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2946ffa1ec8b6d02b8a15f361755b3e7"></a><!-- doxytag: member="vigra::operator&gt;" ref="ga2946ffa1ec8b6d02b8a15f361755b3e7" args="(Rational&lt; IntType1 &gt; const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga2946ffa1ec8b6d02b8a15f361755b3e7">operator&gt;</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater-than <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga719bcf3d7b89a4a8c0095eb1d4ebb5e8"></a><!-- doxytag: member="vigra::operator&gt;" ref="ga719bcf3d7b89a4a8c0095eb1d4ebb5e8" args="(const Rational&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga719bcf3d7b89a4a8c0095eb1d4ebb5e8">operator&gt;</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; &amp;l, IntType2 const &amp;i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater-than with right-hand <code>IntType2</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa9603be3f4235c8650e2adb9bbbd27ca"></a><!-- doxytag: member="vigra::operator&gt;" ref="gaa9603be3f4235c8650e2adb9bbbd27ca" args="(IntType1 const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gaa9603be3f4235c8650e2adb9bbbd27ca">operator&gt;</a> (IntType1 const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater-than with left-hand <code>IntType1</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadd406409450f5e7dcceb7e4dcd6f8246"></a><!-- doxytag: member="vigra::operator&gt;" ref="gadd406409450f5e7dcceb7e4dcd6f8246" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gadd406409450f5e7dcceb7e4dcd6f8246">operator&gt;</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9e66b07e0f99f4a0c73afe630d9ec9e6"></a><!-- doxytag: member="vigra::operator&gt;=" ref="ga9e66b07e0f99f4a0c73afe630d9ec9e6" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga9e66b07e0f99f4a0c73afe630d9ec9e6">operator&gt;=</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater or equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabc0d7fd362c006305cb6d68076703af6"></a><!-- doxytag: member="vigra::operator&gt;=" ref="gabc0d7fd362c006305cb6d68076703af6" args="(Rational&lt; IntType1 &gt; const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gabc0d7fd362c006305cb6d68076703af6">operator&gt;=</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater-equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0bc71efeac21bbb9c83ce5f094bf4dad"></a><!-- doxytag: member="vigra::operator&gt;=" ref="ga0bc71efeac21bbb9c83ce5f094bf4dad" args="(Rational&lt; IntType1 &gt; const &amp;l, IntType2 const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga0bc71efeac21bbb9c83ce5f094bf4dad">operator&gt;=</a> (<a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType1 &gt; const &amp;l, IntType2 const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater-equal with right-hand <code>IntType2</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6aae5b6b09ed46cf7f3517736a4f0c89"></a><!-- doxytag: member="vigra::operator&gt;=" ref="ga6aae5b6b09ed46cf7f3517736a4f0c89" args="(IntType1 const &amp;l, Rational&lt; IntType2 &gt; const &amp;r)" -->
template&lt;typename IntType1 , typename IntType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga6aae5b6b09ed46cf7f3517736a4f0c89">operator&gt;=</a> (IntType1 const &amp;l, <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType2 &gt; const &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater-equal with left-hand <code>IntType1</code> argument <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8dbcf24233b03449957220e8faced0ae"></a><!-- doxytag: member="vigra::operator&gt;=" ref="ga8dbcf24233b03449957220e8faced0ae" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga8dbcf24233b03449957220e8faced0ae">operator&gt;=</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">greater or equal <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Unsupervised__Decomposition.html#ga7aff6f8e1ad85add65d226bcd899e07b">pLSA</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a matrix according to the pLSA algorithm.  <a href="group__Unsupervised__Decomposition.html#ga7aff6f8e1ad85add65d226bcd899e07b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#gafdec7ac4d8ba3ec5a076372eea278c66">polar2Lab</a> (double color, double brightness, double saturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init L*a*b* color triple from polar representation.  <a href="group__PolarColors.html#gafdec7ac4d8ba3ec5a076372eea278c66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#gacda9420225ef2bb0075597549fc493e2">polar2Luv</a> (double color, double brightness, double saturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init L*u*v* color triple from polar representation.  <a href="group__PolarColors.html#gacda9420225ef2bb0075597549fc493e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#gadb4ecbf1f3cd03559da19f5930bf308e">polar2YPrimeCbCr</a> (double color, double brightness, double saturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init Y'CbCr color triple from polar representation.  <a href="group__PolarColors.html#gadb4ecbf1f3cd03559da19f5930bf308e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#gaeb7ea17d644d4bb1c9a11f5298e96c97">polar2YPrimeIQ</a> (double color, double brightness, double saturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init Y'IQ color triple from polar representation.  <a href="group__PolarColors.html#gaeb7ea17d644d4bb1c9a11f5298e96c97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#gaaed05183ac67f4ce6a88bce59be43d47">polar2YPrimePbPr</a> (double color, double brightness, double saturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init Y'PbPr color triple from polar representation.  <a href="group__PolarColors.html#gaaed05183ac67f4ce6a88bce59be43d47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#ga04dfa11029f88093e78cd5b8c620a928">polar2YPrimeUV</a> (double color, double brightness, double saturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init Y'UV color triple from polar representation.  <a href="group__PolarColors.html#ga04dfa11029f88093e78cd5b8c620a928"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class POLYNOMIAL , class VECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials.html#gafdc4f470cee357d53e7db7d40450fde5">polynomialRealRoots</a> (POLYNOMIAL const &amp;p, VECTOR &amp;roots, bool polishRoots)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class POLYNOMIAL , class VECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials.html#gaf46ab7ff907f8abcaccdb43990c4df6b">polynomialRoots</a> (POLYNOMIAL const &amp;poriginal, VECTOR &amp;roots, bool polishRoots)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#gaba43b6f85c1ae2dc67ab8150268a346b">pow</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r, int n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , int SIZE, class D1 , class D2 , class E &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga4edd815fa4f00487d010da6521e7f101">pow</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v, E exponent)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned n, class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga203e71c46fd7f38f8139eed3072f6c78">power</a> (const V &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation to a positive integer power by squaring.  <a href="group__MathFunctions.html#ga203e71c46fd7f38f8139eed3072f6c78"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Unsupervised__Decomposition.html#ga03b34ec75f31e6ea3b2dc541f31204fe">principleComponents</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C1 &gt; const &amp;features, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C2 &gt; fz, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C3 &gt; zv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a matrix according to the PCA algorithm.  <a href="group__Unsupervised__Decomposition.html#ga03b34ec75f31e6ea3b2dc541f31204fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa49e08e69b54385f9434ffe32a32f299"></a><!-- doxytag: member="vigra::prod" ref="gaa49e08e69b54385f9434ffe32a32f299" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; V &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299">prod</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">product of the vector's elements <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#ga3abb6e1a494b5d3ce952dbacf71c3092">pyramidExpandBurtFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-fold up-sampling for image pyramid reconstruction.  <a href="group__ResamplingConvolutionFilters.html#ga3abb6e1a494b5d3ce952dbacf71c3092"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Image , class Alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#ga220bd2af2ffb47ed8ed6ba583207c079">pyramidExpandBurtLaplacian</a> (<a class="el" href="classvigra_1_1ImagePyramid.html">ImagePyramid</a>&lt; Image, Alloc &gt; &amp;pyramid, int fromLevel, int toLevel, double centerValue=0.4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct a Laplacian pyramid.  <a href="group__ResamplingConvolutionFilters.html#ga220bd2af2ffb47ed8ed6ba583207c079"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#gafde4a3aeaffdb86f415419444acf49e7">pyramidReduceBurtFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-fold down-sampling for image pyramid construction.  <a href="group__ResamplingConvolutionFilters.html#gafde4a3aeaffdb86f415419444acf49e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Image , class Alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#ga6608e09fdd3756af97586288bc2db2c7">pyramidReduceBurtLaplacian</a> (<a class="el" href="classvigra_1_1ImagePyramid.html">ImagePyramid</a>&lt; Image, Alloc &gt; &amp;pyramid, int fromLevel, int toLevel, double centerValue=0.4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Laplacian pyramid.  <a href="group__ResamplingConvolutionFilters.html#ga6608e09fdd3756af97586288bc2db2c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NoiseNormalization.html#gaeac0754774b3c445c953359f5d2d495f">quadraticNoiseNormalization</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Noise normalization by means of an estimated or given quadratic noise model.  <a href="group__NoiseNormalization.html#gaeac0754774b3c445c953359f5d2d495f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 , class C4 , class C5 , class C6 , class C7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#ga60bf3f23776bd500a5009b2a25442860">quadraticProgramming</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C1 &gt; const &amp;G, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C2 &gt; const &amp;g, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C3 &gt; const &amp;CE, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C4 &gt; const &amp;ce, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C5 &gt; const &amp;CI, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C6 &gt; const &amp;ci, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 2, T, C7 &gt; &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GaborFilter.html#ga13740f6096df3f546d5eeb6ebfbd3d8b">radialGaborSigma</a> (double centerFrequency)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sensible radial sigma for given parameters.  <a href="group__GaborFilter.html#ga13740f6096df3f546d5eeb6ebfbd3d8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SymmetryDetection.html#ga5ea9947261f0d49f92521e9f3ca38ee0">radialSymmetryTransform</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find centers of radial symmetry in an image.  <a href="group__SymmetryDetection.html#ga5ea9947261f0d49f92521e9f3ca38ee0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RandomNumberGeneration.html#gac1184f48edbce638f79fcb5d8074984d">RandomMT19937</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RandomNumberGeneration.html#gae34d6da9b72d96c42bec282cb8936017">randomMT19937</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RandomNumberGeneration.html#gaf517ee17df7fcc2c4b299428b4fe0065">RandomTT800</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RandomNumberGeneration.html#gae55108350d19c537466a50a1783cd3f7">randomTT800</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga0de10b17bd103b0a03ffb23f44019592">rational_cast</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#ga8ccb383ad5d24064f31fab265bc07439">readHDF5</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data specified by the given <a class="el" href="classvigra_1_1HDF5ImportInfo.html">vigra::HDF5ImportInfo</a> object and write the into the given 'array'.  <a href="group__VigraHDF5Impex.html#ga8ccb383ad5d24064f31fab265bc07439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraSIFImport.html#ga4051013d956bcdc9ca2400f6b66c9bf3">readSIF</a> (const <a class="el" href="classvigra_1_1SIFImportInfo.html">SIFImportInfo</a> &amp;info, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 3, float &gt; array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the image data specified by the given <a class="el" href="classvigra_1_1SIFImportInfo.html">vigra::SIFImportInfo</a> object and write them into the given 'array'.  <a href="group__VigraSIFImport.html#ga4051013d956bcdc9ca2400f6b66c9bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__VigraSIFImport.html#ga4fa00a6827e328629e84d68f94145c0f">readSIFBlock</a> (const <a class="el" href="classvigra_1_1SIFImportInfo.html">SIFImportInfo</a> &amp;info, <a class="el" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> offset, <a class="el" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; 3, float &gt; array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read parts of the image data from an Andor SIF file specified with an <a class="el" href="classvigra_1_1SIFImportInfo.html" title="Extracts image properties from an Andor SIF file header.">SIFImportInfo</a> object and write them into the <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a> array.  <a href="group__VigraSIFImport.html#ga4fa00a6827e328629e84d68f94145c0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gafa8d2d7496e4bdd96c42026a0ecbde1c"></a><!-- doxytag: member="vigra::real" ref="gafa8d2d7496e4bdd96c42026a0ecbde1c" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#gafa8d2d7496e4bdd96c42026a0ecbde1c">real</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">real part <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gaa39fc82115f78dfab5ae275eaebb854a">recursiveFilterLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1-dimensional recursive convolution of the source signal.  <a href="group__RecursiveConvolution.html#gaa39fc82115f78dfab5ae275eaebb854a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gaf634b87803c602b9f3f34e670119f035">recursiveFilterX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 1 dimensional recursive filtering (1st and 2nd order) in x direction.  <a href="group__RecursiveConvolution.html#gaf634b87803c602b9f3f34e670119f035"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gaa2197533a4dc993998f89641f61015cb">recursiveFilterY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 1 dimensional recursive filtering (1st and 2nd order) in y direction.  <a href="group__RecursiveConvolution.html#gaa2197533a4dc993998f89641f61015cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga60a94e16526f93f19d0cee9cf6bb9343">recursiveFirstDerivativeLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1 dimensional recursive convolution of the source signal.  <a href="group__RecursiveConvolution.html#ga60a94e16526f93f19d0cee9cf6bb9343"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga1c1ec548957b55a384faae347bea11a1">recursiveFirstDerivativeX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively calculates the 1 dimensional first derivative in x direction.  <a href="group__RecursiveConvolution.html#ga1c1ec548957b55a384faae347bea11a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga403c328c10708888afb8a8ebabff6112">recursiveFirstDerivativeY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively calculates the 1 dimensional first derivative in y direction.  <a href="group__RecursiveConvolution.html#ga403c328c10708888afb8a8ebabff6112"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gac3b0b8f9de1d4349523c013e86f7d87b">recursiveGaussianFilterLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a 1-dimensional recursive approximation of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing.  <a href="group__RecursiveConvolution.html#gac3b0b8f9de1d4349523c013e86f7d87b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gabdf886196470e2cc9cbf346c9fddf2ba">recursiveGaussianFilterX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 1 dimensional recursive approximation of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing in y direction.  <a href="group__RecursiveConvolution.html#gabdf886196470e2cc9cbf346c9fddf2ba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga06487fbca4d237ebb6b31bd946fe4b10">recursiveGaussianFilterY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 1 dimensional recursive approximation of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing in y direction.  <a href="group__RecursiveConvolution.html#ga06487fbca4d237ebb6b31bd946fe4b10"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga514cd0d70fc617cfea89b9dcb779ea18">recursiveSecondDerivativeLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1 dimensional recursive convolution of the source signal.  <a href="group__RecursiveConvolution.html#ga514cd0d70fc617cfea89b9dcb779ea18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gadba28236309482d0cbaafb16255accdc">recursiveSecondDerivativeX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively calculates the 1 dimensional second derivative in x direction.  <a href="group__RecursiveConvolution.html#gadba28236309482d0cbaafb16255accdc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga6b132800bac14425c86402edd6af1338">recursiveSecondDerivativeY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively calculates the 1 dimensional second derivative in y direction.  <a href="group__RecursiveConvolution.html#ga6b132800bac14425c86402edd6af1338"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolves the image with a 1-dimensional exponential filter.  <a href="group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#gae3e3c74fead25258d1225ceda83f3535">recursiveSmoothX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 1 dimensional recursive smoothing in x direction.  <a href="group__RecursiveConvolution.html#gae3e3c74fead25258d1225ceda83f3535"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RecursiveConvolution.html#ga10723bec4fe32dfb5885671c08c5c16a">recursiveSmoothY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 1 dimensional recursive smoothing in y direction.  <a href="group__RecursiveConvolution.html#ga10723bec4fe32dfb5885671c08c5c16a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0">reflectImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflect image horizontally or vertically.  <a href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga0d13d25c5b735aaca90c5a506bb274ac">regionImageToCrackEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a labeled image into a crack edge (interpixel edge) image.  <a href="group__Labeling.html#ga0d13d25c5b735aaca90c5a506bb274ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Labeling.html#ga6b16eb7df332ab9392e0927c2b5383e2">regionImageToEdgeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a labeled image into an edge image.  <a href="group__Labeling.html#ga6b16eb7df332ab9392e0927c2b5383e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga6f9601dcf8f062b88b8cb80b8fdd76a5">removeShortEdges</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove short edges from an edge image.  <a href="group__EdgeDetection.html#ga6f9601dcf8f062b88b8cb80b8fdd76a5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga823eb2815225a1fc8771c4138a5ccb1b">resampleImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample image by a given factor.  <a href="group__GeometricTransformations.html#ga823eb2815225a1fc8771c4138a5ccb1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#gac820754f8e34277afa6f098a2d51303a">resamplingConvolveImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply two separable resampling filters successively, the first in x-direction, the second in y-direction.  <a href="group__ResamplingConvolutionFilters.html#gac820754f8e34277afa6f098a2d51303a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#gaa9dc5f38f7cb55b8539de6f1648191f8">resamplingConvolveLine</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1-dimensional resampling convolution of the source signal using the given set of kernels.  <a href="group__ResamplingConvolutionFilters.html#gaa9dc5f38f7cb55b8539de6f1648191f8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#ga047eb80825598893b6ffce266b7a4dbd">resamplingConvolveX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a resampling filter in the x-direction.  <a href="group__ResamplingConvolutionFilters.html#ga047eb80825598893b6ffce266b7a4dbd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ResamplingConvolutionFilters.html#ga3781a892b11a52e752ed4dab52cb6c5f">resamplingConvolveY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a resampling filter in the y-direction.  <a href="group__ResamplingConvolutionFilters.html#ga3781a892b11a52e752ed4dab52cb6c5f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga8c2f8475feaeaf94dcb5df8fd4679d30">resizeImageCatmullRomInterpolation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize image using the Catmull/Rom interpolation function.  <a href="group__GeometricTransformations.html#ga8c2f8475feaeaf94dcb5df8fd4679d30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga725f478e6b802647d77f19c528273947">resizeImageCoscotInterpolation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize image using the Coscot interpolation function.  <a href="group__GeometricTransformations.html#ga725f478e6b802647d77f19c528273947"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga5269b1cd9d82b394fa7cda279a42423b">resizeImageLinearInterpolation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize image using linear interpolation.  <a href="group__GeometricTransformations.html#ga5269b1cd9d82b394fa7cda279a42423b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gaad7f1a2f1e089f2e29b486d81741c9f6">resizeImageNoInterpolation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize image by repeating the nearest pixel values.  <a href="group__GeometricTransformations.html#gaad7f1a2f1e089f2e29b486d81741c9f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga7c1095b357ec19b9edefa849a0a4d178">resizeImageSplineInterpolation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize image using B-spline interpolation.  <a href="group__GeometricTransformations.html#ga7c1095b357ec19b9edefa849a0a4d178"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305">resizeMultiArraySplineInterpolation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a> using B-spline interpolation.  <a href="group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8ca94c8917082971917a51ece034f52f"></a><!-- doxytag: member="vigra::reverse" ref="ga8ca94c8917082971917a51ece034f52f" args="(TinyVector&lt; V, SIZE &gt; const &amp;t)" -->
template&lt;class V , int SIZE&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga8ca94c8917082971917a51ece034f52f">reverse</a> (<a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt; const &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reversed copy <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail::RF_DEFAULT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra.html#ae19ed2482e705ffa14000822902fc131">rf_default</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function to return a RF_DEFAULT tag  <a href="#ae19ed2482e705ffa14000822902fc131"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevigra.html#a4b9531980863a167728e1981dc2faf47">rf_export_HDF5</a> (const <a class="el" href="classvigra_1_1RandomForest.html">RandomForest</a>&lt; T, Tag &gt; &amp;rf, <a class="el" href="classvigra_1_1HDF5File.html">HDF5File</a> &amp;h5context, const std::string &amp;pathname=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a random forest to an <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object into a specified HDF5 group.  <a href="#a4b9531980863a167728e1981dc2faf47"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevigra.html#a0868515f6cfa996e552b183a32be470b">rf_export_HDF5</a> (const <a class="el" href="classvigra_1_1RandomForest.html">RandomForest</a>&lt; T, Tag &gt; &amp;rf, const std::string &amp;filename, const std::string &amp;pathname=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a random forest to a named HDF5 file into a specified HDF5 group.  <a href="#a0868515f6cfa996e552b183a32be470b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevigra.html#a3d43572b44bd45d7008cb31f13b94f61">rf_import_HDF5</a> (<a class="el" href="classvigra_1_1RandomForest.html">RandomForest</a>&lt; T, Tag &gt; &amp;rf, <a class="el" href="classvigra_1_1HDF5File.html">HDF5File</a> &amp;h5context, const std::string &amp;pathname=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a random forest from an <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object's specified group.  <a href="#a3d43572b44bd45d7008cb31f13b94f61"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevigra.html#af288e98b3d173aea3eaaf443c62ce06d">rf_import_HDF5</a> (<a class="el" href="classvigra_1_1RandomForest.html">RandomForest</a>&lt; T, Tag &gt; &amp;rf, const std::string &amp;filename, const std::string &amp;pathname=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a random forest from a named HDF5 file's specified group.  <a href="#af288e98b3d173aea3eaaf443c62ce06d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Riesz transforms of the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>.  <a href="group__CommonConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CornerDetection.html#ga425b0f1d2d17b7aa2518dff5cd1abd8e">rohrCornerDetector</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find corners in an image (3).  <a href="group__CornerDetection.html#ga425b0f1d2d17b7aa2518dff5cd1abd8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gaca913f155ee3de0d6c1177d953370f3a">rotateImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate an image by a multiple of 90 degrees or by an arbitrary angle.  <a href="group__GeometricTransformations.html#gaca913f155ee3de0d6c1177d953370f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gacc7041b192dfb4a79de8d168abd495c9">rotationMatrix2DDegrees</a> (double angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the coordinate origin.  <a href="group__GeometricTransformations.html#gacc7041b192dfb4a79de8d168abd495c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gac5db2aa94b116d3cc1b67b96e4ac96b5">rotationMatrix2DDegrees</a> (double angle, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; double, 2 &gt; const &amp;center)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the given point.  <a href="group__GeometricTransformations.html#gac5db2aa94b116d3cc1b67b96e4ac96b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga814c2b60d8b8579e159e939a76cd6db3">rotationMatrix2DRadians</a> (double angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the coordinate origin.  <a href="group__GeometricTransformations.html#ga814c2b60d8b8579e159e939a76cd6db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gafdb14c737ca2c1587eeb2ac7d040542e">rotationMatrix2DRadians</a> (double angle, <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; double, 2 &gt; const &amp;center)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the given point.  <a href="group__GeometricTransformations.html#gafdb14c737ca2c1587eeb2ac7d040542e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga3fd73560e02ff2f241ebfdf38daf1740">round</a> (REAL v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The rounding function.  <a href="group__MathFunctions.html#ga3fd73560e02ff2f241ebfdf38daf1740"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaddcb15f9b13ee9ba98ee1e5b8e228544"></a><!-- doxytag: member="vigra::round" ref="gaddcb15f9b13ee9ba98ee1e5b8e228544" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544">round</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding to the nearest integer. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaad0bcd8708c6fe598780a675ad30e52d"></a><!-- doxytag: member="vigra::round" ref="gaad0bcd8708c6fe598780a675ad30e52d" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gaad0bcd8708c6fe598780a675ad30e52d">round</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding to the nearest integer. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga0ff1b5c929283b95fa5bfb12a5e2dc62">round</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga97048e053a17edc953036936e59ce88e">roundi</a> (double t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Round and cast to integer.  <a href="group__MathFunctions.html#ga97048e053a17edc953036936e59ce88e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2d7df7a7ce314097e5d4be827ecb18d9"></a><!-- doxytag: member="vigra::roundi" ref="ga2d7df7a7ce314097e5d4be827ecb18d9" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#ga2d7df7a7ce314097e5d4be827ecb18d9">roundi</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">rounding to the nearest integer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga41cb093e4faa9a00db19571790530b86">scalingMatrix2D</a> (double scalingFactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D uniform scaling about the coordinate origin.  <a href="group__GeometricTransformations.html#ga41cb093e4faa9a00db19571790530b86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga0ed2998d9b3c103c07d005ca15a84316">scalingMatrix2D</a> (double sx, double sy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D non-uniform scaling about the coordinate origin.  <a href="group__GeometricTransformations.html#ga0ed2998d9b3c103c07d005ca15a84316"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NonLinearDiffusion.html#ga80e6e77f9e1a94080a3791981bb4fc0c">secondOrderTotalVariationFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Anisotropic Total Variation Regularization.  <a href="group__NonLinearDiffusion.html#ga80e6e77f9e1a94080a3791981bb4fc0c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga7b54436edf7b15b9628d17a22917b4b1">seededRegionGrowing</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Region Segmentation by means of Seeded Region Growing.  <a href="group__SeededRegionGrowing.html#ga7b54436edf7b15b9628d17a22917b4b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#gae9e3ebc5978a393267485d426141a201">seededRegionGrowing3D</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-dimensional Region Segmentation by means of Seeded Region Growing.  <a href="group__SeededRegionGrowing.html#gae9e3ebc5978a393267485d426141a201"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Separated convolution on multi-dimensional arrays.  <a href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1 dimensional convolution in x direction.  <a href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 1 dimensional convolution in y direction.  <a href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayDistanceTransform.html#gac5b055757926655498f70c6253761e27">separableMultiDistance</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance on multi-dimensional arrays.  <a href="group__MultiArrayDistanceTransform.html#gac5b055757926655498f70c6253761e27"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayDistanceTransform.html#gaae083ae030d660264b728eef8a0f5b46">separableMultiDistSquared</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared on multi-dimensional arrays.  <a href="group__MultiArrayDistanceTransform.html#gaae083ae030d660264b728eef8a0f5b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga42a408803035022f33ce0dae2cff5e81">shearMatrix2D</a> (double s01, double s10)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D shearing.  <a href="group__GeometricTransformations.html#ga42a408803035022f33ce0dae2cff5e81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74">sign</a> (T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sign function.  <a href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gab97607c505b78dde9e45ce4f11ad20ea">sign</a> (T1 t1, T2 t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary sign function.  <a href="group__MathFunctions.html#gab97607c505b78dde9e45ce4f11ad20ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2d6f0e128653deb42a47a8f379b4b9a0">signi</a> (T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer sign function.  <a href="group__MathFunctions.html#ga2d6f0e128653deb42a47a8f379b4b9a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform simple sharpening function.  <a href="group__CommonConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0">sin_pi</a> (REAL x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sin(pi*x).  <a href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SlantedEdgeMTF.html#gaff310bc50ffb7d3a60f545c2b7a7bf37">slantedEdgeMTF</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the magnitude transfer function of the camera.  <a href="group__SlantedEdgeMTF.html#gaff310bc50ffb7d3a60f545c2b7a7bf37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga5561f1ce9b3f7a95b7de67738a0d2447">slicSuperpixels</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute SLIC superpixels in arbitrary dimensions.  <a href="group__SeededRegionGrowing.html#ga5561f1ce9b3f7a95b7de67738a0d2447"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; T &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a> (T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The square function.  <a href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga22d75753836176f3d172f58be11ecc4c"></a><!-- doxytag: member="vigra::sqrt" ref="ga22d75753836176f3d172f58be11ecc4c" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SquareRootTraits&lt; <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a><br class="typebreak"/>
&lt; IntBits, FracBits &gt;<br class="typebreak"/>
 &gt;::SquareRootResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c">sqrt</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">square root. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaeba9152f83152e566195b4a6600a1023"></a><!-- doxytag: member="vigra::sqrt" ref="gaeba9152f83152e566195b4a6600a1023" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SquareRootTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits, OverflowHandling &gt;<br class="typebreak"/>
 &gt;::SquareRootResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gaeba9152f83152e566195b4a6600a1023">sqrt</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">square root. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga5e7ad02cda9d7d9be09a5be092ebb520">sqrt</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903">sqrti</a> (<a class="el" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060">Int32</a> v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer square root.  <a href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga435a208ecc16dacbb7e8c20f4c6a530d"></a><!-- doxytag: member="vigra::squaredNorm" ref="ga435a208ecc16dacbb7e8c20f4c6a530d" args="(TinyVectorBase&lt; V1, SIZE, D1, D2 &gt; const &amp;t)" -->
template&lt;class V1 , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, <br class="typebreak"/>
D2 &gt;::SquaredNormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga435a208ecc16dacbb7e8c20f4c6a530d">squaredNorm</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V1, SIZE, D1, D2 &gt; const &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf3b531ba4abcbbc431075c7f3dbc000a"></a><!-- doxytag: member="vigra::squaredNorm" ref="gaf3b531ba4abcbbc431075c7f3dbc000a" args="(Quaternion&lt; Type &gt; const &amp;q)" -->
template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;::SquaredNormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__QuaternionOperations.html#gaf3b531ba4abcbbc431075c7f3dbc000a">squaredNorm</a> (<a class="el" href="classvigra_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; const &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0677c47f51a629befaf13be48958b16b"></a><!-- doxytag: member="vigra::squaredNorm" ref="ga0677c47f51a629befaf13be48958b16b" args="(FixedPoint&lt; IntBits, FracBits &gt; v)" -->
template&lt;unsigned IntBits, unsigned FracBits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FixedPointTraits&lt; <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a><br class="typebreak"/>
&lt; IntBits, FracBits &gt;<br class="typebreak"/>
, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, <br class="typebreak"/>
FracBits &gt; &gt;::MultipliesType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#ga0677c47f51a629befaf13be48958b16b">squaredNorm</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits, FracBits &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm (same as v*v). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NormTraits&lt; T &gt;::SquaredNormType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga38870065d4c6e12602b9154c7e69df1f">squaredNorm</a> (T const &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared norm of a numerical object.  <a href="group__MathFunctions.html#ga38870065d4c6e12602b9154c7e69df1f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga484df995dad9821aac02ec42cd58f7eb"></a><!-- doxytag: member="vigra::squaredNorm" ref="ga484df995dad9821aac02ec42cd58f7eb" args="(const FFTWComplex&lt; R &gt; &amp;a)" -->
template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt;::SquaredNormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FFTWComplexOperators.html#ga484df995dad9821aac02ec42cd58f7eb">squaredNorm</a> (const <a class="el" href="classvigra_1_1FFTWComplex.html">FFTWComplex</a>&lt; R &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm (= squared magnitude) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga821cb2d1bdfae5df5d4b97855358eaa9"></a><!-- doxytag: member="vigra::squaredNorm" ref="ga821cb2d1bdfae5df5d4b97855358eaa9" args="(const Rational&lt; IntType &gt; &amp;r)" -->
template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NormTraits&lt; <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt;<br class="typebreak"/>
 &gt;::SquaredNormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__RationalOperations.html#ga821cb2d1bdfae5df5d4b97855358eaa9">squaredNorm</a> (const <a class="el" href="classvigra_1_1Rational.html">Rational</a>&lt; IntType &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad5ff4b2e985f4917da11535f352a847f"></a><!-- doxytag: member="vigra::squaredNorm" ref="gad5ff4b2e985f4917da11535f352a847f" args="(FixedPoint16&lt; IntBits, OverflowHandling &gt; v)" -->
template&lt;int IntBits, FPOverflowHandling OverflowHandling&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NormTraits&lt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a><br class="typebreak"/>
&lt; IntBits, OverflowHandling &gt;<br class="typebreak"/>
 &gt;::SquaredNormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gad5ff4b2e985f4917da11535f352a847f">squaredNorm</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits, OverflowHandling &gt; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm (same as v*v). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabe11a15981a8e3a4e9715ea8de51f5fb"></a><!-- doxytag: member="vigra::squaredNorm" ref="gabe11a15981a8e3a4e9715ea8de51f5fb" args="(TinyVector&lt; V, SIZE &gt; const &amp;t)" -->
template&lt;class V , int SIZE&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt;<br class="typebreak"/>
::SquaredNormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#gabe11a15981a8e3a4e9715ea8de51f5fb">squaredNorm</a> (<a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; V, SIZE &gt; const &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">squared norm <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CommonConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Structure Tensor for each pixel of and image, using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> (derivative) filters.  <a href="group__CommonConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate th structure tensor of a multi-dimensional arrays.  <a href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa403dd4b5533c2e3000ade778bbf6f81"></a><!-- doxytag: member="vigra::sub" ref="gaa403dd4b5533c2e3000ade778bbf6f81" args="(FixedPoint&lt; IntBits1, FracBits1 &gt; l, FixedPoint&lt; IntBits2, FracBits2 &gt; r, FixedPoint&lt; IntBits3, FracBits3 &gt; &amp;result)" -->
template&lt;unsigned IntBits1, unsigned FracBits1, unsigned IntBits2, unsigned FracBits2, unsigned IntBits3, unsigned FracBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPointOperations.html#gaa403dd4b5533c2e3000ade778bbf6f81">sub</a> (<a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits1, FracBits1 &gt; l, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits2, FracBits2 &gt; r, <a class="el" href="classvigra_1_1FixedPoint.html">FixedPoint</a>&lt; IntBits3, FracBits3 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf596c4c928259b41eb1b7da68affec8b"></a><!-- doxytag: member="vigra::sub" ref="gaf596c4c928259b41eb1b7da68affec8b" args="(FixedPoint16&lt; IntBits1, OverflowHandling &gt; l, FixedPoint16&lt; IntBits2, OverflowHandling &gt; r, FixedPoint16&lt; IntBits3, OverflowHandling &gt; &amp;result)" -->
template&lt;int IntBits1, FPOverflowHandling OverflowHandling, int IntBits2, int IntBits3&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, <br class="typebreak"/>
OverflowHandling &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedPoint16Operations.html#gaf596c4c928259b41eb1b7da68affec8b">sub</a> (<a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits1, OverflowHandling &gt; l, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits2, OverflowHandling &gt; r, <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>&lt; IntBits3, OverflowHandling &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction with enforced result type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga202143b556e7388b4895f457317eb086"></a><!-- doxytag: member="vigra::sum" ref="ga202143b556e7388b4895f457317eb086" args="(TinyVectorBase&lt; V, SIZE, D1, D2 &gt; const &amp;l)" -->
template&lt;class V , int SIZE, class D1 , class D2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; V &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a> (<a class="el" href="classvigra_1_1TinyVectorBase.html">TinyVectorBase</a>&lt; V, SIZE, D1, D2 &gt; const &amp;l)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sum of the vector's elements <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga9210561d31f03b4fa1656bafc7182c0b">symmetric2x2Eigenvalues</a> (T a00, T a01, T a11, T *r0, T *r1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues of a 2x2 real symmetric matrix.  <a href="group__MathFunctions.html#ga9210561d31f03b4fa1656bafc7182c0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2c49eca66b2ba5c308d04fa324dcc230">symmetric3x3Eigenvalues</a> (T a00, T a01, T a02, T a11, T a12, T a22, T *r0, T *r1, T *r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues of a 3x3 real symmetric matrix.  <a href="group__MathFunctions.html#ga2c49eca66b2ba5c308d04fa324dcc230"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate gradient of a multi-dimensional arrays using symmetric difference filters.  <a href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga50a97001588cdbec053d23d1d99079eb">tensorDeterminantMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the tensor determinant for every element of a ND tensor array.  <a href="group__MultiPointoperators.html#ga50a97001588cdbec053d23d1d99079eb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gac6c6ac6dbf29130be5337bb4d4c4c250">tensorEigenRepresentation</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate eigen representation of a symmetric 2x2 tensor.  <a href="group__TensorImaging.html#gac6c6ac6dbf29130be5337bb4d4c4c250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#gacc06f88a0cd7dcdb73f0c4af5b0e0312">tensorEigenvaluesMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the tensor eigenvalues for every element of a N-D tensor array.  <a href="group__MultiPointoperators.html#gacc06f88a0cd7dcdb73f0c4af5b0e0312"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gafcf8fcdf2b221ff2d4f7430353b373f0">tensorToEdgeCorner</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a symmetric 2x2 tensor into its edge and corner parts.  <a href="group__TensorImaging.html#gafcf8fcdf2b221ff2d4f7430353b373f0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gae7b454b5230ad9a79069980f232ac3d7">tensorTrace</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the trace of a 2x2 tensor.  <a href="group__TensorImaging.html#gae7b454b5230ad9a79069980f232ac3d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga0e407a39a189369be86f6e2a9a4a1415">tensorTraceMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the tensor trace for every element of a N-D tensor array.  <a href="group__MultiPointoperators.html#ga0e407a39a189369be86f6e2a9a4a1415"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TIFFImpex.html#ga098bce6a0f789bae2b026745a55a9ef2">tiffToRGBImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a RGB (3-band or color-mapped) TiffImage into a RGB image.  <a href="group__TIFFImpex.html#ga098bce6a0f789bae2b026745a55a9ef2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TIFFImpex.html#ga3b11b4794c6a24de19dc1dbb5e2f8cb8">tiffToScalarImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert single-band TiffImage to scalar image.  <a href="group__TIFFImpex.html#ga3b11b4794c6a24de19dc1dbb5e2f8cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra.html#ad49e6891f1cd7d62bda19b2d3099f04d">tolower</a> (std::string s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__NonLinearDiffusion.html#ga60041a186e8c6a6a7fb98a432bbee319">totalVariationFilter</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standard Total Variation Regularization.  <a href="group__NonLinearDiffusion.html#ga60041a186e8c6a6a7fb98a432bbee319"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">transformImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply unary point transformation to each pixel.  <a href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformAlgo.html#ga2104c7ffff3c6f9fe8f649fbc7a06a94">transformImageIf</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply unary point transformation to each pixel within the ROI (i.e., where the mask is non-zero).  <a href="group__TransformAlgo.html#ga2104c7ffff3c6f9fe8f649fbc7a06a94"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga4e3f906de480f4a867340968da8a98dd">transformMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a multi-dimensional array with a unary function or functor.  <a href="group__MultiPointoperators.html#ga4e3f906de480f4a867340968da8a98dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga18dd969f7e355a60a1ade6517944457d">translationMatrix2D</a> (<a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; double, 2 &gt; const &amp;shift)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create homogeneous matrix representing a 2D translation.  <a href="group__GeometricTransformations.html#ga18dd969f7e355a60a1ade6517944457d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090">transposeImage</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose an image over the major or minor diagonal.  <a href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gac89c1d0fbbeb611478744da17c2bb104">vectorToTensor</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the tensor (outer) product of a 2D vector with itself.  <a href="group__TensorImaging.html#gac89c1d0fbbeb611478744da17c2bb104"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80">vectorToTensorMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the tensor (outer) product of a N-D vector with itself.  <a href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga848b9a3983f20e8ad753d104aad16810">watersheds3D</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Region Segmentation by means of the watershed algorithm.  <a href="group__SeededRegionGrowing.html#ga848b9a3983f20e8ad753d104aad16810"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Label&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga67dae5f2292e59d2de0936e7aa4f3e67">watershedsMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Watershed segmentation of an arbitrary-dimensional array.  <a href="group__SeededRegionGrowing.html#ga67dae5f2292e59d2de0936e7aa4f3e67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#gadc7ca5f4008adfaeeb33875bd378bc9d">watershedsRegionGrowing</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Region segmentation by means of a flooding-based watershed algorithm.  <a href="group__SeededRegionGrowing.html#gadc7ca5f4008adfaeeb33875bd378bc9d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#ga798e1da19d24c46a3762057b1708e8b3">watershedsUnionFind</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Region segmentation by means of the union-find watershed algorithm.  <a href="group__SeededRegionGrowing.html#ga798e1da19d24c46a3762057b1708e8b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#ga2e66ccacdf2a0be58e9ff2565fcc77df">writeHDF5</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Store array data in an HDF5 file.  <a href="group__VigraHDF5Impex.html#ga2e66ccacdf2a0be58e9ff2565fcc77df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t N, class T , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#ga30942a3a78f5d0f0df6f5d39dafc0410">writeHDF5Attr</a> (hid_t loc, const char *name, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, T, C &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t N, class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#ga2302ebaf5025389b1e65925f2730fe01">writeHDF5Attr</a> (hid_t loc, const char *name, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, std::string, C &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#gaa76a3015531eb06d7d5b223f0dd71d84">writeHDF5Attr</a> (hid_t loc, const char *name, <a class="el" href="classvigra_1_1ArrayVectorView.html">ArrayVectorView</a>&lt; T &gt; &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Arr &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VigraHDF5Impex.html#gac870449b451834c012ca7ffe4d282680">writeHDF5Attr</a> (std::string filePath, std::string pathInFile, Arr &amp;ar)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#ga789ff96bd5b7fbcf75100307dcd4617d">yPrimeCbCr2Polar</a> (V const &amp;ycbcr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polar representation form Y'CbCr.  <a href="group__PolarColors.html#ga789ff96bd5b7fbcf75100307dcd4617d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#gaf75e5be718b502797ecece452fac99a1">yPrimeIQ2Polar</a> (V const &amp;yiq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polar representation form Y'IQ.  <a href="group__PolarColors.html#gaf75e5be718b502797ecece452fac99a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#ga46c5522efdc3fc857675fcee909e4110">yPrimePbPr2Polar</a> (V const &amp;ypbpr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polar representation form Y'PbPr.  <a href="group__PolarColors.html#ga46c5522efdc3fc857675fcee909e4110"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; float, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PolarColors.html#ga2976f7502ebf84fc190a6f02ee3b46e8">yPrimeUV2Polar</a> (V const &amp;yuv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polar representation form Y'UV.  <a href="group__PolarColors.html#ga2976f7502ebf84fc190a6f02ee3b46e8"></a><br/></td></tr>
</table>
<hr/><a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<div class="textblock"><p>all VIGRA functionality is located in namespace vigra </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a4843bfa9895ddff20af7279e053b3629"></a><!-- doxytag: member="vigra::GiniRidgeSplit" ref="a4843bfa9895ddff20af7279e053b3629" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RidgeSplit&lt;<a class="el" href="classvigra_1_1BestGiniOfColumn.html">BestGiniOfColumn</a>&lt;<a class="el" href="classvigra_1_1GiniCriterion.html">GiniCriterion</a>&gt; &gt; <a class="el" href="namespacevigra.html#a4843bfa9895ddff20af7279e053b3629">GiniRidgeSplit</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standard ridge regression split </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ab929a955ebe9b33e718a13a08020700a"></a><!-- doxytag: member="vigra::RF_OptionTag" ref="ab929a955ebe9b33e718a13a08020700a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevigra.html#ab929a955ebe9b33e718a13a08020700a">RF_OptionTag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>tags used with the <a class="el" href="classvigra_1_1RandomForestOptions.html" title="Options object for the random forest.">RandomForestOptions</a> class </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RF_Traits::Option_t </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae19ed2482e705ffa14000822902fc131"></a><!-- doxytag: member="vigra::rf_default" ref="ae19ed2482e705ffa14000822902fc131" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::RF_DEFAULT &amp; <a class="el" href="namespacevigra.html#ae19ed2482e705ffa14000822902fc131">rf_default</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>factory function to return a RF_DEFAULT tag </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MachineLearning.html#ga11157c680b4f47c5592d6695b5fbac05" title="learn on data with custom config and random number generator">RandomForest&lt;&gt;::learn()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b9531980863a167728e1981dc2faf47"></a><!-- doxytag: member="vigra::rf_export_HDF5" ref="a4b9531980863a167728e1981dc2faf47" args="(const RandomForest&lt; T, Tag &gt; &amp;rf, HDF5File &amp;h5context, const std::string &amp;pathname=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacevigra.html#a4b9531980863a167728e1981dc2faf47">vigra::rf_export_HDF5</a> </td>
          <td>(</td>
          <td class="paramtype">const RandomForest&lt; T, Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HDF5File &amp;&#160;</td>
          <td class="paramname"><em>h5context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a random forest to an <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object into a specified HDF5 group. </p>
<p>The random forest is saved as a set of HDF5 datasets, groups, and attributes below a certain HDF5 group (default: current group of the <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object). No additional data should be stored in that group.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rf</td><td>Random forest object to be exported </td></tr>
    <tr><td class="paramname">h5context</td><td><a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object to use </td></tr>
    <tr><td class="paramname">pathname</td><td>If empty or not supplied, save the random forest to the current group of the <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object. Otherwise, save to a new-created group specified by the path name, which may be either relative or absolute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0868515f6cfa996e552b183a32be470b"></a><!-- doxytag: member="vigra::rf_export_HDF5" ref="a0868515f6cfa996e552b183a32be470b" args="(const RandomForest&lt; T, Tag &gt; &amp;rf, const std::string &amp;filename, const std::string &amp;pathname=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacevigra.html#a4b9531980863a167728e1981dc2faf47">vigra::rf_export_HDF5</a> </td>
          <td>(</td>
          <td class="paramtype">const RandomForest&lt; T, Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a random forest to a named HDF5 file into a specified HDF5 group. </p>
<p>The random forest is saved as a set of HDF5 datasets, groups, and attributes below a certain HDF5 group (default: root). No additional data should be stored in that group.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rf</td><td>Random forest object to be exported </td></tr>
    <tr><td class="paramname">filename</td><td>Name of an HDF5 file to open </td></tr>
    <tr><td class="paramname">pathname</td><td>If empty or not supplied, save the random forest to the root group of the HDF5 file. Otherwise, save to a new-created group specified by the path name (relative to the root group). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d43572b44bd45d7008cb31f13b94f61"></a><!-- doxytag: member="vigra::rf_import_HDF5" ref="a3d43572b44bd45d7008cb31f13b94f61" args="(RandomForest&lt; T, Tag &gt; &amp;rf, HDF5File &amp;h5context, const std::string &amp;pathname=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacevigra.html#a3d43572b44bd45d7008cb31f13b94f61">vigra::rf_import_HDF5</a> </td>
          <td>(</td>
          <td class="paramtype">RandomForest&lt; T, Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HDF5File &amp;&#160;</td>
          <td class="paramname"><em>h5context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a random forest from an <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object's specified group. </p>
<p>The random forest is read from a certain HDF5 group (default: current group of the <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object) as a set of HDF5 datasets, groups, and attributes. No additional data should be present in that group.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rf</td><td>Random forest object to be imported </td></tr>
    <tr><td class="paramname">h5context</td><td><a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object to use </td></tr>
    <tr><td class="paramname">pathname</td><td>If empty or not supplied, read from the random forest from the current group of the <a class="el" href="classvigra_1_1HDF5File.html" title="Access to HDF5 files.">HDF5File</a> object. Otherwise, use the group specified by the path name, which may be either relative or absolute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af288e98b3d173aea3eaaf443c62ce06d"></a><!-- doxytag: member="vigra::rf_import_HDF5" ref="af288e98b3d173aea3eaaf443c62ce06d" args="(RandomForest&lt; T, Tag &gt; &amp;rf, const std::string &amp;filename, const std::string &amp;pathname=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacevigra.html#a3d43572b44bd45d7008cb31f13b94f61">vigra::rf_import_HDF5</a> </td>
          <td>(</td>
          <td class="paramtype">RandomForest&lt; T, Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>rf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a random forest from a named HDF5 file's specified group. </p>
<p>The random forest is read from a certain HDF5 group (default: root group of the HDF5 file) as a set of HDF5 datasets, groups, and attributes. No additional data should be present in that group.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rf</td><td>Random forest object to be imported </td></tr>
    <tr><td class="paramname">filename</td><td>Name of an HDF5 file to open </td></tr>
    <tr><td class="paramname">pathname</td><td>If empty or not supplied, read from the random forest from the current group of the HDF5 file. Otherwise, use the group specified by the path name, which may be either relative or absolute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abefdd44c2db13a2b64f36c82d3647b82"></a><!-- doxytag: member="vigra::asString" ref="abefdd44c2db13a2b64f36c82d3647b82" args="(T t)(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">vigra::asString</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a value to a string. Available for integral and floating point types and void *. </p>

</div>
</div>
<a class="anchor" id="ad49e6891f1cd7d62bda19b2d3099f04d"></a><!-- doxytag: member="vigra::tolower" ref="ad49e6891f1cd7d62bda19b2d3099f04d" args="(std::string s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacevigra.html#ad49e6891f1cd7d62bda19b2d3099f04d">vigra::tolower</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert string to lower case. </p>

</div>
</div>
<a class="anchor" id="a9e4131b7743b5801ce7122df2c63a9ba"></a><!-- doxytag: member="vigra::normalizeString" ref="a9e4131b7743b5801ce7122df2c63a9ba" args="(std::string const &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">vigra::normalizeString</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert string to lower case and remove any white space characters. </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
