<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - vigra/mathutil.hxx Source File</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">vigra/mathutil.hxx
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************************/</span>
<a name="l00002"></a>00002 <span class="comment">/*                                                                      */</span>
<a name="l00003"></a>00003 <span class="comment">/*               Copyright 1998-2011 by Ullrich Koethe                  */</span>
<a name="l00004"></a>00004 <span class="comment">/*                                                                      */</span>
<a name="l00005"></a>00005 <span class="comment">/*    This file is part of the VIGRA computer vision library.           */</span>
<a name="l00006"></a>00006 <span class="comment">/*    The VIGRA Website is                                              */</span>
<a name="l00007"></a>00007 <span class="comment">/*        http://hci.iwr.uni-heidelberg.de/vigra/                       */</span>
<a name="l00008"></a>00008 <span class="comment">/*    Please direct questions, bug reports, and contributions to        */</span>
<a name="l00009"></a>00009 <span class="comment">/*        ullrich.koethe@iwr.uni-heidelberg.de    or                    */</span>
<a name="l00010"></a>00010 <span class="comment">/*        vigra@informatik.uni-hamburg.de                               */</span>
<a name="l00011"></a>00011 <span class="comment">/*                                                                      */</span>
<a name="l00012"></a>00012 <span class="comment">/*    Permission is hereby granted, free of charge, to any person       */</span>
<a name="l00013"></a>00013 <span class="comment">/*    obtaining a copy of this software and associated documentation    */</span>
<a name="l00014"></a>00014 <span class="comment">/*    files (the &quot;Software&quot;), to deal in the Software without           */</span>
<a name="l00015"></a>00015 <span class="comment">/*    restriction, including without limitation the rights to use,      */</span>
<a name="l00016"></a>00016 <span class="comment">/*    copy, modify, merge, publish, distribute, sublicense, and/or      */</span>
<a name="l00017"></a>00017 <span class="comment">/*    sell copies of the Software, and to permit persons to whom the    */</span>
<a name="l00018"></a>00018 <span class="comment">/*    Software is furnished to do so, subject to the following          */</span>
<a name="l00019"></a>00019 <span class="comment">/*    conditions:                                                       */</span>
<a name="l00020"></a>00020 <span class="comment">/*                                                                      */</span>
<a name="l00021"></a>00021 <span class="comment">/*    The above copyright notice and this permission notice shall be    */</span>
<a name="l00022"></a>00022 <span class="comment">/*    included in all copies or substantial portions of the             */</span>
<a name="l00023"></a>00023 <span class="comment">/*    Software.                                                         */</span>
<a name="l00024"></a>00024 <span class="comment">/*                                                                      */</span>
<a name="l00025"></a>00025 <span class="comment">/*    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND    */</span>
<a name="l00026"></a>00026 <span class="comment">/*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES   */</span>
<a name="l00027"></a>00027 <span class="comment">/*    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND          */</span>
<a name="l00028"></a>00028 <span class="comment">/*    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT       */</span>
<a name="l00029"></a>00029 <span class="comment">/*    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,      */</span>
<a name="l00030"></a>00030 <span class="comment">/*    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      */</span>
<a name="l00031"></a>00031 <span class="comment">/*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR     */</span>
<a name="l00032"></a>00032 <span class="comment">/*    OTHER DEALINGS IN THE SOFTWARE.                                   */</span>                
<a name="l00033"></a>00033 <span class="comment">/*                                                                      */</span>
<a name="l00034"></a>00034 <span class="comment">/************************************************************************/</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef VIGRA_MATHUTIL_HXX</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define VIGRA_MATHUTIL_HXX</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor"># pragma warning (disable: 4996) // hypot/_hypot confusion</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;config.hxx&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;error.hxx&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;tuple.hxx&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;sized_int.hxx&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;numerictraits.hxx&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;algorithm.hxx&quot;</span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">/** \page MathConstants Mathematical Constants</span>
<a name="l00054"></a>00054 <span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">    &lt;TT&gt;M_PI, M_SQRT2 etc.&lt;/TT&gt;</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">    &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;</span>
<a name="l00058"></a>00058 <span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">    Since mathematical constants such as &lt;TT&gt;M_PI&lt;/TT&gt; and &lt;TT&gt;M_SQRT2&lt;/TT&gt; </span>
<a name="l00060"></a>00060 <span class="comment">    are not officially standardized, we provide definitions here for those </span>
<a name="l00061"></a>00061 <span class="comment">    compilers that don&#39;t support them.</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">    \code</span>
<a name="l00064"></a>00064 <span class="comment">    #ifndef M_PI</span>
<a name="l00065"></a>00065 <span class="comment">    #    define M_PI     3.14159265358979323846</span>
<a name="l00066"></a>00066 <span class="comment">    #endif</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">    #ifndef M_SQRT2</span>
<a name="l00069"></a>00069 <span class="comment">    #    define M_2_PI   0.63661977236758134308</span>
<a name="l00070"></a>00070 <span class="comment">    #endif</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    #ifndef M_PI_2</span>
<a name="l00073"></a>00073 <span class="comment">    #    define M_PI_2   1.57079632679489661923</span>
<a name="l00074"></a>00074 <span class="comment">    #endif</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    #ifndef M_PI_4</span>
<a name="l00077"></a>00077 <span class="comment">    #    define M_PI_4   0.78539816339744830962</span>
<a name="l00078"></a>00078 <span class="comment">    #endif</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">    #ifndef M_SQRT2</span>
<a name="l00081"></a>00081 <span class="comment">    #    define M_SQRT2  1.41421356237309504880</span>
<a name="l00082"></a>00082 <span class="comment">    #endif</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">    #ifndef M_EULER_GAMMA</span>
<a name="l00085"></a>00085 <span class="comment">    #    define M_EULER_GAMMA  0.5772156649015329</span>
<a name="l00086"></a>00086 <span class="comment">    #endif</span>
<a name="l00087"></a>00087 <span class="comment">    \endcode</span>
<a name="l00088"></a>00088 <span class="comment">*/</span>
<a name="l00089"></a>00089 <span class="preprocessor">#ifndef M_PI</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#    define M_PI     3.14159265358979323846</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="preprocessor">#ifndef M_2_PI</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#    define M_2_PI   0.63661977236758134308</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097 <span class="preprocessor">#ifndef M_PI_2</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#    define M_PI_2   1.57079632679489661923</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="preprocessor">#ifndef M_PI_4</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#    define M_PI_4   0.78539816339744830962</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>
<a name="l00105"></a>00105 <span class="preprocessor">#ifndef M_SQRT2</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#    define M_SQRT2  1.41421356237309504880</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>
<a name="l00109"></a>00109 <span class="preprocessor">#ifndef M_E</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor">#    define M_E      2.71828182845904523536</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>
<a name="l00113"></a>00113 <span class="preprocessor">#ifndef M_EULER_GAMMA</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#    define M_EULER_GAMMA  0.5772156649015329</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="keyword">namespace </span>vigra {
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment">/** \addtogroup MathFunctions Mathematical Functions</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">    Useful mathematical functions and functors.</span>
<a name="l00122"></a>00122 <span class="comment">*/</span><span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">//@{</span>
<a name="l00124"></a>00124 <span class="comment"></span><span class="comment">// import functions into namespace vigra which VIGRA is going to overload</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keyword">using</span> VIGRA_CSTD::pow;  
<a name="l00127"></a>00127 <span class="keyword">using</span> <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">VIGRA_CSTD::floor</a>;  
<a name="l00128"></a>00128 <span class="keyword">using</span> <a class="code" href="group__FixedPointOperations.html#ga14fe7b9ffa21e091c6ff4ede68717c30" title="rounding up.">VIGRA_CSTD::ceil</a>;  
<a name="l00129"></a>00129 <span class="keyword">using</span> <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">VIGRA_CSTD::exp</a>;  
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment">// import abs(float), abs(double), abs(long double) from &lt;cmath&gt;</span>
<a name="l00132"></a>00132 <span class="comment">//        abs(int), abs(long), abs(long long) from &lt;cstdlib&gt;</span>
<a name="l00133"></a>00133 <span class="comment">//        abs(std::complex&lt;T&gt;) from &lt;complex&gt;</span>
<a name="l00134"></a>00134 <span class="keyword">using</span> <a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">std::abs</a>;  
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="comment">// define the missing variants of abs() to avoid &#39;ambiguous overload&#39;</span>
<a name="l00137"></a>00137 <span class="comment">// errors in template functions</span>
<a name="l00138"></a>00138 <span class="preprocessor">#define VIGRA_DEFINE_UNSIGNED_ABS(T) \</span>
<a name="l00139"></a>00139 <span class="preprocessor">    inline T abs(T t) { return t; }</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>
<a name="l00141"></a>00141 VIGRA_DEFINE_UNSIGNED_ABS(<span class="keywordtype">bool</span>)
<a name="l00142"></a>00142 VIGRA_DEFINE_UNSIGNED_ABS(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)
<a name="l00143"></a>00143 VIGRA_DEFINE_UNSIGNED_ABS(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)
<a name="l00144"></a>00144 VIGRA_DEFINE_UNSIGNED_ABS(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)
<a name="l00145"></a>00145 VIGRA_DEFINE_UNSIGNED_ABS(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)
<a name="l00146"></a>00146 VIGRA_DEFINE_UNSIGNED_ABS(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="preprocessor">#undef VIGRA_DEFINE_UNSIGNED_ABS</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>
<a name="l00150"></a>00150 <span class="preprocessor">#define VIGRA_DEFINE_MISSING_ABS(T) \</span>
<a name="l00151"></a>00151 <span class="preprocessor">    inline T abs(T t) { return t &lt; 0 ? static_cast&lt;T&gt;(-t) : t; }</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span>
<a name="l00153"></a>00153 VIGRA_DEFINE_MISSING_ABS(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)
<a name="l00154"></a>00154 VIGRA_DEFINE_MISSING_ABS(<span class="keywordtype">signed</span> <span class="keywordtype">short</span>)
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1600</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>VIGRA_DEFINE_MISSING_ABS(<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00158"></a>00158 <span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="preprocessor">#undef VIGRA_DEFINE_MISSING_ABS</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>
<a name="l00162"></a>00162 <span class="comment">// scalar dot is needed for generic functions that should work with</span>
<a name="l00163"></a>00163 <span class="comment">// scalars and vectors alike</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="preprocessor">#define VIGRA_DEFINE_SCALAR_DOT(T) \</span>
<a name="l00166"></a>00166 <span class="preprocessor">    inline NumericTraits&lt;T&gt;::Promote dot(T l, T r) { return l*r; }</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>
<a name="l00168"></a>00168 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)
<a name="l00169"></a>00169 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)
<a name="l00170"></a>00170 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)
<a name="l00171"></a>00171 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)
<a name="l00172"></a>00172 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00173"></a>00173 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)
<a name="l00174"></a>00174 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">signed</span> <span class="keywordtype">short</span>)
<a name="l00175"></a>00175 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">signed</span> <span class="keywordtype">int</span>)
<a name="l00176"></a>00176 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">signed</span> <span class="keywordtype">long</span>)
<a name="l00177"></a>00177 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00178"></a>00178 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">float</span>)
<a name="l00179"></a>00179 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">double</span>)
<a name="l00180"></a>00180 VIGRA_DEFINE_SCALAR_DOT(<span class="keywordtype">long</span> <span class="keywordtype">double</span>)
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="preprocessor">#undef VIGRA_DEFINE_SCALAR_DOT</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>
<a name="l00184"></a>00184 <span class="keyword">using</span> std::pow;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// support &#39;double&#39; exponents for all floating point versions of pow()</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">inline</span> <span class="keywordtype">float</span> pow(<span class="keywordtype">float</span> v, <span class="keywordtype">double</span> e)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190     <span class="keywordflow">return</span> std::pow(v, (<span class="keywordtype">float</span>)e);
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">inline</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span> pow(<span class="keywordtype">long</span> <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> e)
<a name="l00194"></a>00194 {
<a name="l00195"></a>00195     <span class="keywordflow">return</span> std::pow(v, (<span class="keywordtype">long</span> <span class="keywordtype">double</span>)e);
<a name="l00196"></a>00196 }
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment">    /** \brief The rounding function.</span>
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment">        Defined for all floating point types. Rounds towards the nearest integer </span>
<a name="l00201"></a>00201 <span class="comment">        such that &lt;tt&gt;abs(round(t)) == round(abs(t))&lt;/tt&gt; for all &lt;tt&gt;t&lt;/tt&gt;.</span>
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00204"></a>00204 <span class="comment">        Namespace: vigra</span>
<a name="l00205"></a>00205 <span class="comment">    */</span>
<a name="l00206"></a>00206 <span class="preprocessor">#ifdef DOXYGEN // only for documentation</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span>REAL <a class="code" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544" title="rounding to the nearest integer.">round</a>(REAL v);
<a name="l00208"></a>00208 <span class="preprocessor">#endif</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>
<a name="l00210"></a>00210 <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544" title="rounding to the nearest integer.">round</a>(<span class="keywordtype">float</span> t)
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212      <span class="keywordflow">return</span> t &gt;= 0.0
<a name="l00213"></a>00213                 ? <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">floor</a>(t + 0.5f)
<a name="l00214"></a>00214                 : <a class="code" href="group__FixedPointOperations.html#ga14fe7b9ffa21e091c6ff4ede68717c30" title="rounding up.">ceil</a>(t - 0.5f);
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544" title="rounding to the nearest integer.">round</a>(<span class="keywordtype">double</span> t)
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219      <span class="keywordflow">return</span> t &gt;= 0.0
<a name="l00220"></a>00220                 ? <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">floor</a>(t + 0.5)
<a name="l00221"></a>00221                 : <a class="code" href="group__FixedPointOperations.html#ga14fe7b9ffa21e091c6ff4ede68717c30" title="rounding up.">ceil</a>(t - 0.5);
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="keyword">inline</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span> <a class="code" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544" title="rounding to the nearest integer.">round</a>(<span class="keywordtype">long</span> <span class="keywordtype">double</span> t)
<a name="l00225"></a>00225 {
<a name="l00226"></a>00226      <span class="keywordflow">return</span> t &gt;= 0.0
<a name="l00227"></a>00227                 ? <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">floor</a>(t + 0.5)
<a name="l00228"></a>00228                 : <a class="code" href="group__FixedPointOperations.html#ga14fe7b9ffa21e091c6ff4ede68717c30" title="rounding up.">ceil</a>(t - 0.5);
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="comment"></span>
<a name="l00232"></a>00232 <span class="comment">    /** \brief Round and cast to integer.</span>
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">        Rounds to the nearest integer like round(), but casts the result to </span>
<a name="l00235"></a>00235 <span class="comment">        &lt;tt&gt;int&lt;/tt&gt; (this will be faster and is usually needed anyway).</span>
<a name="l00236"></a>00236 <span class="comment"></span>
<a name="l00237"></a>00237 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00238"></a>00238 <span class="comment">        Namespace: vigra</span>
<a name="l00239"></a>00239 <span class="comment">    */</span>
<a name="l00240"></a><a class="code" href="group__MathFunctions.html#ga97048e053a17edc953036936e59ce88e">00240</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__FixedPoint16Operations.html#ga2d7df7a7ce314097e5d4be827ecb18d9" title="rounding to the nearest integer.">roundi</a>(<span class="keywordtype">double</span> t)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242      <span class="keywordflow">return</span> t &gt;= 0.0
<a name="l00243"></a>00243                 ? int(t + 0.5)
<a name="l00244"></a>00244                 : int(t - 0.5);
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 <span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment">    /** \brief Round up to the nearest power of 2.</span>
<a name="l00248"></a>00248 <span class="comment"></span>
<a name="l00249"></a>00249 <span class="comment">        Efficient algorithm for finding the smallest power of 2 which is not smaller than \a x</span>
<a name="l00250"></a>00250 <span class="comment">        (function clp2() from Henry Warren: &quot;Hacker&#39;s Delight&quot;, Addison-Wesley, 2003,</span>
<a name="l00251"></a>00251 <span class="comment">         see http://www.hackersdelight.org/).</span>
<a name="l00252"></a>00252 <span class="comment">        If \a x &gt; 2^31, the function will return 0 because integer arithmetic is defined modulo 2^32.</span>
<a name="l00253"></a>00253 <span class="comment"></span>
<a name="l00254"></a>00254 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00255"></a>00255 <span class="comment">        Namespace: vigra</span>
<a name="l00256"></a>00256 <span class="comment">    */</span>
<a name="l00257"></a><a class="code" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5">00257</a> <span class="keyword">inline</span> <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> <a class="code" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5" title="Round up to the nearest power of 2.">ceilPower2</a>(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> x) 
<a name="l00258"></a>00258 {
<a name="l00259"></a>00259     <span class="keywordflow">if</span>(x == 0) <span class="keywordflow">return</span> 0;
<a name="l00260"></a>00260     
<a name="l00261"></a>00261     x = x - 1;
<a name="l00262"></a>00262     x = x | (x &gt;&gt; 1);
<a name="l00263"></a>00263     x = x | (x &gt;&gt; 2);
<a name="l00264"></a>00264     x = x | (x &gt;&gt; 4);
<a name="l00265"></a>00265     x = x | (x &gt;&gt; 8);
<a name="l00266"></a>00266     x = x | (x &gt;&gt;16);
<a name="l00267"></a>00267     <span class="keywordflow">return</span> x + 1;
<a name="l00268"></a>00268 } 
<a name="l00269"></a>00269     <span class="comment"></span>
<a name="l00270"></a>00270 <span class="comment">    /** \brief Round down to the nearest power of 2.</span>
<a name="l00271"></a>00271 <span class="comment"></span>
<a name="l00272"></a>00272 <span class="comment">        Efficient algorithm for finding the largest power of 2 which is not greater than \a x</span>
<a name="l00273"></a>00273 <span class="comment">        (function flp2() from Henry Warren: &quot;Hacker&#39;s Delight&quot;, Addison-Wesley, 2003,</span>
<a name="l00274"></a>00274 <span class="comment">         see http://www.hackersdelight.org/).</span>
<a name="l00275"></a>00275 <span class="comment"></span>
<a name="l00276"></a>00276 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00277"></a>00277 <span class="comment">        Namespace: vigra</span>
<a name="l00278"></a>00278 <span class="comment">    */</span>
<a name="l00279"></a><a class="code" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329">00279</a> <span class="keyword">inline</span> <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> <a class="code" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329" title="Round down to the nearest power of 2.">floorPower2</a>(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> x) 
<a name="l00280"></a>00280 { 
<a name="l00281"></a>00281     x = x | (x &gt;&gt; 1);
<a name="l00282"></a>00282     x = x | (x &gt;&gt; 2);
<a name="l00283"></a>00283     x = x | (x &gt;&gt; 4);
<a name="l00284"></a>00284     x = x | (x &gt;&gt; 8);
<a name="l00285"></a>00285     x = x | (x &gt;&gt;16);
<a name="l00286"></a>00286     <span class="keywordflow">return</span> x - (x &gt;&gt; 1);
<a name="l00287"></a>00287 }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">namespace </span>detail {
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00292"></a>00292 <span class="keyword">struct </span>IntLog2
<a name="l00293"></a>00293 {
<a name="l00294"></a>00294     <span class="keyword">static</span> <a class="code" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060" title="32-bit signed int">Int32</a> table[64];
<a name="l00295"></a>00295 };
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00298"></a>00298 <a class="code" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060" title="32-bit signed int">Int32</a> IntLog2&lt;T&gt;::table[64] = {
<a name="l00299"></a>00299          -1,  0,  -1,  15,  -1,  1,  28,  -1,  16,  -1,  -1,  -1,  2,  21,  
<a name="l00300"></a>00300          29,  -1,  -1,  -1,  19,  17,  10,  -1,  12,  -1,  -1,  3,  -1,  6,  
<a name="l00301"></a>00301          -1,  22,  30,  -1,  14,  -1,  27,  -1,  -1,  -1,  20,  -1,  18,  9,  
<a name="l00302"></a>00302          11,  -1,  5,  -1,  -1,  13,  26,  -1,  -1,  8,  -1,  4,  -1,  25,  
<a name="l00303"></a>00303          -1,  7,  24,  -1,  23,  -1,  31,  -1};
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 } <span class="comment">// namespace detail</span>
<a name="l00306"></a>00306 <span class="comment"></span>
<a name="l00307"></a>00307 <span class="comment">    /** \brief Compute the base-2 logarithm of an integer.</span>
<a name="l00308"></a>00308 <span class="comment"></span>
<a name="l00309"></a>00309 <span class="comment">        Returns the position of the left-most 1-bit in the given number \a x, or</span>
<a name="l00310"></a>00310 <span class="comment">        -1 if \a x == 0. That is,</span>
<a name="l00311"></a>00311 <span class="comment">        </span>
<a name="l00312"></a>00312 <span class="comment">        \code</span>
<a name="l00313"></a>00313 <span class="comment">        assert(k &gt;= 0 &amp;&amp; k &lt; 32 &amp;&amp; log2i(1 &lt;&lt; k) == k);</span>
<a name="l00314"></a>00314 <span class="comment">        \endcode</span>
<a name="l00315"></a>00315 <span class="comment">        </span>
<a name="l00316"></a>00316 <span class="comment">        The function uses Robert Harley&#39;s algorithm to determine the number of leading zeros</span>
<a name="l00317"></a>00317 <span class="comment">        in \a x (algorithm nlz10() at http://www.hackersdelight.org/). But note that the functions</span>
<a name="l00318"></a>00318 <span class="comment">        \ref floorPower2() or \ref ceilPower2() are more efficient and should be preferred when possible.</span>
<a name="l00319"></a>00319 <span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00321"></a>00321 <span class="comment">        Namespace: vigra</span>
<a name="l00322"></a>00322 <span class="comment">    */</span>
<a name="l00323"></a><a class="code" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83">00323</a> <span class="keyword">inline</span> <a class="code" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060" title="32-bit signed int">Int32</a> <a class="code" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83" title="Compute the base-2 logarithm of an integer.">log2i</a>(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> x) 
<a name="l00324"></a>00324 { 
<a name="l00325"></a>00325     <span class="comment">// Propagate leftmost 1-bit to the right.</span>
<a name="l00326"></a>00326     x = x | (x &gt;&gt; 1);
<a name="l00327"></a>00327     x = x | (x &gt;&gt; 2);
<a name="l00328"></a>00328     x = x | (x &gt;&gt; 4);
<a name="l00329"></a>00329     x = x | (x &gt;&gt; 8);
<a name="l00330"></a>00330     x = x | (x &gt;&gt;16);
<a name="l00331"></a>00331     x = x*0x06EB14F9; <span class="comment">// Multiplier is 7*255**3. </span>
<a name="l00332"></a>00332     <span class="keywordflow">return</span> detail::IntLog2&lt;Int32&gt;::table[x &gt;&gt; 26];
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 <span class="comment"></span>
<a name="l00335"></a>00335 <span class="comment">    /** \brief The square function.</span>
<a name="l00336"></a>00336 <span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment">        &lt;tt&gt;sq(x) = x*x&lt;/tt&gt; is needed so often that it makes sense to define it as a function.</span>
<a name="l00338"></a>00338 <span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00340"></a>00340 <span class="comment">        Namespace: vigra</span>
<a name="l00341"></a>00341 <span class="comment">    */</span>
<a name="l00342"></a>00342 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00343"></a>00343 <span class="keyword">inline</span> 
<a name="l00344"></a><a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">00344</a> <span class="keyword">typename</span> NumericTraits&lt;T&gt;::Promote <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(T t)
<a name="l00345"></a>00345 {
<a name="l00346"></a>00346     <span class="keywordflow">return</span> t*t;
<a name="l00347"></a>00347 }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="keyword">namespace </span>detail {
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="keyword">template</span> &lt;<span class="keyword">class</span> V, <span class="keywordtype">unsigned</span>&gt;
<a name="l00352"></a>00352 <span class="keyword">struct </span>cond_mult
<a name="l00353"></a>00353 {
<a name="l00354"></a>00354     <span class="keyword">static</span> V call(<span class="keyword">const</span> V &amp; x, <span class="keyword">const</span> V &amp; y) { <span class="keywordflow">return</span> x * y; }
<a name="l00355"></a>00355 };
<a name="l00356"></a>00356 <span class="keyword">template</span> &lt;<span class="keyword">class</span> V&gt;
<a name="l00357"></a>00357 <span class="keyword">struct </span>cond_mult&lt;V, 0&gt;
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359     <span class="keyword">static</span> V call(<span class="keyword">const</span> V &amp;, <span class="keyword">const</span> V &amp; y) { <span class="keywordflow">return</span> y; }
<a name="l00360"></a>00360 };
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="keyword">template</span> &lt;<span class="keyword">class</span> V, <span class="keywordtype">unsigned</span> n&gt;
<a name="l00363"></a>00363 <span class="keyword">struct </span>power_static
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365     <span class="keyword">static</span> V call(<span class="keyword">const</span> V &amp; x)
<a name="l00366"></a>00366     {
<a name="l00367"></a>00367         <span class="keywordflow">return</span> n / 2
<a name="l00368"></a>00368             ? cond_mult&lt;V, n &amp; 1&gt;::call(x, power_static&lt;V, n / 2&gt;::call(x * x))
<a name="l00369"></a>00369             : n &amp; 1 ? x : V();
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371 };
<a name="l00372"></a>00372 <span class="keyword">template</span> &lt;<span class="keyword">class</span> V&gt;
<a name="l00373"></a>00373 <span class="keyword">struct </span>power_static&lt;V, 0&gt;
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375     <span class="keyword">static</span> V call(<span class="keyword">const</span> V &amp; x)
<a name="l00376"></a>00376     {
<a name="l00377"></a>00377         <span class="keywordflow">return</span> V(1);
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 };
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 } <span class="comment">// namespace detail</span>
<a name="l00382"></a>00382 <span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">    /** \brief Exponentiation to a positive integer power by squaring.</span>
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00386"></a>00386 <span class="comment">        Namespace: vigra</span>
<a name="l00387"></a>00387 <span class="comment">    */</span>
<a name="l00388"></a>00388 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> n, <span class="keyword">class</span> V&gt;
<a name="l00389"></a><a class="code" href="group__MathFunctions.html#ga203e71c46fd7f38f8139eed3072f6c78">00389</a> <span class="keyword">inline</span> V <a class="code" href="group__MathFunctions.html#ga203e71c46fd7f38f8139eed3072f6c78" title="Exponentiation to a positive integer power by squaring.">power</a>(<span class="keyword">const</span> V &amp; x)
<a name="l00390"></a>00390 {
<a name="l00391"></a>00391     <span class="keywordflow">return</span> detail::power_static&lt;V, n&gt;::call(x);
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 <span class="comment">//doxygen_overloaded_function(template &lt;unsigned n, class V&gt; power(const V &amp; x))</span>
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="keyword">namespace </span>detail {
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00398"></a>00398 <span class="keyword">struct </span>IntSquareRoot
<a name="l00399"></a>00399 {
<a name="l00400"></a>00400     <span class="keyword">static</span> <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> sqq_table[];
<a name="l00401"></a>00401     <span class="keyword">static</span> <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> exec(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> v);
<a name="l00402"></a>00402 };
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00405"></a>00405 <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> IntSquareRoot&lt;T&gt;::sqq_table[] = {
<a name="l00406"></a>00406            0,  16,  22,  27,  32,  35,  39,  42,  45,  48,  50,  53,  55,  57,
<a name="l00407"></a>00407           59,  61,  64,  65,  67,  69,  71,  73,  75,  76,  78,  80,  81,  83,
<a name="l00408"></a>00408           84,  86,  87,  89,  90,  91,  93,  94,  96,  97,  98,  99, 101, 102,
<a name="l00409"></a>00409          103, 104, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118,
<a name="l00410"></a>00410          119, 120, 121, 122, 123, 124, 125, 126, 128, 128, 129, 130, 131, 132,
<a name="l00411"></a>00411          133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 144, 145,
<a name="l00412"></a>00412          146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155, 156, 157,
<a name="l00413"></a>00413          158, 159, 160, 160, 161, 162, 163, 163, 164, 165, 166, 167, 167, 168,
<a name="l00414"></a>00414          169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 178,
<a name="l00415"></a>00415          179, 180, 181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 187, 188,
<a name="l00416"></a>00416          189, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197,
<a name="l00417"></a>00417          198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 204, 205, 206, 206,
<a name="l00418"></a>00418          207, 208, 208, 209, 209, 210, 211, 211, 212, 212, 213, 214, 214, 215,
<a name="l00419"></a>00419          215, 216, 217, 217, 218, 218, 219, 219, 220, 221, 221, 222, 222, 223,
<a name="l00420"></a>00420          224, 224, 225, 225, 226, 226, 227, 227, 228, 229, 229, 230, 230, 231,
<a name="l00421"></a>00421          231, 232, 232, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238,
<a name="l00422"></a>00422          239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246,
<a name="l00423"></a>00423          246, 247, 247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253,
<a name="l00424"></a>00424          253, 254, 254, 255
<a name="l00425"></a>00425 };
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00428"></a>00428 <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> IntSquareRoot&lt;T&gt;::exec(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> x) 
<a name="l00429"></a>00429 {
<a name="l00430"></a>00430     <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> xn;
<a name="l00431"></a>00431     <span class="keywordflow">if</span> (x &gt;= 0x10000)
<a name="l00432"></a>00432         <span class="keywordflow">if</span> (x &gt;= 0x1000000)
<a name="l00433"></a>00433             <span class="keywordflow">if</span> (x &gt;= 0x10000000)
<a name="l00434"></a>00434                 <span class="keywordflow">if</span> (x &gt;= 0x40000000) {
<a name="l00435"></a>00435                     <span class="keywordflow">if</span> (x &gt;= (<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a>)65535*(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a>)65535)
<a name="l00436"></a>00436                         <span class="keywordflow">return</span> 65535;
<a name="l00437"></a>00437                     xn = sqq_table[x&gt;&gt;24] &lt;&lt; 8;
<a name="l00438"></a>00438                 } <span class="keywordflow">else</span>
<a name="l00439"></a>00439                     xn = sqq_table[x&gt;&gt;22] &lt;&lt; 7;
<a name="l00440"></a>00440             <span class="keywordflow">else</span>
<a name="l00441"></a>00441                 <span class="keywordflow">if</span> (x &gt;= 0x4000000)
<a name="l00442"></a>00442                     xn = sqq_table[x&gt;&gt;20] &lt;&lt; 6;
<a name="l00443"></a>00443                 <span class="keywordflow">else</span>
<a name="l00444"></a>00444                     xn = sqq_table[x&gt;&gt;18] &lt;&lt; 5;
<a name="l00445"></a>00445         <span class="keywordflow">else</span> {
<a name="l00446"></a>00446             <span class="keywordflow">if</span> (x &gt;= 0x100000)
<a name="l00447"></a>00447                 <span class="keywordflow">if</span> (x &gt;= 0x400000)
<a name="l00448"></a>00448                     xn = sqq_table[x&gt;&gt;16] &lt;&lt; 4;
<a name="l00449"></a>00449                 <span class="keywordflow">else</span>
<a name="l00450"></a>00450                     xn = sqq_table[x&gt;&gt;14] &lt;&lt; 3;
<a name="l00451"></a>00451             <span class="keywordflow">else</span>
<a name="l00452"></a>00452                 <span class="keywordflow">if</span> (x &gt;= 0x40000)
<a name="l00453"></a>00453                     xn = sqq_table[x&gt;&gt;12] &lt;&lt; 2;
<a name="l00454"></a>00454                 <span class="keywordflow">else</span>
<a name="l00455"></a>00455                     xn = sqq_table[x&gt;&gt;10] &lt;&lt; 1;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457             <span class="keywordflow">goto</span> nr1;
<a name="l00458"></a>00458         }
<a name="l00459"></a>00459     <span class="keywordflow">else</span>
<a name="l00460"></a>00460         <span class="keywordflow">if</span> (x &gt;= 0x100) {
<a name="l00461"></a>00461             <span class="keywordflow">if</span> (x &gt;= 0x1000)
<a name="l00462"></a>00462                 <span class="keywordflow">if</span> (x &gt;= 0x4000)
<a name="l00463"></a>00463                     xn = (sqq_table[x&gt;&gt;8] &gt;&gt; 0) + 1;
<a name="l00464"></a>00464                 <span class="keywordflow">else</span>
<a name="l00465"></a>00465                     xn = (sqq_table[x&gt;&gt;6] &gt;&gt; 1) + 1;
<a name="l00466"></a>00466             <span class="keywordflow">else</span>
<a name="l00467"></a>00467                 <span class="keywordflow">if</span> (x &gt;= 0x400)
<a name="l00468"></a>00468                     xn = (sqq_table[x&gt;&gt;4] &gt;&gt; 2) + 1;
<a name="l00469"></a>00469                 <span class="keywordflow">else</span>
<a name="l00470"></a>00470                     xn = (sqq_table[x&gt;&gt;2] &gt;&gt; 3) + 1;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472             <span class="keywordflow">goto</span> adj;
<a name="l00473"></a>00473         } <span class="keywordflow">else</span>
<a name="l00474"></a>00474             <span class="keywordflow">return</span> sqq_table[x] &gt;&gt; 4;
<a name="l00475"></a>00475 
<a name="l00476"></a>00476     <span class="comment">/* Run two iterations of the standard convergence formula */</span>
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     xn = (xn + 1 + x / xn) / 2;
<a name="l00479"></a>00479   nr1:
<a name="l00480"></a>00480     xn = (xn + 1 + x / xn) / 2;
<a name="l00481"></a>00481   adj:
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     <span class="keywordflow">if</span> (xn * xn &gt; x) <span class="comment">/* Correct rounding if necessary */</span>
<a name="l00484"></a>00484         xn--;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486     <span class="keywordflow">return</span> xn;
<a name="l00487"></a>00487 }
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 } <span class="comment">// namespace detail</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="keyword">using</span> <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>;
<a name="l00492"></a>00492 <span class="comment"></span>
<a name="l00493"></a>00493 <span class="comment">    /** \brief Signed integer square root.</span>
<a name="l00494"></a>00494 <span class="comment">    </span>
<a name="l00495"></a>00495 <span class="comment">        Useful for fast fixed-point computations.</span>
<a name="l00496"></a>00496 <span class="comment"></span>
<a name="l00497"></a>00497 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00498"></a>00498 <span class="comment">        Namespace: vigra</span>
<a name="l00499"></a>00499 <span class="comment">    */</span>
<a name="l00500"></a><a class="code" href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903">00500</a> <span class="keyword">inline</span> <a class="code" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060" title="32-bit signed int">Int32</a> <a class="code" href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903" title="Signed integer square root.">sqrti</a>(<a class="code" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060" title="32-bit signed int">Int32</a> v)
<a name="l00501"></a>00501 {
<a name="l00502"></a>00502     <span class="keywordflow">if</span>(v &lt; 0)
<a name="l00503"></a>00503         <span class="keywordflow">throw</span> std::domain_error(<span class="stringliteral">&quot;sqrti(Int32): negative argument.&quot;</span>);
<a name="l00504"></a>00504     <span class="keywordflow">return</span> (<a class="code" href="group__FixedSizeInt.html#ga92f05c4b6944ec5926841e34f03a9060" title="32-bit signed int">Int32</a>)detail::IntSquareRoot&lt;UInt32&gt;::exec((<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a>)v);
<a name="l00505"></a>00505 }
<a name="l00506"></a>00506 <span class="comment"></span>
<a name="l00507"></a>00507 <span class="comment">    /** \brief Unsigned integer square root.</span>
<a name="l00508"></a>00508 <span class="comment"></span>
<a name="l00509"></a>00509 <span class="comment">        Useful for fast fixed-point computations.</span>
<a name="l00510"></a>00510 <span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00512"></a>00512 <span class="comment">        Namespace: vigra</span>
<a name="l00513"></a>00513 <span class="comment">    */</span>
<a name="l00514"></a>00514 <span class="keyword">inline</span> <a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> <a class="code" href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903" title="Signed integer square root.">sqrti</a>(<a class="code" href="group__FixedSizeInt.html#gad055e2244a667a1a5a5c1ee4397c07f9" title="32-bit unsigned int">UInt32</a> v)
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516     <span class="keywordflow">return</span> detail::IntSquareRoot&lt;UInt32&gt;::exec(v);
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="preprocessor">#ifdef VIGRA_NO_HYPOT</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span><span class="comment">    /** \brief Compute the Euclidean distance (length of the hypotenuse of a right-angled triangle).</span>
<a name="l00521"></a>00521 <span class="comment"></span>
<a name="l00522"></a>00522 <span class="comment">        The  hypot()  function  returns  the  sqrt(a*a  +  b*b).</span>
<a name="l00523"></a>00523 <span class="comment">        It is implemented in a way that minimizes round-off error.</span>
<a name="l00524"></a>00524 <span class="comment"></span>
<a name="l00525"></a>00525 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00526"></a>00526 <span class="comment">        Namespace: vigra</span>
<a name="l00527"></a>00527 <span class="comment">    */</span>
<a name="l00528"></a>00528 <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__FixedPoint16Operations.html#gac462ab7aeaeaa2af19c524e89c9ee1fd" title="Length of hypotenuse.">hypot</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b) 
<a name="l00529"></a>00529 { 
<a name="l00530"></a>00530     <span class="keywordtype">double</span> absa = VIGRA_CSTD::fabs(a), absb = VIGRA_CSTD::fabs(b);
<a name="l00531"></a>00531     <span class="keywordflow">if</span> (absa &gt; absb) 
<a name="l00532"></a>00532         <span class="keywordflow">return</span> absa * <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(1.0 + <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(absb/absa)); 
<a name="l00533"></a>00533     <span class="keywordflow">else</span> 
<a name="l00534"></a>00534         <span class="keywordflow">return</span> absb == 0.0
<a name="l00535"></a>00535                    ? 0.0
<a name="l00536"></a>00536                    : absb * <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(1.0 + <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(absa/absb)); 
<a name="l00537"></a>00537 }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="preprocessor">#else</span>
<a name="l00540"></a>00540 <span class="preprocessor"></span>
<a name="l00541"></a>00541 <a class="code" href="group__FixedPoint16Operations.html#gac462ab7aeaeaa2af19c524e89c9ee1fd" title="Length of hypotenuse.">using ::hypot</a>;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="preprocessor">#endif</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00545"></a>00545 <span class="comment">    /** \brief The sign function.</span>
<a name="l00546"></a>00546 <span class="comment"></span>
<a name="l00547"></a>00547 <span class="comment">        Returns 1, 0, or -1 depending on the sign of \a t, but with the same type as \a t.</span>
<a name="l00548"></a>00548 <span class="comment"></span>
<a name="l00549"></a>00549 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00550"></a>00550 <span class="comment">        Namespace: vigra</span>
<a name="l00551"></a>00551 <span class="comment">    */</span>
<a name="l00552"></a>00552 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00553"></a><a class="code" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74">00553</a> <span class="keyword">inline</span> T <a class="code" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74" title="The sign function.">sign</a>(T t) 
<a name="l00554"></a>00554 { 
<a name="l00555"></a>00555     <span class="keywordflow">return</span> t &gt; NumericTraits&lt;T&gt;::zero()
<a name="l00556"></a>00556                ? NumericTraits&lt;T&gt;::one()
<a name="l00557"></a>00557                : t &lt; NumericTraits&lt;T&gt;::zero()
<a name="l00558"></a>00558                     ? -NumericTraits&lt;T&gt;::one()
<a name="l00559"></a>00559                     : NumericTraits&lt;T&gt;::zero();
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">    /** \brief The integer sign function.</span>
<a name="l00563"></a>00563 <span class="comment"></span>
<a name="l00564"></a>00564 <span class="comment">        Returns 1, 0, or -1 depending on the sign of \a t, converted to int.</span>
<a name="l00565"></a>00565 <span class="comment"></span>
<a name="l00566"></a>00566 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00567"></a>00567 <span class="comment">        Namespace: vigra</span>
<a name="l00568"></a>00568 <span class="comment">    */</span>
<a name="l00569"></a>00569 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00570"></a><a class="code" href="group__MathFunctions.html#ga2d6f0e128653deb42a47a8f379b4b9a0">00570</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__MathFunctions.html#ga2d6f0e128653deb42a47a8f379b4b9a0" title="The integer sign function.">signi</a>(T t) 
<a name="l00571"></a>00571 { 
<a name="l00572"></a>00572     <span class="keywordflow">return</span> t &gt; NumericTraits&lt;T&gt;::zero()
<a name="l00573"></a>00573                ? 1
<a name="l00574"></a>00574                : t &lt; NumericTraits&lt;T&gt;::zero()
<a name="l00575"></a>00575                     ? -1
<a name="l00576"></a>00576                     : 0;
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 <span class="comment"></span>
<a name="l00579"></a>00579 <span class="comment">    /** \brief The binary sign function.</span>
<a name="l00580"></a>00580 <span class="comment"></span>
<a name="l00581"></a>00581 <span class="comment">        Transfers the sign of \a t2 to \a t1.</span>
<a name="l00582"></a>00582 <span class="comment"></span>
<a name="l00583"></a>00583 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00584"></a>00584 <span class="comment">        Namespace: vigra</span>
<a name="l00585"></a>00585 <span class="comment">    */</span>
<a name="l00586"></a>00586 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00587"></a><a class="code" href="group__MathFunctions.html#gab97607c505b78dde9e45ce4f11ad20ea">00587</a> <span class="keyword">inline</span> T1 <a class="code" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74" title="The sign function.">sign</a>(T1 t1, T2 t2) 
<a name="l00588"></a>00588 { 
<a name="l00589"></a>00589     <span class="keywordflow">return</span> t2 &gt;= NumericTraits&lt;T2&gt;::zero()
<a name="l00590"></a>00590                ? <a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(t1)
<a name="l00591"></a>00591                : -<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(t1);
<a name="l00592"></a>00592 }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="preprocessor">#ifdef DOXYGEN // only for documentation</span>
<a name="l00596"></a>00596 <span class="preprocessor"></span><span class="comment">    /** \brief Check if an integer is even.</span>
<a name="l00597"></a>00597 <span class="comment"></span>
<a name="l00598"></a>00598 <span class="comment">        Defined for all integral types.</span>
<a name="l00599"></a>00599 <span class="comment">    */</span>
<a name="l00600"></a>00600 <span class="keywordtype">bool</span> <a class="code" href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115" title="Check if an integer is even.">even</a>(<span class="keywordtype">int</span> t);
<a name="l00601"></a>00601 <span class="comment"></span>
<a name="l00602"></a>00602 <span class="comment">    /** \brief Check if an integer is odd.</span>
<a name="l00603"></a>00603 <span class="comment"></span>
<a name="l00604"></a>00604 <span class="comment">        Defined for all integral types.</span>
<a name="l00605"></a>00605 <span class="comment">    */</span>
<a name="l00606"></a>00606 <span class="keywordtype">bool</span> <a class="code" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145" title="Check if an integer is odd.">odd</a>(<span class="keywordtype">int</span> t);
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 <span class="preprocessor">#endif</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span>
<a name="l00610"></a>00610 <span class="preprocessor">#define VIGRA_DEFINE_ODD_EVEN(T) \</span>
<a name="l00611"></a>00611 <span class="preprocessor">    inline bool even(T t) { return (t&amp;1) == 0; } \</span>
<a name="l00612"></a>00612 <span class="preprocessor">    inline bool odd(T t)  { return (t&amp;1) == 1; }</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span>
<a name="l00614"></a>00614 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">char</span>)
<a name="l00615"></a>00615 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">short</span>)
<a name="l00616"></a>00616 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">int</span>)
<a name="l00617"></a>00617 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">long</span>)
<a name="l00618"></a>00618 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00619"></a>00619 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)
<a name="l00620"></a>00620 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)
<a name="l00621"></a>00621 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)
<a name="l00622"></a>00622 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)
<a name="l00623"></a>00623 VIGRA_DEFINE_ODD_EVEN(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="preprocessor">#undef VIGRA_DEFINE_ODD_EVEN</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span>
<a name="l00627"></a>00627 <span class="preprocessor">#define VIGRA_DEFINE_NORM(T) \</span>
<a name="l00628"></a>00628 <span class="preprocessor">    inline NormTraits&lt;T&gt;::SquaredNormType squaredNorm(T t) { return sq(t); } \</span>
<a name="l00629"></a>00629 <span class="preprocessor">    inline NormTraits&lt;T&gt;::NormType norm(T t) { return abs(t); }</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span>
<a name="l00631"></a>00631 VIGRA_DEFINE_NORM(<span class="keywordtype">bool</span>)
<a name="l00632"></a>00632 VIGRA_DEFINE_NORM(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)
<a name="l00633"></a>00633 VIGRA_DEFINE_NORM(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)
<a name="l00634"></a>00634 VIGRA_DEFINE_NORM(<span class="keywordtype">short</span>)
<a name="l00635"></a>00635 VIGRA_DEFINE_NORM(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)
<a name="l00636"></a>00636 VIGRA_DEFINE_NORM(<span class="keywordtype">int</span>)
<a name="l00637"></a>00637 VIGRA_DEFINE_NORM(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)
<a name="l00638"></a>00638 VIGRA_DEFINE_NORM(<span class="keywordtype">long</span>)
<a name="l00639"></a>00639 VIGRA_DEFINE_NORM(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)
<a name="l00640"></a>00640 VIGRA_DEFINE_NORM(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00641"></a>00641 VIGRA_DEFINE_NORM(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l00642"></a>00642 VIGRA_DEFINE_NORM(<span class="keywordtype">float</span>)
<a name="l00643"></a>00643 VIGRA_DEFINE_NORM(<span class="keywordtype">double</span>)
<a name="l00644"></a>00644 VIGRA_DEFINE_NORM(<span class="keywordtype">long</span> <span class="keywordtype">double</span>)
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 <span class="preprocessor">#undef VIGRA_DEFINE_NORM</span>
<a name="l00647"></a>00647 <span class="preprocessor"></span>
<a name="l00648"></a>00648 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00649"></a>00649 <span class="keyword">inline</span> <span class="keyword">typename</span> NormTraits&lt;std::complex&lt;T&gt; &gt;::SquaredNormType
<a name="l00650"></a>00650 <a class="code" href="group__FFTWComplexOperators.html#ga484df995dad9821aac02ec42cd58f7eb" title="squared norm (= squared magnitude)">squaredNorm</a>(std::complex&lt;T&gt; <span class="keyword">const</span> &amp; t)
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(t.real()) + <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(t.imag());
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 <span class="preprocessor">#ifdef DOXYGEN // only for documentation</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span><span class="comment">    /** \brief The squared norm of a numerical object.</span>
<a name="l00657"></a>00657 <span class="comment"></span>
<a name="l00658"></a>00658 <span class="comment">        &lt;ul&gt;</span>
<a name="l00659"></a>00659 <span class="comment">        &lt;li&gt;For scalar types: equals &lt;tt&gt;vigra::sq(t)&lt;/tt&gt;.</span>
<a name="l00660"></a>00660 <span class="comment">        &lt;li&gt;For vectorial types (including TinyVector): equals &lt;tt&gt;vigra::dot(t, t)&lt;/tt&gt;.</span>
<a name="l00661"></a>00661 <span class="comment">        &lt;li&gt;For complex number types: equals &lt;tt&gt;vigra::sq(t.real()) + vigra::sq(t.imag())&lt;/tt&gt;.</span>
<a name="l00662"></a>00662 <span class="comment">        &lt;li&gt;For array and matrix types: results in the squared Frobenius norm (sum of squares of the matrix elements).</span>
<a name="l00663"></a>00663 <span class="comment">        &lt;/ul&gt;</span>
<a name="l00664"></a>00664 <span class="comment">    */</span>
<a name="l00665"></a>00665 NormTraits&lt;T&gt;::SquaredNormType <a class="code" href="group__FFTWComplexOperators.html#ga484df995dad9821aac02ec42cd58f7eb" title="squared norm (= squared magnitude)">squaredNorm</a>(T <span class="keyword">const</span> &amp; t);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="preprocessor">#endif</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00669"></a>00669 <span class="comment">    /** \brief The norm of a numerical object.</span>
<a name="l00670"></a>00670 <span class="comment"></span>
<a name="l00671"></a>00671 <span class="comment">        For scalar types: implemented as &lt;tt&gt;abs(t)&lt;/tt&gt;&lt;br&gt;</span>
<a name="l00672"></a>00672 <span class="comment">        otherwise: implemented as &lt;tt&gt;sqrt(squaredNorm(t))&lt;/tt&gt;.</span>
<a name="l00673"></a>00673 <span class="comment"></span>
<a name="l00674"></a>00674 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00675"></a>00675 <span class="comment">        Namespace: vigra</span>
<a name="l00676"></a>00676 <span class="comment">    */</span>
<a name="l00677"></a>00677 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00678"></a>00678 <span class="keyword">inline</span> <span class="keyword">typename</span> NormTraits&lt;T&gt;::NormType 
<a name="l00679"></a><a class="code" href="group__MathFunctions.html#ga794eb2a920016363c5e9653b6b2b6eb2">00679</a> <a class="code" href="group__FFTWComplexOperators.html#ga396baa79e8bd78a178597d32d5152041" title="norm (= magnitude)">norm</a>(T <span class="keyword">const</span> &amp; t)
<a name="l00680"></a>00680 {
<a name="l00681"></a>00681     <span class="keyword">typedef</span> <span class="keyword">typename</span> NormTraits&lt;T&gt;::SquaredNormType SNT;
<a name="l00682"></a>00682     <span class="keywordflow">return</span> <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">sqrt</a>(<span class="keyword">static_cast&lt;</span>typename SquareRootTraits&lt;SNT&gt;::SquareRootArgument<span class="keyword">&gt;</span>(<a class="code" href="group__FFTWComplexOperators.html#ga484df995dad9821aac02ec42cd58f7eb" title="squared norm (= squared magnitude)">squaredNorm</a>(t)));
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 <span class="comment"></span>
<a name="l00685"></a>00685 <span class="comment">    /** \brief Compute the eigenvalues of a 2x2 real symmetric matrix.</span>
<a name="l00686"></a>00686 <span class="comment">      </span>
<a name="l00687"></a>00687 <span class="comment">        This uses the analytical eigenvalue formula </span>
<a name="l00688"></a>00688 <span class="comment">        \f[</span>
<a name="l00689"></a>00689 <span class="comment">           \lambda_{1,2} = \frac{1}{2}\left(a_{00} + a_{11} \pm \sqrt{(a_{00} - a_{11})^2 + 4 a_{01}^2}\right)</span>
<a name="l00690"></a>00690 <span class="comment">        \f]</span>
<a name="l00691"></a>00691 <span class="comment">      </span>
<a name="l00692"></a>00692 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00693"></a>00693 <span class="comment">        Namespace: vigra</span>
<a name="l00694"></a>00694 <span class="comment">    */</span>
<a name="l00695"></a>00695 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00696"></a><a class="code" href="group__MathFunctions.html#ga9210561d31f03b4fa1656bafc7182c0b">00696</a> <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga9210561d31f03b4fa1656bafc7182c0b" title="Compute the eigenvalues of a 2x2 real symmetric matrix.">symmetric2x2Eigenvalues</a>(T a00, T a01, T a11, T * r0, T * r1)
<a name="l00697"></a>00697 {
<a name="l00698"></a>00698     <span class="keywordtype">double</span> d  = <a class="code" href="group__FixedPoint16Operations.html#gac462ab7aeaeaa2af19c524e89c9ee1fd" title="Length of hypotenuse.">hypot</a>(a00 - a11, 2.0*a01);
<a name="l00699"></a>00699     *r0 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.5*(a00 + a11 + d));
<a name="l00700"></a>00700     *r1 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(0.5*(a00 + a11 - d));
<a name="l00701"></a>00701     <span class="keywordflow">if</span>(*r0 &lt; *r1)
<a name="l00702"></a>00702         std::swap(*r0, *r1);
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 <span class="comment"></span>
<a name="l00705"></a>00705 <span class="comment">    /** \brief Compute the eigenvalues of a 3x3 real symmetric matrix.</span>
<a name="l00706"></a>00706 <span class="comment">        </span>
<a name="l00707"></a>00707 <span class="comment">        This uses a numerically stable version of the analytical eigenvalue formula according to</span>
<a name="l00708"></a>00708 <span class="comment">        &lt;p&gt;</span>
<a name="l00709"></a>00709 <span class="comment">        David Eberly: &lt;a href=&quot;http://www.geometrictools.com/Documentation/EigenSymmetric3x3.pdf&quot;&gt;</span>
<a name="l00710"></a>00710 <span class="comment">        &lt;em&gt;&quot;Eigensystems for 3  3 Symmetric Matrices (Revisited)&quot;&lt;/em&gt;&lt;/a&gt;, Geometric Tools Documentation, 2006</span>
<a name="l00711"></a>00711 <span class="comment">        </span>
<a name="l00712"></a>00712 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00713"></a>00713 <span class="comment">        Namespace: vigra</span>
<a name="l00714"></a>00714 <span class="comment">    */</span>
<a name="l00715"></a>00715 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00716"></a><a class="code" href="group__MathFunctions.html#ga2c49eca66b2ba5c308d04fa324dcc230">00716</a> <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga2c49eca66b2ba5c308d04fa324dcc230" title="Compute the eigenvalues of a 3x3 real symmetric matrix.">symmetric3x3Eigenvalues</a>(T a00, T a01, T a02, T a11, T a12, T a22,
<a name="l00717"></a>00717                              T * r0, T * r1, T * r2)
<a name="l00718"></a>00718 {
<a name="l00719"></a>00719     <span class="keywordtype">double</span> inv3 = 1.0 / 3.0, root3 = <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">std::sqrt</a>(3.0);
<a name="l00720"></a>00720     
<a name="l00721"></a>00721     <span class="keywordtype">double</span> c0 = a00*a11*a22 + 2.0*a01*a02*a12 - a00*a12*a12 - a11*a02*a02 - a22*a01*a01;
<a name="l00722"></a>00722     <span class="keywordtype">double</span> c1 = a00*a11 - a01*a01 + a00*a22 - a02*a02 + a11*a22 - a12*a12;
<a name="l00723"></a>00723     <span class="keywordtype">double</span> c2 = a00 + a11 + a22;
<a name="l00724"></a>00724     <span class="keywordtype">double</span> c2Div3 = c2*inv3;
<a name="l00725"></a>00725     <span class="keywordtype">double</span> aDiv3 = (c1 - c2*c2Div3)*inv3;
<a name="l00726"></a>00726     <span class="keywordflow">if</span> (aDiv3 &gt; 0.0) 
<a name="l00727"></a>00727         aDiv3 = 0.0;
<a name="l00728"></a>00728     <span class="keywordtype">double</span> mbDiv2 = 0.5*(c0 + c2Div3*(2.0*c2Div3*c2Div3 - c1));
<a name="l00729"></a>00729     <span class="keywordtype">double</span> q = mbDiv2*mbDiv2 + aDiv3*aDiv3*aDiv3;
<a name="l00730"></a>00730     <span class="keywordflow">if</span> (q &gt; 0.0) 
<a name="l00731"></a>00731         q = 0.0;
<a name="l00732"></a>00732     <span class="keywordtype">double</span> magnitude = <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">std::sqrt</a>(-aDiv3);
<a name="l00733"></a>00733     <span class="keywordtype">double</span> angle = <a class="code" href="group__FixedPoint16Operations.html#gae83e1ae2e3dae6dc462c69a7c8175fc5" title="Arctangent. Accuracy better than 1/3 degree (9 significant bits).">std::atan2</a>(<a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">std::sqrt</a>(-q),mbDiv2)*inv3;
<a name="l00734"></a>00734     <span class="keywordtype">double</span> cs = <a class="code" href="group__LinearAlgebraFunctions.html#ga05727ffc201ac332c0e4158a2267c08c">std::cos</a>(angle);
<a name="l00735"></a>00735     <span class="keywordtype">double</span> sn = <a class="code" href="group__LinearAlgebraFunctions.html#ga9db90484f9146df72b800bab7fecdd4b">std::sin</a>(angle);
<a name="l00736"></a>00736     *r0 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(c2Div3 + 2.0*magnitude*cs);
<a name="l00737"></a>00737     *r1 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(c2Div3 - magnitude*(cs + root3*sn));
<a name="l00738"></a>00738     *r2 = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(c2Div3 - magnitude*(cs - root3*sn));
<a name="l00739"></a>00739     <span class="keywordflow">if</span>(*r0 &lt; *r1)
<a name="l00740"></a>00740         std::swap(*r0, *r1);
<a name="l00741"></a>00741     <span class="keywordflow">if</span>(*r0 &lt; *r2)
<a name="l00742"></a>00742         std::swap(*r0, *r2);
<a name="l00743"></a>00743     <span class="keywordflow">if</span>(*r1 &lt; *r2)
<a name="l00744"></a>00744         std::swap(*r1, *r2);
<a name="l00745"></a>00745 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="keyword">namespace </span>detail {
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00750"></a>00750 T ellipticRD(T x, T y, T z)
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752     <span class="keywordtype">double</span> f = 1.0, s = 0.0, X, Y, Z, m;
<a name="l00753"></a>00753     <span class="keywordflow">for</span>(;;)
<a name="l00754"></a>00754     {
<a name="l00755"></a>00755         m = (x + y + 3.0*z) / 5.0;
<a name="l00756"></a>00756         X = 1.0 - x/m;
<a name="l00757"></a>00757         Y = 1.0 - y/m;
<a name="l00758"></a>00758         Z = 1.0 - z/m;
<a name="l00759"></a>00759         <span class="keywordflow">if</span>(std::max(std::max(VIGRA_CSTD::fabs(X), VIGRA_CSTD::fabs(Y)), VIGRA_CSTD::fabs(Z)) &lt; 0.01)
<a name="l00760"></a>00760             <span class="keywordflow">break</span>;
<a name="l00761"></a>00761         <span class="keywordtype">double</span> l = <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(x*y) + <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(x*z) + <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(y*z);
<a name="l00762"></a>00762         s += f / (<a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(z)*(z + l));
<a name="l00763"></a>00763         f /= 4.0;
<a name="l00764"></a>00764         x = (x + l)/4.0;
<a name="l00765"></a>00765         y = (y + l)/4.0;
<a name="l00766"></a>00766         z = (z + l)/4.0;
<a name="l00767"></a>00767     }
<a name="l00768"></a>00768     <span class="keywordtype">double</span> a = X*Y;
<a name="l00769"></a>00769     <span class="keywordtype">double</span> b = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(Z);
<a name="l00770"></a>00770     <span class="keywordtype">double</span> c = a - b;
<a name="l00771"></a>00771     <span class="keywordtype">double</span> d = a - 6.0*b;
<a name="l00772"></a>00772     <span class="keywordtype">double</span> e = d + 2.0*c;
<a name="l00773"></a>00773     <span class="keywordflow">return</span> 3.0*s + f*(1.0+d*(-3.0/14.0+d*9.0/88.0-Z*e*4.5/26.0)
<a name="l00774"></a>00774                       +Z*(e/6.0+Z*(-c*9.0/22.0+a*Z*3.0/26.0))) / VIGRA_CSTD::pow(m,1.5);
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00778"></a>00778 T ellipticRF(T x, T y, T z)
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780     <span class="keywordtype">double</span> X, Y, Z, m;
<a name="l00781"></a>00781     <span class="keywordflow">for</span>(;;)
<a name="l00782"></a>00782     {
<a name="l00783"></a>00783         m = (x + y + z) / 3.0;
<a name="l00784"></a>00784         X = 1.0 - x/m;
<a name="l00785"></a>00785         Y = 1.0 - y/m;
<a name="l00786"></a>00786         Z = 1.0 - z/m;
<a name="l00787"></a>00787         <span class="keywordflow">if</span>(std::max(std::max(VIGRA_CSTD::fabs(X), VIGRA_CSTD::fabs(Y)), VIGRA_CSTD::fabs(Z)) &lt; 0.01)
<a name="l00788"></a>00788             <span class="keywordflow">break</span>;
<a name="l00789"></a>00789         <span class="keywordtype">double</span> l = <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(x*y) + <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(x*z) + <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(y*z);
<a name="l00790"></a>00790         x = (x + l)/4.0;
<a name="l00791"></a>00791         y = (y + l)/4.0;
<a name="l00792"></a>00792         z = (z + l)/4.0;
<a name="l00793"></a>00793     }
<a name="l00794"></a>00794     <span class="keywordtype">double</span> d = X*Y - <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(Z);
<a name="l00795"></a>00795     <span class="keywordtype">double</span> p = X*Y*Z;
<a name="l00796"></a>00796     <span class="keywordflow">return</span> (1.0 - d/10.0 + p/14.0 + <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(d)/24.0 - d*p*3.0/44.0) / <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(m);
<a name="l00797"></a>00797 }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 } <span class="comment">// namespace detail</span>
<a name="l00800"></a>00800 <span class="comment"></span>
<a name="l00801"></a>00801 <span class="comment">    /** \brief The incomplete elliptic integral of the first kind.</span>
<a name="l00802"></a>00802 <span class="comment">    </span>
<a name="l00803"></a>00803 <span class="comment">        This function computes</span>
<a name="l00804"></a>00804 <span class="comment"></span>
<a name="l00805"></a>00805 <span class="comment">        \f[</span>
<a name="l00806"></a>00806 <span class="comment">             \mbox{F}(x, k) = \int_0^x \frac{1}{\sqrt{1 - k^2 \sin(t)^2}} dt</span>
<a name="l00807"></a>00807 <span class="comment">        \f]</span>
<a name="l00808"></a>00808 <span class="comment">  </span>
<a name="l00809"></a>00809 <span class="comment">        according to the algorithm given in Press et al. &quot;Numerical Recipes&quot;. </span>
<a name="l00810"></a>00810 <span class="comment"></span>
<a name="l00811"></a>00811 <span class="comment">        Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral</span>
<a name="l00812"></a>00812 <span class="comment">        functions must be k^2 rather than k. Check the documentation when results disagree!</span>
<a name="l00813"></a>00813 <span class="comment"></span>
<a name="l00814"></a>00814 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00815"></a>00815 <span class="comment">        Namespace: vigra</span>
<a name="l00816"></a>00816 <span class="comment">    */</span>
<a name="l00817"></a><a class="code" href="group__MathFunctions.html#ga7e909bd1d07e846d5d3ba78eaed7c520">00817</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#ga7e909bd1d07e846d5d3ba78eaed7c520" title="The incomplete elliptic integral of the first kind.">ellipticIntegralF</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> k)
<a name="l00818"></a>00818 {
<a name="l00819"></a>00819     <span class="keywordtype">double</span> c2 = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(<a class="code" href="group__LinearAlgebraFunctions.html#ga05727ffc201ac332c0e4158a2267c08c">VIGRA_CSTD::cos</a>(x));
<a name="l00820"></a>00820     <span class="keywordtype">double</span> s = <a class="code" href="group__LinearAlgebraFunctions.html#ga9db90484f9146df72b800bab7fecdd4b">VIGRA_CSTD::sin</a>(x);
<a name="l00821"></a>00821     <span class="keywordflow">return</span> s*detail::ellipticRF(c2, 1.0 - <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(k*s), 1.0);
<a name="l00822"></a>00822 }
<a name="l00823"></a>00823 <span class="comment"></span>
<a name="l00824"></a>00824 <span class="comment">    /** \brief The incomplete elliptic integral of the second kind.</span>
<a name="l00825"></a>00825 <span class="comment">      </span>
<a name="l00826"></a>00826 <span class="comment">        This function computes</span>
<a name="l00827"></a>00827 <span class="comment">      </span>
<a name="l00828"></a>00828 <span class="comment">        \f[</span>
<a name="l00829"></a>00829 <span class="comment">            \mbox{E}(x, k) = \int_0^x \sqrt{1 - k^2 \sin(t)^2} dt</span>
<a name="l00830"></a>00830 <span class="comment">        \f]</span>
<a name="l00831"></a>00831 <span class="comment">      </span>
<a name="l00832"></a>00832 <span class="comment">        according to the algorithm given in Press et al. &quot;Numerical Recipes&quot;. The</span>
<a name="l00833"></a>00833 <span class="comment">        complete elliptic integral of the second kind is simply &lt;tt&gt;ellipticIntegralE(M_PI/2, k)&lt;/TT&gt;.</span>
<a name="l00834"></a>00834 <span class="comment">      </span>
<a name="l00835"></a>00835 <span class="comment">        Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral</span>
<a name="l00836"></a>00836 <span class="comment">        functions must be k^2 rather than k. Check the documentation when results disagree!</span>
<a name="l00837"></a>00837 <span class="comment">      </span>
<a name="l00838"></a>00838 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00839"></a>00839 <span class="comment">        Namespace: vigra</span>
<a name="l00840"></a>00840 <span class="comment">    */</span>
<a name="l00841"></a><a class="code" href="group__MathFunctions.html#ga29d6193bd95ec54c5f25dd0470f58215">00841</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#ga29d6193bd95ec54c5f25dd0470f58215" title="The incomplete elliptic integral of the second kind.">ellipticIntegralE</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> k)
<a name="l00842"></a>00842 {
<a name="l00843"></a>00843     <span class="keywordtype">double</span> c2 = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(<a class="code" href="group__LinearAlgebraFunctions.html#ga05727ffc201ac332c0e4158a2267c08c">VIGRA_CSTD::cos</a>(x));
<a name="l00844"></a>00844     <span class="keywordtype">double</span> s = <a class="code" href="group__LinearAlgebraFunctions.html#ga9db90484f9146df72b800bab7fecdd4b">VIGRA_CSTD::sin</a>(x);
<a name="l00845"></a>00845     k = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(k*s);
<a name="l00846"></a>00846     <span class="keywordflow">return</span> s*(detail::ellipticRF(c2, 1.0-k, 1.0) - k/3.0*detail::ellipticRD(c2, 1.0-k, 1.0));
<a name="l00847"></a>00847 }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00850"></a>00850 <span class="preprocessor"></span>
<a name="l00851"></a>00851 <span class="keyword">namespace </span>detail {
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00854"></a>00854 <span class="keywordtype">double</span> erfImpl(T x)
<a name="l00855"></a>00855 {
<a name="l00856"></a>00856     <span class="keywordtype">double</span> t = 1.0/(1.0+0.5*VIGRA_CSTD::fabs(x));
<a name="l00857"></a>00857     <span class="keywordtype">double</span> ans = t*<a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">VIGRA_CSTD::exp</a>(-x*x-1.26551223+t*(1.00002368+t*(0.37409196+
<a name="l00858"></a>00858                                     t*(0.09678418+t*(-0.18628806+t*(0.27886807+
<a name="l00859"></a>00859                                     t*(-1.13520398+t*(1.48851587+t*(-0.82215223+
<a name="l00860"></a>00860                                     t*0.17087277)))))))));
<a name="l00861"></a>00861     <span class="keywordflow">if</span> (x &gt;= 0.0)
<a name="l00862"></a>00862         <span class="keywordflow">return</span> 1.0 - ans;
<a name="l00863"></a>00863     <span class="keywordflow">else</span>
<a name="l00864"></a>00864         <span class="keywordflow">return</span> ans - 1.0;
<a name="l00865"></a>00865 }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 } <span class="comment">// namespace detail </span>
<a name="l00868"></a>00868 <span class="comment"></span>
<a name="l00869"></a>00869 <span class="comment">    /** \brief The error function.</span>
<a name="l00870"></a>00870 <span class="comment"></span>
<a name="l00871"></a>00871 <span class="comment">        If &lt;tt&gt;erf()&lt;/tt&gt; is not provided in the C standard math library (as it should according to the</span>
<a name="l00872"></a>00872 <span class="comment">        new C99 standard ?), VIGRA implements &lt;tt&gt;erf()&lt;/tt&gt; as an approximation of the error </span>
<a name="l00873"></a>00873 <span class="comment">        function</span>
<a name="l00874"></a>00874 <span class="comment">        </span>
<a name="l00875"></a>00875 <span class="comment">        \f[</span>
<a name="l00876"></a>00876 <span class="comment">            \mbox{erf}(x) = \int_0^x e^{-t^2} dt</span>
<a name="l00877"></a>00877 <span class="comment">        \f]</span>
<a name="l00878"></a>00878 <span class="comment">        </span>
<a name="l00879"></a>00879 <span class="comment">        according to the formula given in Press et al. &quot;Numerical Recipes&quot;.</span>
<a name="l00880"></a>00880 <span class="comment"></span>
<a name="l00881"></a>00881 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l00882"></a>00882 <span class="comment">        Namespace: vigra</span>
<a name="l00883"></a>00883 <span class="comment">    */</span>
<a name="l00884"></a>00884 <span class="keyword">inline</span> <span class="keywordtype">double</span> erf(<span class="keywordtype">double</span> x)
<a name="l00885"></a>00885 {
<a name="l00886"></a>00886     <span class="keywordflow">return</span> detail::erfImpl(x);
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="preprocessor">#else</span>
<a name="l00890"></a>00890 <span class="preprocessor"></span>
<a name="l00891"></a>00891 using ::erf;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893 <span class="preprocessor">#endif</span>
<a name="l00894"></a>00894 <span class="preprocessor"></span>
<a name="l00895"></a>00895 <span class="keyword">namespace </span>detail {
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00898"></a>00898 <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb" title="Cumulative non-central chi square distribution (approximate).">noncentralChi2CDFApprox</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, T noncentrality, T <a class="code" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d" title="pahse">arg</a>)
<a name="l00899"></a>00899 {
<a name="l00900"></a>00900     <span class="keywordtype">double</span> a = degreesOfFreedom + noncentrality;
<a name="l00901"></a>00901     <span class="keywordtype">double</span> b = (a + noncentrality) / <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(a);
<a name="l00902"></a>00902     <span class="keywordtype">double</span> t = (VIGRA_CSTD::pow((<span class="keywordtype">double</span>)arg / a, 1.0/3.0) - (1.0 - 2.0 / 9.0 * b)) / <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(2.0 / 9.0 * b);
<a name="l00903"></a>00903     <span class="keywordflow">return</span> 0.5*(1.0 + erf(t/<a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(2.0)));
<a name="l00904"></a>00904 }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00907"></a>00907 <span class="keywordtype">void</span> noncentralChi2OneIteration(T arg, T &amp; lans, T &amp; dans, T &amp; pans, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; j)
<a name="l00908"></a>00908 {
<a name="l00909"></a>00909     <span class="keywordtype">double</span> tol = -50.0;
<a name="l00910"></a>00910     <span class="keywordflow">if</span>(lans &lt; tol)
<a name="l00911"></a>00911     {
<a name="l00912"></a>00912         lans = lans + <a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">VIGRA_CSTD::log</a>(arg / j);
<a name="l00913"></a>00913         dans = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">VIGRA_CSTD::exp</a>(lans);
<a name="l00914"></a>00914     }
<a name="l00915"></a>00915     <span class="keywordflow">else</span>
<a name="l00916"></a>00916     {
<a name="l00917"></a>00917         dans = dans * arg / j;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919     pans = pans - dans;
<a name="l00920"></a>00920     j += 2;
<a name="l00921"></a>00921 }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00924"></a>00924 std::pair&lt;double, double&gt; <a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">noncentralChi2CDF</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, T noncentrality, T arg, T eps)
<a name="l00925"></a>00925 {
<a name="l00926"></a>00926     vigra_precondition(noncentrality &gt;= 0.0 &amp;&amp; arg &gt;= 0.0 &amp;&amp; eps &gt; 0.0,
<a name="l00927"></a>00927         <span class="stringliteral">&quot;noncentralChi2P(): parameters must be positive.&quot;</span>);
<a name="l00928"></a>00928     <span class="keywordflow">if</span> (arg == 0.0 &amp;&amp; degreesOfFreedom &gt; 0)
<a name="l00929"></a>00929         <span class="keywordflow">return</span> std::make_pair(0.0, 0.0);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="comment">// Determine initial values</span>
<a name="l00932"></a>00932     <span class="keywordtype">double</span> b1 = 0.5 * noncentrality,
<a name="l00933"></a>00933            ao = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">VIGRA_CSTD::exp</a>(-b1),
<a name="l00934"></a>00934            eps2 = eps / ao,
<a name="l00935"></a>00935            lnrtpi2 = 0.22579135264473,
<a name="l00936"></a>00936            probability, density, lans, dans, pans, <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a>, am, hold;
<a name="l00937"></a>00937     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxit = 500,
<a name="l00938"></a>00938         i, m;
<a name="l00939"></a>00939     <span class="keywordflow">if</span>(degreesOfFreedom % 2)
<a name="l00940"></a>00940     {
<a name="l00941"></a>00941         i = 1;
<a name="l00942"></a>00942         lans = -0.5 * (arg + <a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">VIGRA_CSTD::log</a>(arg)) - lnrtpi2;
<a name="l00943"></a>00943         dans = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">VIGRA_CSTD::exp</a>(lans);
<a name="l00944"></a>00944         pans = erf(<a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">VIGRA_CSTD::sqrt</a>(arg/2.0));
<a name="l00945"></a>00945     }
<a name="l00946"></a>00946     <span class="keywordflow">else</span>
<a name="l00947"></a>00947     {
<a name="l00948"></a>00948         i = 2;
<a name="l00949"></a>00949         lans = -0.5 * <a class="code" href="group__FFTWComplexOperators.html#gadde71f2f7d25b483924dedacc36b2b2d" title="pahse">arg</a>;
<a name="l00950"></a>00950         dans = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">VIGRA_CSTD::exp</a>(lans);
<a name="l00951"></a>00951         pans = 1.0 - dans;
<a name="l00952"></a>00952     }
<a name="l00953"></a>00953     
<a name="l00954"></a>00954     <span class="comment">// Evaluate first term</span>
<a name="l00955"></a>00955     <span class="keywordflow">if</span>(degreesOfFreedom == 0)
<a name="l00956"></a>00956     {
<a name="l00957"></a>00957         m = 1;
<a name="l00958"></a>00958         degreesOfFreedom = 2;
<a name="l00959"></a>00959         am = b1;
<a name="l00960"></a>00960         sum = 1.0 / ao - 1.0 - am;
<a name="l00961"></a>00961         density = am * dans;
<a name="l00962"></a>00962         probability = 1.0 + am * pans;
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964     <span class="keywordflow">else</span>
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966         m = 0;
<a name="l00967"></a>00967         degreesOfFreedom = degreesOfFreedom - 1;
<a name="l00968"></a>00968         am = 1.0;
<a name="l00969"></a>00969         sum = 1.0 / ao - 1.0;
<a name="l00970"></a>00970         <span class="keywordflow">while</span>(i &lt; degreesOfFreedom)
<a name="l00971"></a>00971             detail::noncentralChi2OneIteration(arg, lans, dans, pans, i);
<a name="l00972"></a>00972         degreesOfFreedom = degreesOfFreedom + 1;
<a name="l00973"></a>00973         density = dans;
<a name="l00974"></a>00974         probability = pans;
<a name="l00975"></a>00975     }
<a name="l00976"></a>00976     <span class="comment">// Evaluate successive terms of the expansion</span>
<a name="l00977"></a>00977     <span class="keywordflow">for</span>(++m; m&lt;maxit; ++m)
<a name="l00978"></a>00978     {
<a name="l00979"></a>00979         am = b1 * am / m;
<a name="l00980"></a>00980         detail::noncentralChi2OneIteration(arg, lans, dans, pans, degreesOfFreedom);
<a name="l00981"></a>00981         sum = sum - am;
<a name="l00982"></a>00982         density = density + am * dans;
<a name="l00983"></a>00983         hold = am * pans;
<a name="l00984"></a>00984         probability = probability + hold;
<a name="l00985"></a>00985         <span class="keywordflow">if</span>((pans * sum &lt; eps2) &amp;&amp; (hold &lt; eps2))
<a name="l00986"></a>00986             <span class="keywordflow">break</span>; <span class="comment">// converged</span>
<a name="l00987"></a>00987     }
<a name="l00988"></a>00988     <span class="keywordflow">if</span>(m == maxit)
<a name="l00989"></a>00989         vigra_fail(<span class="stringliteral">&quot;noncentralChi2P(): no convergence.&quot;</span>);
<a name="l00990"></a>00990     <span class="keywordflow">return</span> std::make_pair(0.5 * ao * density, std::min(1.0, std::max(0.0, ao * probability)));
<a name="l00991"></a>00991 }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 } <span class="comment">// namespace detail</span>
<a name="l00994"></a>00994 <span class="comment"></span>
<a name="l00995"></a>00995 <span class="comment">    /** \brief Chi square distribution. </span>
<a name="l00996"></a>00996 <span class="comment"></span>
<a name="l00997"></a>00997 <span class="comment">        Computes the density of a chi square distribution with \a degreesOfFreedom </span>
<a name="l00998"></a>00998 <span class="comment">        and tolerance \a accuracy at the given argument \a arg</span>
<a name="l00999"></a>00999 <span class="comment">        by calling &lt;tt&gt;noncentralChi2(degreesOfFreedom, 0.0, arg, accuracy)&lt;/tt&gt;.</span>
<a name="l01000"></a>01000 <span class="comment"></span>
<a name="l01001"></a>01001 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01002"></a>01002 <span class="comment">        Namespace: vigra</span>
<a name="l01003"></a>01003 <span class="comment">    */</span>
<a name="l01004"></a><a class="code" href="group__MathFunctions.html#ga0f6a2804ceaf785495472fb9bf2dd5bc">01004</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#ga0f6a2804ceaf785495472fb9bf2dd5bc" title="Chi square distribution.">chi2</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, <span class="keywordtype">double</span> arg, <span class="keywordtype">double</span> accuracy = 1e-7)
<a name="l01005"></a>01005 {
<a name="l01006"></a>01006     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">detail::noncentralChi2CDF</a>(degreesOfFreedom, 0.0, arg, accuracy).first;
<a name="l01007"></a>01007 }
<a name="l01008"></a>01008 <span class="comment"></span>
<a name="l01009"></a>01009 <span class="comment">    /** \brief Cumulative chi square distribution. </span>
<a name="l01010"></a>01010 <span class="comment"></span>
<a name="l01011"></a>01011 <span class="comment">        Computes the cumulative density of a chi square distribution with \a degreesOfFreedom </span>
<a name="l01012"></a>01012 <span class="comment">        and tolerance \a accuracy at the given argument \a arg, i.e. the probability that</span>
<a name="l01013"></a>01013 <span class="comment">        a random number drawn from the distribution is below \a arg</span>
<a name="l01014"></a>01014 <span class="comment">        by calling &lt;tt&gt;noncentralChi2CDF(degreesOfFreedom, 0.0, arg, accuracy)&lt;/tt&gt;.</span>
<a name="l01015"></a>01015 <span class="comment"></span>
<a name="l01016"></a>01016 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01017"></a>01017 <span class="comment">        Namespace: vigra</span>
<a name="l01018"></a>01018 <span class="comment">    */</span>
<a name="l01019"></a><a class="code" href="group__MathFunctions.html#gaa94c7af27b4aecda8a764beb89dbc2a6">01019</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#gaa94c7af27b4aecda8a764beb89dbc2a6" title="Cumulative chi square distribution.">chi2CDF</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, <span class="keywordtype">double</span> arg, <span class="keywordtype">double</span> accuracy = 1e-7)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">detail::noncentralChi2CDF</a>(degreesOfFreedom, 0.0, arg, accuracy).second;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 <span class="comment"></span>
<a name="l01024"></a>01024 <span class="comment">    /** \brief Non-central chi square distribution. </span>
<a name="l01025"></a>01025 <span class="comment"></span>
<a name="l01026"></a>01026 <span class="comment">        Computes the density of a non-central chi square distribution with \a degreesOfFreedom, </span>
<a name="l01027"></a>01027 <span class="comment">        noncentrality parameter \a noncentrality and tolerance \a accuracy at the given argument </span>
<a name="l01028"></a>01028 <span class="comment">        \a arg. It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from </span>
<a name="l01029"></a>01029 <span class="comment">        http://lib.stat.cmu.edu/apstat/231). The algorithm has linear complexity in the number of</span>
<a name="l01030"></a>01030 <span class="comment">        degrees of freedom.</span>
<a name="l01031"></a>01031 <span class="comment"></span>
<a name="l01032"></a>01032 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01033"></a>01033 <span class="comment">        Namespace: vigra</span>
<a name="l01034"></a>01034 <span class="comment">    */</span>
<a name="l01035"></a><a class="code" href="group__MathFunctions.html#ga074ace0a87d00243c85a52e5071a1ad4">01035</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#ga074ace0a87d00243c85a52e5071a1ad4" title="Non-central chi square distribution.">noncentralChi2</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, 
<a name="l01036"></a>01036               <span class="keywordtype">double</span> noncentrality, <span class="keywordtype">double</span> arg, <span class="keywordtype">double</span> accuracy = 1e-7)
<a name="l01037"></a>01037 {
<a name="l01038"></a>01038     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">detail::noncentralChi2CDF</a>(degreesOfFreedom, noncentrality, arg, accuracy).first;
<a name="l01039"></a>01039 }
<a name="l01040"></a>01040 <span class="comment"></span>
<a name="l01041"></a>01041 <span class="comment">    /** \brief Cumulative non-central chi square distribution. </span>
<a name="l01042"></a>01042 <span class="comment"></span>
<a name="l01043"></a>01043 <span class="comment">        Computes the cumulative density of a chi square distribution with \a degreesOfFreedom, </span>
<a name="l01044"></a>01044 <span class="comment">        noncentrality parameter \a noncentrality and tolerance \a accuracy at the given argument </span>
<a name="l01045"></a>01045 <span class="comment">        \a arg, i.e. the probability that a random number drawn from the distribution is below \a arg</span>
<a name="l01046"></a>01046 <span class="comment">        It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from </span>
<a name="l01047"></a>01047 <span class="comment">        http://lib.stat.cmu.edu/apstat/231). The algorithm has linear complexity in the number of</span>
<a name="l01048"></a>01048 <span class="comment">        degrees of freedom (see noncentralChi2CDFApprox() for a constant-time algorithm).</span>
<a name="l01049"></a>01049 <span class="comment"></span>
<a name="l01050"></a>01050 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01051"></a>01051 <span class="comment">        Namespace: vigra</span>
<a name="l01052"></a>01052 <span class="comment">    */</span>
<a name="l01053"></a><a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226">01053</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">noncentralChi2CDF</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, 
<a name="l01054"></a>01054               <span class="keywordtype">double</span> noncentrality, <span class="keywordtype">double</span> arg, <span class="keywordtype">double</span> accuracy = 1e-7)
<a name="l01055"></a>01055 {
<a name="l01056"></a>01056     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution.">detail::noncentralChi2CDF</a>(degreesOfFreedom, noncentrality, arg, accuracy).second;
<a name="l01057"></a>01057 }
<a name="l01058"></a>01058 <span class="comment"></span>
<a name="l01059"></a>01059 <span class="comment">    /** \brief Cumulative non-central chi square distribution (approximate). </span>
<a name="l01060"></a>01060 <span class="comment"></span>
<a name="l01061"></a>01061 <span class="comment">        Computes approximate values of the cumulative density of a chi square distribution with \a degreesOfFreedom, </span>
<a name="l01062"></a>01062 <span class="comment">        and noncentrality parameter \a noncentrality at the given argument </span>
<a name="l01063"></a>01063 <span class="comment">        \a arg, i.e. the probability that a random number drawn from the distribution is below \a arg</span>
<a name="l01064"></a>01064 <span class="comment">        It uses the approximate transform into a normal distribution due to Wilson and Hilferty </span>
<a name="l01065"></a>01065 <span class="comment">        (see Abramovitz, Stegun: &quot;Handbook of Mathematical Functions&quot;, formula 26.3.32). </span>
<a name="l01066"></a>01066 <span class="comment">        The algorithm&#39;s running time is independent of the inputs, i.e. is should be used</span>
<a name="l01067"></a>01067 <span class="comment">        when noncentralChi2CDF() is too slow, and approximate values are sufficient. The accuracy is only </span>
<a name="l01068"></a>01068 <span class="comment">        about 0.1 for few degrees of freedom, but reaches about 0.001 above dof = 5.</span>
<a name="l01069"></a>01069 <span class="comment"></span>
<a name="l01070"></a>01070 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01071"></a>01071 <span class="comment">        Namespace: vigra</span>
<a name="l01072"></a>01072 <span class="comment">    */</span>
<a name="l01073"></a><a class="code" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb">01073</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb" title="Cumulative non-central chi square distribution (approximate).">noncentralChi2CDFApprox</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degreesOfFreedom, <span class="keywordtype">double</span> noncentrality, <span class="keywordtype">double</span> arg)
<a name="l01074"></a>01074 {
<a name="l01075"></a>01075     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb" title="Cumulative non-central chi square distribution (approximate).">detail::noncentralChi2CDFApprox</a>(degreesOfFreedom, noncentrality, arg);
<a name="l01076"></a>01076 }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 <span class="keyword">namespace </span>detail  {
<a name="l01079"></a>01079 
<a name="l01080"></a>01080 <span class="comment">// computes (l+m)! / (l-m)!</span>
<a name="l01081"></a>01081 <span class="comment">// l and m must be positive</span>
<a name="l01082"></a>01082 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01083"></a>01083 T facLM(T l, T m)
<a name="l01084"></a>01084 {
<a name="l01085"></a>01085     T tmp = NumericTraits&lt;T&gt;::one();
<a name="l01086"></a>01086     <span class="keywordflow">for</span>(T f = l-m+1; f &lt;= l+m; ++f)
<a name="l01087"></a>01087         tmp *= f;
<a name="l01088"></a>01088     <span class="keywordflow">return</span> tmp;
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 } <span class="comment">// namespace detail</span>
<a name="l01092"></a>01092 <span class="comment"></span>
<a name="l01093"></a>01093 <span class="comment">    /** \brief Associated Legendre polynomial. </span>
<a name="l01094"></a>01094 <span class="comment"></span>
<a name="l01095"></a>01095 <span class="comment">        Computes the value of the associated Legendre polynomial of order &lt;tt&gt;l, m&lt;/tt&gt; </span>
<a name="l01096"></a>01096 <span class="comment">        for argument &lt;tt&gt;x&lt;/tt&gt;. &lt;tt&gt;x&lt;/tt&gt; must be in the range &lt;tt&gt;[-1.0, 1.0]&lt;/tt&gt;, </span>
<a name="l01097"></a>01097 <span class="comment">        otherwise an exception is thrown. The standard Legendre polynomials are the </span>
<a name="l01098"></a>01098 <span class="comment">        special case &lt;tt&gt;m == 0&lt;/tt&gt;.</span>
<a name="l01099"></a>01099 <span class="comment"></span>
<a name="l01100"></a>01100 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01101"></a>01101 <span class="comment">        Namespace: vigra</span>
<a name="l01102"></a>01102 <span class="comment">    */</span>
<a name="l01103"></a>01103 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01104"></a><a class="code" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b">01104</a> REAL <a class="code" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b" title="Associated Legendre polynomial.">legendre</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l, <span class="keywordtype">int</span> m, REAL x)
<a name="l01105"></a>01105 {
<a name="l01106"></a>01106     vigra_precondition(<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(x) &lt;= 1.0, <span class="stringliteral">&quot;legendre(): x must be in [-1.0, 1.0].&quot;</span>);
<a name="l01107"></a>01107     <span class="keywordflow">if</span> (m &lt; 0)
<a name="l01108"></a>01108     {
<a name="l01109"></a>01109         m = -m;
<a name="l01110"></a>01110         REAL s = <a class="code" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145" title="Check if an integer is odd.">odd</a>(m)
<a name="l01111"></a>01111                    ? -1.0
<a name="l01112"></a>01112                    :  1.0;
<a name="l01113"></a>01113         <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b" title="Associated Legendre polynomial.">legendre</a>(l,m,x) * s / detail::facLM&lt;REAL&gt;(l,m);
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115     REAL result = 1.0;
<a name="l01116"></a>01116     <span class="keywordflow">if</span> (m &gt; 0)
<a name="l01117"></a>01117     {
<a name="l01118"></a>01118         REAL r = <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">std::sqrt</a>( (1.0-x) * (1.0+x) );
<a name="l01119"></a>01119         REAL f = 1.0;
<a name="l01120"></a>01120         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=m; i++)
<a name="l01121"></a>01121         {
<a name="l01122"></a>01122             result *= (-f) * r;
<a name="l01123"></a>01123             f += 2.0;
<a name="l01124"></a>01124         }
<a name="l01125"></a>01125     }
<a name="l01126"></a>01126     <span class="keywordflow">if</span>((<span class="keywordtype">int</span>)l == m) 
<a name="l01127"></a>01127         <span class="keywordflow">return</span> result;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129     REAL result_1 = x * (2.0 * m + 1.0) * result;
<a name="l01130"></a>01130     <span class="keywordflow">if</span>((<span class="keywordtype">int</span>)l == m+1) 
<a name="l01131"></a>01131         <span class="keywordflow">return</span> result_1;
<a name="l01132"></a>01132     REAL other = 0.0;
<a name="l01133"></a>01133     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m+2; i &lt;= l; ++i)
<a name="l01134"></a>01134     {
<a name="l01135"></a>01135         other = ( (2.0*i-1.0) * x * result_1 - (i+m-1.0)*result) / (i-m);
<a name="l01136"></a>01136         result = result_1;
<a name="l01137"></a>01137         result_1 = other;
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139     <span class="keywordflow">return</span> other;
<a name="l01140"></a>01140 }
<a name="l01141"></a>01141 <span class="comment"></span>
<a name="l01142"></a>01142 <span class="comment">    /** \brief \brief Legendre polynomial. </span>
<a name="l01143"></a>01143 <span class="comment"></span>
<a name="l01144"></a>01144 <span class="comment">        Computes the value of the Legendre polynomial of order &lt;tt&gt;l&lt;/tt&gt; for argument &lt;tt&gt;x&lt;/tt&gt;.</span>
<a name="l01145"></a>01145 <span class="comment">        &lt;tt&gt;x&lt;/tt&gt; must be in the range &lt;tt&gt;[-1.0, 1.0]&lt;/tt&gt;, otherwise an exception is thrown.</span>
<a name="l01146"></a>01146 <span class="comment"></span>
<a name="l01147"></a>01147 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01148"></a>01148 <span class="comment">        Namespace: vigra</span>
<a name="l01149"></a>01149 <span class="comment">    */</span>
<a name="l01150"></a>01150 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01151"></a><a class="code" href="group__MathFunctions.html#ga0197e622433399bc9792bb1a884c0b8d">01151</a> REAL <a class="code" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b" title="Associated Legendre polynomial.">legendre</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l, REAL x)
<a name="l01152"></a>01152 {
<a name="l01153"></a>01153     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b" title="Associated Legendre polynomial.">legendre</a>(l, 0, x);
<a name="l01154"></a>01154 }
<a name="l01155"></a>01155 <span class="comment"></span>
<a name="l01156"></a>01156 <span class="comment">    /** \brief sin(pi*x). </span>
<a name="l01157"></a>01157 <span class="comment"></span>
<a name="l01158"></a>01158 <span class="comment">        Essentially calls &lt;tt&gt;std::sin(M_PI*x)&lt;/tt&gt; but uses a more accurate implementation</span>
<a name="l01159"></a>01159 <span class="comment">        to make sure that &lt;tt&gt;sin_pi(1.0) == 0.0&lt;/tt&gt; (which does not hold for</span>
<a name="l01160"></a>01160 <span class="comment">        &lt;tt&gt;std::sin(M_PI)&lt;/tt&gt; due to round-off error), and &lt;tt&gt;sin_pi(0.5) == 1.0&lt;/tt&gt;.</span>
<a name="l01161"></a>01161 <span class="comment"></span>
<a name="l01162"></a>01162 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01163"></a>01163 <span class="comment">        Namespace: vigra</span>
<a name="l01164"></a>01164 <span class="comment">    */</span>
<a name="l01165"></a>01165 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01166"></a><a class="code" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0">01166</a> REAL <a class="code" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0" title="sin(pi*x).">sin_pi</a>(REAL x)
<a name="l01167"></a>01167 {
<a name="l01168"></a>01168     <span class="keywordflow">if</span>(x &lt; 0.0)
<a name="l01169"></a>01169         <span class="keywordflow">return</span> -<a class="code" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0" title="sin(pi*x).">sin_pi</a>(-x);
<a name="l01170"></a>01170     <span class="keywordflow">if</span>(x &lt; 0.5)
<a name="l01171"></a>01171         <span class="keywordflow">return</span> <a class="code" href="group__LinearAlgebraFunctions.html#ga9db90484f9146df72b800bab7fecdd4b">std::sin</a>(M_PI * x);
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     <span class="keywordtype">bool</span> invert = <span class="keyword">false</span>;
<a name="l01174"></a>01174     <span class="keywordflow">if</span>(x &lt; 1.0)
<a name="l01175"></a>01175     {
<a name="l01176"></a>01176         invert = <span class="keyword">true</span>;
<a name="l01177"></a>01177         x = -x;
<a name="l01178"></a>01178     }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180     REAL rem = <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">std::floor</a>(x);
<a name="l01181"></a>01181     <span class="keywordflow">if</span>(<a class="code" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145" title="Check if an integer is odd.">odd</a>((<span class="keywordtype">int</span>)rem))
<a name="l01182"></a>01182         invert = !invert;
<a name="l01183"></a>01183     rem = x - rem;
<a name="l01184"></a>01184     <span class="keywordflow">if</span>(rem &gt; 0.5)
<a name="l01185"></a>01185         rem = 1.0 - rem;
<a name="l01186"></a>01186     <span class="keywordflow">if</span>(rem == 0.5)
<a name="l01187"></a>01187         rem = NumericTraits&lt;REAL&gt;::one();
<a name="l01188"></a>01188     <span class="keywordflow">else</span>
<a name="l01189"></a>01189         rem = <a class="code" href="group__LinearAlgebraFunctions.html#ga9db90484f9146df72b800bab7fecdd4b">std::sin</a>(M_PI * rem);
<a name="l01190"></a>01190     <span class="keywordflow">return</span> invert 
<a name="l01191"></a>01191               ? -rem 
<a name="l01192"></a>01192               : rem;
<a name="l01193"></a>01193 }
<a name="l01194"></a>01194 <span class="comment"></span>
<a name="l01195"></a>01195 <span class="comment">    /** \brief cos(pi*x). </span>
<a name="l01196"></a>01196 <span class="comment"></span>
<a name="l01197"></a>01197 <span class="comment">        Essentially calls &lt;tt&gt;std::cos(M_PI*x)&lt;/tt&gt; but uses a more accurate implementation</span>
<a name="l01198"></a>01198 <span class="comment">        to make sure that &lt;tt&gt;cos_pi(1.0) == -1.0&lt;/tt&gt; and &lt;tt&gt;cos_pi(0.5) == 0.0&lt;/tt&gt;.</span>
<a name="l01199"></a>01199 <span class="comment"></span>
<a name="l01200"></a>01200 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01201"></a>01201 <span class="comment">        Namespace: vigra</span>
<a name="l01202"></a>01202 <span class="comment">    */</span>
<a name="l01203"></a>01203 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01204"></a><a class="code" href="group__MathFunctions.html#ga7ce9a27a70c7341a29c4637cddf26f8c">01204</a> REAL <a class="code" href="group__MathFunctions.html#ga7ce9a27a70c7341a29c4637cddf26f8c" title="cos(pi*x).">cos_pi</a>(REAL x)
<a name="l01205"></a>01205 {
<a name="l01206"></a>01206     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0" title="sin(pi*x).">sin_pi</a>(x+0.5);
<a name="l01207"></a>01207 }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 <span class="keyword">namespace </span>detail {
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01212"></a>01212 <span class="keyword">struct </span>GammaImpl
<a name="l01213"></a>01213 {
<a name="l01214"></a>01214     <span class="keyword">static</span> REAL <a class="code" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976" title="The gamma function.">gamma</a>(REAL x);
<a name="l01215"></a>01215     <span class="keyword">static</span> REAL <a class="code" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26" title="The natural logarithm of the gamma function.">loggamma</a>(REAL x);
<a name="l01216"></a>01216     
<a name="l01217"></a>01217     <span class="keyword">static</span> <span class="keywordtype">double</span> g[];
<a name="l01218"></a>01218     <span class="keyword">static</span> <span class="keywordtype">double</span> a[];
<a name="l01219"></a>01219     <span class="keyword">static</span> <span class="keywordtype">double</span> t[];
<a name="l01220"></a>01220     <span class="keyword">static</span> <span class="keywordtype">double</span> u[];
<a name="l01221"></a>01221     <span class="keyword">static</span> <span class="keywordtype">double</span> v[];
<a name="l01222"></a>01222     <span class="keyword">static</span> <span class="keywordtype">double</span> s[];
<a name="l01223"></a>01223     <span class="keyword">static</span> <span class="keywordtype">double</span> r[];
<a name="l01224"></a>01224     <span class="keyword">static</span> <span class="keywordtype">double</span> w[];
<a name="l01225"></a>01225 };
<a name="l01226"></a>01226 
<a name="l01227"></a>01227 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01228"></a>01228 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::g[] = {
<a name="l01229"></a>01229     1.0,
<a name="l01230"></a>01230     0.5772156649015329,
<a name="l01231"></a>01231    -0.6558780715202538,
<a name="l01232"></a>01232    -0.420026350340952e-1,
<a name="l01233"></a>01233     0.1665386113822915,
<a name="l01234"></a>01234    -0.421977345555443e-1,
<a name="l01235"></a>01235    -0.9621971527877e-2,
<a name="l01236"></a>01236     0.7218943246663e-2,
<a name="l01237"></a>01237    -0.11651675918591e-2,
<a name="l01238"></a>01238    -0.2152416741149e-3,
<a name="l01239"></a>01239     0.1280502823882e-3,
<a name="l01240"></a>01240    -0.201348547807e-4,
<a name="l01241"></a>01241    -0.12504934821e-5,
<a name="l01242"></a>01242     0.1133027232e-5,
<a name="l01243"></a>01243    -0.2056338417e-6,
<a name="l01244"></a>01244     0.6116095e-8,
<a name="l01245"></a>01245     0.50020075e-8,
<a name="l01246"></a>01246    -0.11812746e-8,
<a name="l01247"></a>01247     0.1043427e-9,
<a name="l01248"></a>01248     0.77823e-11,
<a name="l01249"></a>01249    -0.36968e-11,
<a name="l01250"></a>01250     0.51e-12,
<a name="l01251"></a>01251    -0.206e-13,
<a name="l01252"></a>01252    -0.54e-14,
<a name="l01253"></a>01253     0.14e-14
<a name="l01254"></a>01254 };
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01257"></a>01257 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::a[] = {
<a name="l01258"></a>01258     7.72156649015328655494e-02,
<a name="l01259"></a>01259     3.22467033424113591611e-01,
<a name="l01260"></a>01260     6.73523010531292681824e-02,
<a name="l01261"></a>01261     2.05808084325167332806e-02,
<a name="l01262"></a>01262     7.38555086081402883957e-03,
<a name="l01263"></a>01263     2.89051383673415629091e-03,
<a name="l01264"></a>01264     1.19270763183362067845e-03,
<a name="l01265"></a>01265     5.10069792153511336608e-04,
<a name="l01266"></a>01266     2.20862790713908385557e-04,
<a name="l01267"></a>01267     1.08011567247583939954e-04,
<a name="l01268"></a>01268     2.52144565451257326939e-05,
<a name="l01269"></a>01269     4.48640949618915160150e-05 
<a name="l01270"></a>01270 };
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01273"></a>01273 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::t[] = {
<a name="l01274"></a>01274     4.83836122723810047042e-01,
<a name="l01275"></a>01275     -1.47587722994593911752e-01,
<a name="l01276"></a>01276     6.46249402391333854778e-02,
<a name="l01277"></a>01277     -3.27885410759859649565e-02,
<a name="l01278"></a>01278     1.79706750811820387126e-02,
<a name="l01279"></a>01279     -1.03142241298341437450e-02,
<a name="l01280"></a>01280     6.10053870246291332635e-03,
<a name="l01281"></a>01281     -3.68452016781138256760e-03,
<a name="l01282"></a>01282     2.25964780900612472250e-03,
<a name="l01283"></a>01283     -1.40346469989232843813e-03,
<a name="l01284"></a>01284     8.81081882437654011382e-04,
<a name="l01285"></a>01285     -5.38595305356740546715e-04,
<a name="l01286"></a>01286     3.15632070903625950361e-04,
<a name="l01287"></a>01287     -3.12754168375120860518e-04,
<a name="l01288"></a>01288     3.35529192635519073543e-04
<a name="l01289"></a>01289 };
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01292"></a>01292 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::u[] = {
<a name="l01293"></a>01293     -7.72156649015328655494e-02,
<a name="l01294"></a>01294     6.32827064025093366517e-01,
<a name="l01295"></a>01295     1.45492250137234768737e+00,
<a name="l01296"></a>01296     9.77717527963372745603e-01,
<a name="l01297"></a>01297     2.28963728064692451092e-01,
<a name="l01298"></a>01298     1.33810918536787660377e-02
<a name="l01299"></a>01299 };
<a name="l01300"></a>01300 
<a name="l01301"></a>01301 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01302"></a>01302 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::v[] = {
<a name="l01303"></a>01303     0.0,
<a name="l01304"></a>01304     2.45597793713041134822e+00,
<a name="l01305"></a>01305     2.12848976379893395361e+00,
<a name="l01306"></a>01306     7.69285150456672783825e-01,
<a name="l01307"></a>01307     1.04222645593369134254e-01,
<a name="l01308"></a>01308     3.21709242282423911810e-03
<a name="l01309"></a>01309 };
<a name="l01310"></a>01310 
<a name="l01311"></a>01311 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01312"></a>01312 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::s[] = {
<a name="l01313"></a>01313     -7.72156649015328655494e-02,
<a name="l01314"></a>01314     2.14982415960608852501e-01,
<a name="l01315"></a>01315     3.25778796408930981787e-01,
<a name="l01316"></a>01316     1.46350472652464452805e-01,
<a name="l01317"></a>01317     2.66422703033638609560e-02,
<a name="l01318"></a>01318     1.84028451407337715652e-03,
<a name="l01319"></a>01319     3.19475326584100867617e-05
<a name="l01320"></a>01320 };
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01323"></a>01323 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::r[] = {
<a name="l01324"></a>01324     0.0,
<a name="l01325"></a>01325     1.39200533467621045958e+00,
<a name="l01326"></a>01326     7.21935547567138069525e-01,
<a name="l01327"></a>01327     1.71933865632803078993e-01,
<a name="l01328"></a>01328     1.86459191715652901344e-02,
<a name="l01329"></a>01329     7.77942496381893596434e-04,
<a name="l01330"></a>01330     7.32668430744625636189e-06
<a name="l01331"></a>01331 };
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01334"></a>01334 <span class="keywordtype">double</span> GammaImpl&lt;REAL&gt;::w[] = {
<a name="l01335"></a>01335     4.18938533204672725052e-01,
<a name="l01336"></a>01336     8.33333333333329678849e-02,
<a name="l01337"></a>01337     -2.77777777728775536470e-03,
<a name="l01338"></a>01338     7.93650558643019558500e-04,
<a name="l01339"></a>01339     -5.95187557450339963135e-04,
<a name="l01340"></a>01340     8.36339918996282139126e-04,
<a name="l01341"></a>01341     -1.63092934096575273989e-03
<a name="l01342"></a>01342 };
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01345"></a>01345 REAL <a class="code" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976" title="The gamma function.">GammaImpl&lt;REAL&gt;::gamma</a>(REAL x)
<a name="l01346"></a>01346 {
<a name="l01347"></a>01347     <span class="keywordtype">int</span> i, k, m, ix = (int)x;
<a name="l01348"></a>01348     <span class="keywordtype">double</span> ga = 0.0, gr = 0.0, r = 0.0, z = 0.0;
<a name="l01349"></a>01349 
<a name="l01350"></a>01350     vigra_precondition(x &lt;= 171.0,
<a name="l01351"></a>01351         <span class="stringliteral">&quot;gamma(): argument cannot exceed 171.0.&quot;</span>);
<a name="l01352"></a>01352 
<a name="l01353"></a>01353     <span class="keywordflow">if</span> (x == ix) 
<a name="l01354"></a>01354     {
<a name="l01355"></a>01355         <span class="keywordflow">if</span> (ix &gt; 0) 
<a name="l01356"></a>01356         {
<a name="l01357"></a>01357             ga = 1.0;               <span class="comment">// use factorial</span>
<a name="l01358"></a>01358             <span class="keywordflow">for</span> (i=2; i&lt;ix; ++i) 
<a name="l01359"></a>01359             {
<a name="l01360"></a>01360                ga *= i;
<a name="l01361"></a>01361             }
<a name="l01362"></a>01362         }
<a name="l01363"></a>01363         <span class="keywordflow">else</span>
<a name="l01364"></a>01364         {
<a name="l01365"></a>01365             vigra_precondition(<span class="keyword">false</span>,
<a name="l01366"></a>01366                  <span class="stringliteral">&quot;gamma(): gamma function is undefined for 0 and negative integers.&quot;</span>);
<a name="l01367"></a>01367         }
<a name="l01368"></a>01368      }
<a name="l01369"></a>01369      <span class="keywordflow">else</span> 
<a name="l01370"></a>01370      {
<a name="l01371"></a>01371         <span class="keywordflow">if</span> (<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(x) &gt; 1.0) 
<a name="l01372"></a>01372         {
<a name="l01373"></a>01373             z = <a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(x);
<a name="l01374"></a>01374             m = (int)z;
<a name="l01375"></a>01375             r = 1.0;
<a name="l01376"></a>01376             <span class="keywordflow">for</span> (k=1; k&lt;=m; ++k) 
<a name="l01377"></a>01377             {
<a name="l01378"></a>01378                 r *= (z-k);
<a name="l01379"></a>01379             }
<a name="l01380"></a>01380             z -= m;
<a name="l01381"></a>01381         }
<a name="l01382"></a>01382         <span class="keywordflow">else</span>
<a name="l01383"></a>01383         {
<a name="l01384"></a>01384             z = x;
<a name="l01385"></a>01385         }
<a name="l01386"></a>01386         gr = g[24];
<a name="l01387"></a>01387         <span class="keywordflow">for</span> (k=23; k&gt;=0; --k) 
<a name="l01388"></a>01388         {
<a name="l01389"></a>01389             gr = gr*z+g[k];
<a name="l01390"></a>01390         }
<a name="l01391"></a>01391         ga = 1.0/(gr*z);
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(x) &gt; 1.0) 
<a name="l01393"></a>01393         {
<a name="l01394"></a>01394             ga *= r;
<a name="l01395"></a>01395             <span class="keywordflow">if</span> (x &lt; 0.0) 
<a name="l01396"></a>01396             {
<a name="l01397"></a>01397                 ga = -M_PI/(x*ga*<a class="code" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0" title="sin(pi*x).">sin_pi</a>(x));
<a name="l01398"></a>01398             }
<a name="l01399"></a>01399         }
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401     <span class="keywordflow">return</span> ga;
<a name="l01402"></a>01402 }
<a name="l01403"></a>01403 
<a name="l01404"></a>01404 <span class="comment">/*</span>
<a name="l01405"></a>01405 <span class="comment"> * the following code is derived from lgamma_r() by Sun</span>
<a name="l01406"></a>01406 <span class="comment"> * </span>
<a name="l01407"></a>01407 <span class="comment"> * ====================================================</span>
<a name="l01408"></a>01408 <span class="comment"> * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.</span>
<a name="l01409"></a>01409 <span class="comment"> *</span>
<a name="l01410"></a>01410 <span class="comment"> * Developed at SunPro, a Sun Microsystems, Inc. business.</span>
<a name="l01411"></a>01411 <span class="comment"> * Permission to use, copy, modify, and distribute this</span>
<a name="l01412"></a>01412 <span class="comment"> * software is freely granted, provided that this notice </span>
<a name="l01413"></a>01413 <span class="comment"> * is preserved.</span>
<a name="l01414"></a>01414 <span class="comment"> * ====================================================</span>
<a name="l01415"></a>01415 <span class="comment"> *</span>
<a name="l01416"></a>01416 <span class="comment"> */</span>
<a name="l01417"></a>01417 <span class="keyword">template</span> &lt;<span class="keyword">class</span> REAL&gt;
<a name="l01418"></a>01418 REAL <a class="code" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26" title="The natural logarithm of the gamma function.">GammaImpl&lt;REAL&gt;::loggamma</a>(REAL x)
<a name="l01419"></a>01419 {
<a name="l01420"></a>01420     vigra_precondition(x &gt; 0.0,
<a name="l01421"></a>01421         <span class="stringliteral">&quot;loggamma(): argument must be positive.&quot;</span>);
<a name="l01422"></a>01422     
<a name="l01423"></a>01423     vigra_precondition(x &lt;= 1.0e307,
<a name="l01424"></a>01424         <span class="stringliteral">&quot;loggamma(): argument must not exceed 1e307.&quot;</span>);
<a name="l01425"></a>01425 
<a name="l01426"></a>01426     <span class="keywordtype">double</span> res;
<a name="l01427"></a>01427     
<a name="l01428"></a>01428     <span class="keywordflow">if</span> (x &lt; 4.2351647362715017e-22)
<a name="l01429"></a>01429     {
<a name="l01430"></a>01430         res = -<a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">std::log</a>(x);
<a name="l01431"></a>01431     }
<a name="l01432"></a>01432     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((x == 2.0) || (x == 1.0))
<a name="l01433"></a>01433     {
<a name="l01434"></a>01434         res = 0.0;
<a name="l01435"></a>01435     }
<a name="l01436"></a>01436     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &lt; 2.0)
<a name="l01437"></a>01437     {
<a name="l01438"></a>01438         <span class="keyword">const</span> <span class="keywordtype">double</span> tc  =  1.46163214496836224576e+00;
<a name="l01439"></a>01439         <span class="keyword">const</span> <span class="keywordtype">double</span> tf  = -1.21486290535849611461e-01;
<a name="l01440"></a>01440         <span class="keyword">const</span> <span class="keywordtype">double</span> tt  = -3.63867699703950536541e-18;
<a name="l01441"></a>01441         <span class="keywordflow">if</span> (x &lt;= 0.9)
<a name="l01442"></a>01442         {
<a name="l01443"></a>01443             res = -<a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">std::log</a>(x);
<a name="l01444"></a>01444             <span class="keywordflow">if</span> (x &gt;= 0.7316)
<a name="l01445"></a>01445             {
<a name="l01446"></a>01446                 <span class="keywordtype">double</span> y = 1.0-x;
<a name="l01447"></a>01447                 <span class="keywordtype">double</span> z = y*y;
<a name="l01448"></a>01448                 <span class="keywordtype">double</span> p1 = a[0]+z*(a[2]+z*(a[4]+z*(a[6]+z*(a[8]+z*a[10]))));
<a name="l01449"></a>01449                 <span class="keywordtype">double</span> p2 = z*(a[1]+z*(a[3]+z*(a[5]+z*(a[7]+z*(a[9]+z*a[11])))));
<a name="l01450"></a>01450                 <span class="keywordtype">double</span> p  = y*p1+p2;
<a name="l01451"></a>01451                 res  += (p-0.5*y);
<a name="l01452"></a>01452             }
<a name="l01453"></a>01453             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt;= 0.23164)
<a name="l01454"></a>01454             {
<a name="l01455"></a>01455                 <span class="keywordtype">double</span> y = x-(tc-1.0);
<a name="l01456"></a>01456                 <span class="keywordtype">double</span> z = y*y;
<a name="l01457"></a>01457                 <span class="keywordtype">double</span> w = z*y;
<a name="l01458"></a>01458                 <span class="keywordtype">double</span> p1 = t[0]+w*(t[3]+w*(t[6]+w*(t[9] +w*t[12])));
<a name="l01459"></a>01459                 <span class="keywordtype">double</span> p2 = t[1]+w*(t[4]+w*(t[7]+w*(t[10]+w*t[13])));
<a name="l01460"></a>01460                 <span class="keywordtype">double</span> p3 = t[2]+w*(t[5]+w*(t[8]+w*(t[11]+w*t[14])));
<a name="l01461"></a>01461                 <span class="keywordtype">double</span> p  = z*p1-(tt-w*(p2+y*p3));
<a name="l01462"></a>01462                 res += (tf + p);
<a name="l01463"></a>01463             }
<a name="l01464"></a>01464             <span class="keywordflow">else</span>
<a name="l01465"></a>01465             {
<a name="l01466"></a>01466                 <span class="keywordtype">double</span> y = x;
<a name="l01467"></a>01467                 <span class="keywordtype">double</span> p1 = y*(u[0]+y*(u[1]+y*(u[2]+y*(u[3]+y*(u[4]+y*u[5])))));
<a name="l01468"></a>01468                 <span class="keywordtype">double</span> p2 = 1.0+y*(v[1]+y*(v[2]+y*(v[3]+y*(v[4]+y*v[5]))));
<a name="l01469"></a>01469                 res += (-0.5*y + p1/p2);
<a name="l01470"></a>01470             }
<a name="l01471"></a>01471         }
<a name="l01472"></a>01472         <span class="keywordflow">else</span>
<a name="l01473"></a>01473         {
<a name="l01474"></a>01474             res = 0.0;
<a name="l01475"></a>01475             <span class="keywordflow">if</span> (x &gt;= 1.7316)
<a name="l01476"></a>01476             {
<a name="l01477"></a>01477                 <span class="keywordtype">double</span> y = 2.0-x;
<a name="l01478"></a>01478                 <span class="keywordtype">double</span> z = y*y;
<a name="l01479"></a>01479                 <span class="keywordtype">double</span> p1 = a[0]+z*(a[2]+z*(a[4]+z*(a[6]+z*(a[8]+z*a[10]))));
<a name="l01480"></a>01480                 <span class="keywordtype">double</span> p2 = z*(a[1]+z*(a[3]+z*(a[5]+z*(a[7]+z*(a[9]+z*a[11])))));
<a name="l01481"></a>01481                 <span class="keywordtype">double</span> p  = y*p1+p2;
<a name="l01482"></a>01482                 res  += (p-0.5*y);
<a name="l01483"></a>01483             }
<a name="l01484"></a>01484             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(x &gt;= 1.23164)
<a name="l01485"></a>01485             {
<a name="l01486"></a>01486                 <span class="keywordtype">double</span> y = x-tc;
<a name="l01487"></a>01487                 <span class="keywordtype">double</span> z = y*y;
<a name="l01488"></a>01488                 <span class="keywordtype">double</span> w = z*y;
<a name="l01489"></a>01489                 <span class="keywordtype">double</span> p1 = t[0]+w*(t[3]+w*(t[6]+w*(t[9] +w*t[12])));
<a name="l01490"></a>01490                 <span class="keywordtype">double</span> p2 = t[1]+w*(t[4]+w*(t[7]+w*(t[10]+w*t[13])));
<a name="l01491"></a>01491                 <span class="keywordtype">double</span> p3 = t[2]+w*(t[5]+w*(t[8]+w*(t[11]+w*t[14])));
<a name="l01492"></a>01492                 <span class="keywordtype">double</span> p  = z*p1-(tt-w*(p2+y*p3));
<a name="l01493"></a>01493                 res += (tf + p);
<a name="l01494"></a>01494             }
<a name="l01495"></a>01495             <span class="keywordflow">else</span>
<a name="l01496"></a>01496             {
<a name="l01497"></a>01497                 <span class="keywordtype">double</span> y = x-1.0;
<a name="l01498"></a>01498                 <span class="keywordtype">double</span> p1 = y*(u[0]+y*(u[1]+y*(u[2]+y*(u[3]+y*(u[4]+y*u[5])))));
<a name="l01499"></a>01499                 <span class="keywordtype">double</span> p2 = 1.0+y*(v[1]+y*(v[2]+y*(v[3]+y*(v[4]+y*v[5]))));
<a name="l01500"></a>01500                 res += (-0.5*y + p1/p2);
<a name="l01501"></a>01501             }
<a name="l01502"></a>01502         }
<a name="l01503"></a>01503     }
<a name="l01504"></a>01504     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(x &lt; 8.0)
<a name="l01505"></a>01505     {
<a name="l01506"></a>01506         <span class="keywordtype">double</span> i = <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">std::floor</a>(x);
<a name="l01507"></a>01507         <span class="keywordtype">double</span> y = x-i;
<a name="l01508"></a>01508         <span class="keywordtype">double</span> p = y*(s[0]+y*(s[1]+y*(s[2]+y*(s[3]+y*(s[4]+y*(s[5]+y*s[6]))))));
<a name="l01509"></a>01509         <span class="keywordtype">double</span> q = 1.0+y*(r[1]+y*(r[2]+y*(r[3]+y*(r[4]+y*(r[5]+y*r[6])))));
<a name="l01510"></a>01510         res = 0.5*y+p/q;
<a name="l01511"></a>01511         <span class="keywordtype">double</span> z = 1.0;
<a name="l01512"></a>01512         <span class="keywordflow">while</span> (i &gt; 2.0)
<a name="l01513"></a>01513         {
<a name="l01514"></a>01514             --i;
<a name="l01515"></a>01515             z *= (y+i);
<a name="l01516"></a>01516         }
<a name="l01517"></a>01517         res += <a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">std::log</a>(z);
<a name="l01518"></a>01518     }
<a name="l01519"></a>01519     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &lt; 2.8823037615171174e+17)
<a name="l01520"></a>01520     {
<a name="l01521"></a>01521         <span class="keywordtype">double</span> t = <a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">std::log</a>(x);
<a name="l01522"></a>01522         <span class="keywordtype">double</span> z = 1.0/x;
<a name="l01523"></a>01523         <span class="keywordtype">double</span> y = z*z;
<a name="l01524"></a>01524         <span class="keywordtype">double</span> yy = w[0]+z*(w[1]+y*(w[2]+y*(w[3]+y*(w[4]+y*(w[5]+y*w[6])))));
<a name="l01525"></a>01525         res = (x-0.5)*(t-1.0)+yy;
<a name="l01526"></a>01526     }
<a name="l01527"></a>01527     <span class="keywordflow">else</span>
<a name="l01528"></a>01528     {
<a name="l01529"></a>01529         res =  x*(<a class="code" href="group__LinearAlgebraFunctions.html#ga51ba49a20a6057642664f5be8521ec39">std::log</a>(x) - 1.0);
<a name="l01530"></a>01530     }
<a name="l01531"></a>01531     
<a name="l01532"></a>01532     <span class="keywordflow">return</span> res;
<a name="l01533"></a>01533 }
<a name="l01534"></a>01534 
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 } <span class="comment">// namespace detail</span>
<a name="l01537"></a>01537 <span class="comment"></span>
<a name="l01538"></a>01538 <span class="comment">    /** \brief The gamma function.</span>
<a name="l01539"></a>01539 <span class="comment"></span>
<a name="l01540"></a>01540 <span class="comment">        This function implements the algorithm from&lt;br&gt;</span>
<a name="l01541"></a>01541 <span class="comment">        Zhang and Jin: &quot;Computation of Special Functions&quot;, John Wiley and Sons, 1996.</span>
<a name="l01542"></a>01542 <span class="comment">        </span>
<a name="l01543"></a>01543 <span class="comment">        The argument must be &lt;= 171.0 and cannot be zero or a negative integer. An</span>
<a name="l01544"></a>01544 <span class="comment">        exception is thrown when these conditions are violated.</span>
<a name="l01545"></a>01545 <span class="comment"></span>
<a name="l01546"></a>01546 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01547"></a>01547 <span class="comment">        Namespace: vigra</span>
<a name="l01548"></a>01548 <span class="comment">    */</span>
<a name="l01549"></a><a class="code" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976">01549</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976" title="The gamma function.">gamma</a>(<span class="keywordtype">double</span> x)
<a name="l01550"></a>01550 {
<a name="l01551"></a>01551     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976" title="The gamma function.">detail::GammaImpl&lt;double&gt;::gamma</a>(x);
<a name="l01552"></a>01552 }
<a name="l01553"></a>01553 <span class="comment"></span>
<a name="l01554"></a>01554 <span class="comment">    /** \brief The natural logarithm of the gamma function.</span>
<a name="l01555"></a>01555 <span class="comment"></span>
<a name="l01556"></a>01556 <span class="comment">        This function is based on a free implementation by Sun Microsystems, Inc., see</span>
<a name="l01557"></a>01557 <span class="comment">        &lt;a href=&quot;http://www.sourceware.org/cgi-bin/cvsweb.cgi/~checkout~/src/newlib/libm/mathfp/er_lgamma.c?rev=1.6&amp;content-type=text/plain&amp;cvsroot=src&quot;&gt;sourceware.org&lt;/a&gt; archive. It can be removed once all compilers support the new C99</span>
<a name="l01558"></a>01558 <span class="comment">        math functions.</span>
<a name="l01559"></a>01559 <span class="comment">        </span>
<a name="l01560"></a>01560 <span class="comment">        The argument must be positive and &lt; 1e30. An exception is thrown when these conditions are violated.</span>
<a name="l01561"></a>01561 <span class="comment"></span>
<a name="l01562"></a>01562 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01563"></a>01563 <span class="comment">        Namespace: vigra</span>
<a name="l01564"></a>01564 <span class="comment">    */</span>
<a name="l01565"></a><a class="code" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26">01565</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26" title="The natural logarithm of the gamma function.">loggamma</a>(<span class="keywordtype">double</span> x)
<a name="l01566"></a>01566 {
<a name="l01567"></a>01567     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26" title="The natural logarithm of the gamma function.">detail::GammaImpl&lt;double&gt;::loggamma</a>(x);
<a name="l01568"></a>01568 }
<a name="l01569"></a>01569 
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 <span class="keyword">namespace </span>detail {
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 <span class="comment">// both f1 and f2 are unsigned here</span>
<a name="l01574"></a>01574 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FPT&gt;
<a name="l01575"></a>01575 <span class="keyword">inline</span>
<a name="l01576"></a>01576 FPT safeFloatDivision( FPT f1, FPT f2 )
<a name="l01577"></a>01577 {
<a name="l01578"></a>01578     <span class="keywordflow">return</span>  f2 &lt; NumericTraits&lt;FPT&gt;::one() &amp;&amp; f1 &gt; f2 * NumericTraits&lt;FPT&gt;::max()
<a name="l01579"></a>01579                 ? NumericTraits&lt;FPT&gt;::max() 
<a name="l01580"></a>01580                 : (f2 &gt; NumericTraits&lt;FPT&gt;::one() &amp;&amp; f1 &lt; f2 * NumericTraits&lt;FPT&gt;::smallestPositive()) || 
<a name="l01581"></a>01581                    f1 == NumericTraits&lt;FPT&gt;::zero()
<a name="l01582"></a>01582                      ? NumericTraits&lt;FPT&gt;::zero() 
<a name="l01583"></a>01583                      : f1/f2;
<a name="l01584"></a>01584 }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586 } <span class="comment">// namespace detail</span>
<a name="l01587"></a>01587     <span class="comment"></span>
<a name="l01588"></a>01588 <span class="comment">    /** \brief Tolerance based floating-point comparison.</span>
<a name="l01589"></a>01589 <span class="comment"></span>
<a name="l01590"></a>01590 <span class="comment">        Check whether two floating point numbers are equal within the given tolerance.</span>
<a name="l01591"></a>01591 <span class="comment">        This is useful because floating point numbers that should be equal in theory are</span>
<a name="l01592"></a>01592 <span class="comment">        rarely exactly equal in practice. If the tolerance \a epsilon is not given,</span>
<a name="l01593"></a>01593 <span class="comment">        twice the machine epsilon is used.</span>
<a name="l01594"></a>01594 <span class="comment"></span>
<a name="l01595"></a>01595 <span class="comment">        &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/mathutil.hxx&gt;&lt;br&gt;</span>
<a name="l01596"></a>01596 <span class="comment">        Namespace: vigra</span>
<a name="l01597"></a>01597 <span class="comment">    */</span>
<a name="l01598"></a>01598 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l01599"></a>01599 <span class="keywordtype">bool</span> 
<a name="l01600"></a><a class="code" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7">01600</a> <a class="code" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7" title="Tolerance based floating-point comparison.">closeAtTolerance</a>(T1 l, T2 r, <span class="keyword">typename</span> PromoteTraits&lt;T1, T2&gt;::Promote epsilon)
<a name="l01601"></a>01601 {
<a name="l01602"></a>01602     <span class="keyword">typedef</span> <span class="keyword">typename</span> PromoteTraits&lt;T1, T2&gt;::Promote T;
<a name="l01603"></a>01603     <span class="keywordflow">if</span>(l == 0.0)
<a name="l01604"></a>01604         <span class="keywordflow">return</span> VIGRA_CSTD::fabs(r) &lt;= epsilon;
<a name="l01605"></a>01605     <span class="keywordflow">if</span>(r == 0.0)
<a name="l01606"></a>01606         <span class="keywordflow">return</span> VIGRA_CSTD::fabs(l) &lt;= epsilon;
<a name="l01607"></a>01607     T diff = VIGRA_CSTD::fabs( l - r );
<a name="l01608"></a>01608     T d1   = detail::safeFloatDivision&lt;T&gt;( diff, VIGRA_CSTD::fabs( r ) );
<a name="l01609"></a>01609     T d2   = detail::safeFloatDivision&lt;T&gt;( diff, VIGRA_CSTD::fabs( l ) );
<a name="l01610"></a>01610 
<a name="l01611"></a>01611     <span class="keywordflow">return</span> (d1 &lt;= epsilon &amp;&amp; d2 &lt;= epsilon);
<a name="l01612"></a>01612 }
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l01615"></a>01615 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7" title="Tolerance based floating-point comparison.">closeAtTolerance</a>(T1 l, T2 r)
<a name="l01616"></a>01616 {
<a name="l01617"></a>01617     <span class="keyword">typedef</span> <span class="keyword">typename</span> PromoteTraits&lt;T1, T2&gt;::Promote T;
<a name="l01618"></a>01618     <span class="keywordflow">return</span> <a class="code" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7" title="Tolerance based floating-point comparison.">closeAtTolerance</a>(l, r, T(2.0) * NumericTraits&lt;T&gt;::epsilon());
<a name="l01619"></a>01619 }
<a name="l01620"></a>01620 <span class="comment"></span>
<a name="l01621"></a>01621 <span class="comment">//@}</span>
<a name="l01622"></a>01622 <span class="comment"></span>
<a name="l01623"></a>01623 } <span class="comment">// namespace vigra</span>
<a name="l01624"></a>01624 
<a name="l01625"></a>01625 <span class="preprocessor">#endif </span><span class="comment">/* VIGRA_MATHUTIL_HXX */</span>
</pre></div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
