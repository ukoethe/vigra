<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Optimization and Regression</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Optimization and Regression
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1linalg_1_1LeastAngleRegressionOptions.html">LeastAngleRegressionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass options to <a class="el" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression()</a>.  <a href="classvigra_1_1linalg_1_1LeastAngleRegressionOptions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1NonlinearLSQOptions.html">NonlinearLSQOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass options to <a class="el" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares()</a>.  <a href="classvigra_1_1NonlinearLSQOptions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab47cd570de4c39a53b4da2d830d4568c"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gab47cd570de4c39a53b4da2d830d4568c"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression</a> (...)</td></tr>
<tr class="separator:gab47cd570de4c39a53b4da2d830d4568c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3be347f5631d0aa2ee74c07479e0383"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:gab3be347f5631d0aa2ee74c07479e0383"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#gab3be347f5631d0aa2ee74c07479e0383">leastSquares</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, std::string method=&quot;QR&quot;)</td></tr>
<tr class="separator:gab3be347f5631d0aa2ee74c07479e0383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca08304f34fff2a829234d2c374f4252"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaca08304f34fff2a829234d2c374f4252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252">nonlinearLeastSquares</a> (...)</td></tr>
<tr class="memdesc:gaca08304f34fff2a829234d2c374f4252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a non-linear model to given data by minimizing least squares loss.  <a href="#gaca08304f34fff2a829234d2c374f4252">More...</a><br/></td></tr>
<tr class="separator:gaca08304f34fff2a829234d2c374f4252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b680f4375cd2963543db1a7cf85e41"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga73b680f4375cd2963543db1a7cf85e41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#ga73b680f4375cd2963543db1a7cf85e41">nonnegativeLeastSquares</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x)</td></tr>
<tr class="separator:ga73b680f4375cd2963543db1a7cf85e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60bf3f23776bd500a5009b2a25442860"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 , class C4 , class C5 , class C6 , class C7 &gt; </td></tr>
<tr class="memitem:ga60bf3f23776bd500a5009b2a25442860"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#ga60bf3f23776bd500a5009b2a25442860">quadraticProgramming</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;G, MultiArrayView&lt; 2, T, C2 &gt; const &amp;g, MultiArrayView&lt; 2, T, C3 &gt; const &amp;CE, MultiArrayView&lt; 2, T, C4 &gt; const &amp;ce, MultiArrayView&lt; 2, T, C5 &gt; const &amp;CI, MultiArrayView&lt; 2, T, C6 &gt; const &amp;ci, MultiArrayView&lt; 2, T, C7 &gt; &amp;x)</td></tr>
<tr class="separator:ga60bf3f23776bd500a5009b2a25442860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647810e9f3f2ff2e401f410b4855c58a"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga647810e9f3f2ff2e401f410b4855c58a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#ga647810e9f3f2ff2e401f410b4855c58a">ridgeRegression</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, double lambda)</td></tr>
<tr class="separator:ga647810e9f3f2ff2e401f410b4855c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20a4d83649e2c65d9d553105882af9f"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 , class Array &gt; </td></tr>
<tr class="memitem:gad20a4d83649e2c65d9d553105882af9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#gad20a4d83649e2c65d9d553105882af9f">ridgeRegressionSeries</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, Array const &amp;lambda)</td></tr>
<tr class="separator:gad20a4d83649e2c65d9d553105882af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591ca4f43e4114253d7bfa2953f07c4d"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 , class C4 &gt; </td></tr>
<tr class="memitem:ga591ca4f43e4114253d7bfa2953f07c4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#ga591ca4f43e4114253d7bfa2953f07c4d">weightedLeastSquares</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; const &amp;weights, MultiArrayView&lt; 2, T, C4 &gt; &amp;x, std::string method=&quot;QR&quot;)</td></tr>
<tr class="separator:ga591ca4f43e4114253d7bfa2953f07c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6eb7c915e0e6b1820974316b1d5d32"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 , class C4 &gt; </td></tr>
<tr class="memitem:gade6eb7c915e0e6b1820974316b1d5d32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Optimization.html#gade6eb7c915e0e6b1820974316b1d5d32">weightedRidgeRegression</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; const &amp;weights, MultiArrayView&lt; 2, T, C4 &gt; &amp;x, double lambda)</td></tr>
<tr class="separator:gade6eb7c915e0e6b1820974316b1d5d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga60bf3f23776bd500a5009b2a25442860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T vigra::quadraticProgramming </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>CE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C5 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>CI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C6 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve Quadratic Programming Problem.</p>
<p>The <a class="el" href="group__Optimization.html#ga60bf3f23776bd500a5009b2a25442860">quadraticProgramming()</a> function implements the algorithm described in</p>
<p>D. Goldfarb, A. Idnani: <em>"A numerically stable dual method for solving
            strictly convex quadratic programs"</em>, Mathematical Programming 27:1-33, 1983.</p>
<p>for the solution of (convex) quadratic programming problems by means of a primal-dual method.</p>
<p><b>#include</b> &lt;<a class="el" href="quadprog_8hxx_source.html">vigra/quadprog.hxx</a>&gt; <br/>
 Namespaces: vigra</p>
<p><b>Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra { </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3, <span class="keyword">class</span> C4, <span class="keyword">class</span> C5, <span class="keyword">class</span> C6, <span class="keyword">class</span> C7&gt;</div>
<div class="line">    T </div>
<div class="line">    <a class="code" href="group__Optimization.html#ga60bf3f23776bd500a5009b2a25442860">quadraticProgramming</a>(MultiArrayView&lt;2, T, C1&gt; <span class="keyword">const</span> &amp; GG, MultiArrayView&lt;2, T, C2&gt; <span class="keyword">const</span> &amp; g,  </div>
<div class="line">                         MultiArrayView&lt;2, T, C3&gt; <span class="keyword">const</span> &amp; CE, MultiArrayView&lt;2, T, C4&gt; <span class="keyword">const</span> &amp; ce,  </div>
<div class="line">                         MultiArrayView&lt;2, T, C5&gt; <span class="keyword">const</span> &amp; CI, MultiArrayView&lt;2, T, C6&gt; <span class="keyword">const</span> &amp; ci, </div>
<div class="line">                         MultiArrayView&lt;2, T, C7&gt; &amp; x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The problem must be specified in the form:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \mbox{minimize } &amp;\,&amp; \frac{1}{2} \mbox{\bf x}'\,\mbox{\bf G}\, \mbox{\bf x} + \mbox{\bf g}'\,\mbox{\bf x} \\ \mbox{subject to} &amp;\,&amp; \mbox{\bf C}_E\, \mbox{\bf x} = \mbox{\bf c}_e \\ &amp;\,&amp; \mbox{\bf C}_I\,\mbox{\bf x} \ge \mbox{\bf c}_i \end{eqnarray*}" src="form_69.png"/>
</p>
<p> Matrix <b>G</b> G must be symmetric positive definite, and matrix <b>C</b><sub>E</sub> must have full row rank. Matrix and vector dimensions must be as follows: </p>
<ul>
<li>
<b>G</b>: [n * n], <b>g</b>: [n * 1] </li>
<li>
<b>C</b><sub>E</sub>: [me * n], <b>c</b><sub>e</sub>: [me * 1] </li>
<li>
<b>C</b><sub>I</sub>: [mi * n], <b>c</b><sub>i</sub>: [mi * 1] </li>
<li>
<b>x</b>: [n * 1] </li>
</ul>
<p>The function writes the optimal solution into the vector <em>x</em> and returns the cost of this solution. If the problem is infeasible, std::numeric_limits::infinity() is returned. In this case the value of vector <em>x</em> is undefined.</p>
<p><b>Usage:</b></p>
<p>Minimize <code> f = 0.5 * x'*G*x + g'*x </code> subject to <code> -1 &lt;= x &lt;= 1</code>. The solution is <code> x' = [1.0, 0.5, -1.0] </code> with <code> f = -22.625</code>. </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Gdata[] = {13.0, 12.0, -2.0,</div>
<div class="line">                  12.0, 17.0,  6.0,</div>
<div class="line">                  -2.0,  6.0, 12.0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> gdata[] = {-22.0, -14.5, 13.0};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> CIdata[] = { 1.0,  0.0,  0.0,</div>
<div class="line">                    0.0,  1.0,  0.0,</div>
<div class="line">                    0.0,  0.0,  1.0,</div>
<div class="line">                   -1.0,  0.0,  0.0,</div>
<div class="line">                    0.0, -1.0,  0.0,</div>
<div class="line">                    0.0,  0.0, -1.0};</div>
<div class="line">                  </div>
<div class="line"><span class="keywordtype">double</span> cidata[] = {-1.0, -1.0, -1.0, -1.0, -1.0, -1.0};</div>
<div class="line"></div>
<div class="line">Matrix&lt;double&gt; G(3,3, Gdata), </div>
<div class="line">               g(3,1, gdata), </div>
<div class="line">               CE,             <span class="comment">// empty since there are no equality constraints</span></div>
<div class="line">               ce,             <span class="comment">// likewise</span></div>
<div class="line">               CI(7,3, CIdata), </div>
<div class="line">               ci(7,1, cidata), </div>
<div class="line">               x(3,1);</div>
<div class="line">             </div>
<div class="line"><span class="keywordtype">double</span> f = <a class="code" href="group__Optimization.html#ga60bf3f23776bd500a5009b2a25442860">quadraticProgramming</a>(G, g, CE, ce, CI, ci, x);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab3be347f5631d0aa2ee74c07479e0383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::leastSquares </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;QR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordinary Least Squares Regression.</p>
<p>Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), and a column vector <em>b</em> of length <code>m</code> rows, this function computes the column vector <em>x</em> of length <code>n</code> rows that solves the optimization problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|\right|_2^2 \]" src="form_71.png"/>
</p>
<p>When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.</p>
<p>This function is just another name for <a class="el" href="group__MatrixAlgebra.html#ga889fc66edb20976e31a9212a073e411f">linearSolve()</a>, perhaps leading to more readable code when <em>A</em> is a rectangular matrix. It returns <code>false</code> when the rank of <em>A</em> is less than <code>n</code>. See <a class="el" href="group__MatrixAlgebra.html#ga889fc66edb20976e31a9212a073e411f">linearSolve()</a> for more documentation.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga591ca4f43e4114253d7bfa2953f07c4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::weightedLeastSquares </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;QR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Weighted Least Squares Regression.</p>
<p>Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), a vector <em>b</em> of length <code>m</code>, and a weight vector <em>weights</em> of length <code>m</code> with non-negative entries, this function computes the vector <em>x</em> of length <code>n</code> that solves the optimization problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right)^T \textrm{diag}(\textrm{\bf weights}) \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right) \]" src="form_72.png"/>
</p>
<p>where <code>diag(weights)</code> creates a diagonal matrix from <em>weights</em>. The algorithm calls <a class="el" href="group__Optimization.html#gab3be347f5631d0aa2ee74c07479e0383">leastSquares()</a> on the equivalent problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{diag}(\textrm{\bf weights})^{1/2}\textrm{\bf A} \textrm{\bf x} - \textrm{diag}(\textrm{\bf weights})^{1/2} \textrm{\bf b}\right|\right|_2^2 \]" src="form_73.png"/>
</p>
<p>where the square root of <em>weights</em> is just taken element-wise.</p>
<p>When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.</p>
<p>The function returns <code>false</code> when the rank of the weighted matrix <em>A</em> is less than <code>n</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga647810e9f3f2ff2e401f410b4855c58a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::ridgeRegression </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ridge Regression.</p>
<p>Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), a vector <em>b</em> of length <code>m</code>, and a regularization parameter <code>lambda &gt;= 0.0</code>, this function computes the vector <em>x</em> of length <code>n</code> that solves the optimization problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|\right|_2^2 + \lambda \textrm{\bf x}^T\textrm{\bf x} \]" src="form_74.png"/>
</p>
<p>This is implemented by means of <a class="el" href="group__MatrixAlgebra.html#gaf20e05edcc344f32d96fdaf5a6b3b972">singularValueDecomposition()</a>.</p>
<p>When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.</p>
<p>The function returns <code>false</code> if the rank of <em>A</em> is less than <code>n</code> and <code>lambda == 0.0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gade6eb7c915e0e6b1820974316b1d5d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::weightedRidgeRegression </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Weighted ridge Regression.</p>
<p>Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), a vector <em>b</em> of length <code>m</code>, a weight vector <em>weights</em> of length <code>m</code> with non-negative entries, and a regularization parameter <code>lambda &gt;= 0.0</code> this function computes the vector <em>x</em> of length <code>n</code> that solves the optimization problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right)^T \textrm{diag}(\textrm{\bf weights}) \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right) + \lambda \textrm{\bf x}^T\textrm{\bf x} \]" src="form_75.png"/>
</p>
<p>where <code>diag(weights)</code> creates a diagonal matrix from <em>weights</em>. The algorithm calls <a class="el" href="group__Optimization.html#ga647810e9f3f2ff2e401f410b4855c58a">ridgeRegression()</a> on the equivalent problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{diag}(\textrm{\bf weights})^{1/2}\textrm{\bf A} \textrm{\bf x} - \textrm{diag}(\textrm{\bf weights})^{1/2} \textrm{\bf b}\right|\right|_2^2 + \lambda \textrm{\bf x}^T\textrm{\bf x} \]" src="form_76.png"/>
</p>
<p>where the square root of <em>weights</em> is just taken element-wise. This solution is computed by means of <a class="el" href="group__MatrixAlgebra.html#gaf20e05edcc344f32d96fdaf5a6b3b972">singularValueDecomposition()</a>.</p>
<p>When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.</p>
<p>The function returns <code>false</code> if the rank of <em>A</em> is less than <code>n</code> and <code>lambda == 0.0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gad20a4d83649e2c65d9d553105882af9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::ridgeRegressionSeries </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array const &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ridge Regression with many lambdas.</p>
<p>This executes <a class="el" href="group__Optimization.html#ga647810e9f3f2ff2e401f410b4855c58a">ridgeRegression()</a> for a sequence of regularization parameters. This is implemented so that the <a class="el" href="group__MatrixAlgebra.html#gaf20e05edcc344f32d96fdaf5a6b3b972">singularValueDecomposition()</a> has to be executed only once. <em>lambda</em> must be an array conforming to the <code>std::vector</code> interface, i.e. must support <code>lambda.size()</code> and <code>lambda[k]</code>. The columns of the matrix <em>x</em> will contain the solutions for the corresponding lambda, so the number of columns of the matrix <em>x</em> must be equal to <code>lambda.size()</code>, and <em>b</em> must be a columns vector, i.e. cannot contain several right hand sides at once.</p>
<p>The function returns <code>false</code> when the matrix <em>A</em> is rank deficient. If this happens, and one of the lambdas is zero, the corresponding column of <em>x</em> will be skipped.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gab47cd570de4c39a53b4da2d830d4568c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vigra::linalg::leastAngleRegression </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Least Angle Regression.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a></p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">   <span class="keyword">namespace </span>linalg {</div>
<div class="line">     <span class="comment">// compute either LASSO or least squares solutions</span></div>
<div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> Array1, <span class="keyword">class</span> Array2&gt;</div>
<div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">     <a class="code" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression</a>(MultiArrayView&lt;2, T, C1&gt; <span class="keyword">const</span> &amp; A, MultiArrayView&lt;2, T, C2&gt; <span class="keyword">const</span> &amp;b,</div>
<div class="line">              Array1 &amp; activeSets, Array2 &amp; solutions,</div>
<div class="line">              LeastAngleRegressionOptions <span class="keyword">const</span> &amp; options = LeastAngleRegressionOptions());</div>
<div class="line"></div>
<div class="line">     <span class="comment">// compute LASSO and least squares solutions</span></div>
<div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> Array1, <span class="keyword">class</span> Array2&gt;</div>
<div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div>
<div class="line">     <a class="code" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression</a>(MultiArrayView&lt;2, T, C1&gt; <span class="keyword">const</span> &amp; A, MultiArrayView&lt;2, T, C2&gt; <span class="keyword">const</span> &amp;b,</div>
<div class="line">              Array1 &amp; activeSets, Array2 &amp; lasso_solutions, Array2 &amp; lsq_solutions,</div>
<div class="line">              LeastAngleRegressionOptions <span class="keyword">const</span> &amp; options = LeastAngleRegressionOptions());</div>
<div class="line">   }</div>
<div class="line">   <span class="keyword">using</span> <a class="code" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">linalg::leastAngleRegression</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function implements Least Angle Regression (LARS) as described in</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; B.Efron, T.Hastie, I.Johnstone, and R.Tibshirani: <em>"Least Angle Regression"</em>, Annals of Statistics 32(2):407-499, 2004.</p>
<p>It is an efficient algorithm to solve the L1-regularized least squares (LASSO) problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|\right|_2^2 \textrm{ subject to } \left|\left|\textrm{\bf x}\right|\right|_1\le s \]" src="form_77.png"/>
</p>
<p>and the L1-regularized non-negative least squares (NN-LASSO) problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|\right|_2^2 \textrm{ subject to } \left|\left|\textrm{\bf x}\right|\right|_1\le s \textrm{ and } \textrm{\bf x}\ge \textrm{\bf 0} \]" src="form_78.png"/>
</p>
<p>where <em>A</em> is a matrix with <code>m</code> rows and <code>n</code> columns (often with <code>m &lt; n</code>), <em>b</em> a vector of length <code>m</code>, and a regularization parameter s &gt;= 0.0. L1-regularization has the desirable effect that it causes the solution <b>x</b> to be sparse, i.e. only the most important elements in <b>x</b> (called the <em>active set</em>) have non-zero values. The key insight of the LARS algorithm is the following: When the solution vector <b>x</b> is considered as a function of the regularization parameter s, then <b>x</b>(s) is a piecewise linear function, i.e. a polyline in n-dimensional space. The knots of the polyline <b>x</b>(s) are located precisely at those values of s where one variable enters or leaves the active set and can be efficiently computed.</p>
<p>Therefore, <a class="el" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression()</a> returns the entire solution path as a sequence of knot points, starting at <img class="formulaInl" alt="$\textrm{\bf x}(s=0)$" src="form_79.png"/> (where the only feasible solution is obviously <b>x</b> = 0) and ending at <img class="formulaInl" alt="$\textrm{\bf x}(s=\infty)$" src="form_80.png"/> (where the solution becomes the ordinary least squares solution). Actually, the initial null solution is not explicitly returned, i.e. the sequence starts at the first non-zero solution with one variable in the active set. The function <a class="el" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression()</a> returns the number of solutions (i.e. knot points) computed.</p>
<p>The sequences of active sets and corresponding variable weights are returned in <em>activeSets</em> and <em>solutions</em> respectively. That is, <code>activeSets[i]</code> is an <a class="el" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;int&gt;</a> containing the indices of the variables that are active at the i-th knot, and <code>solutions</code> is a <a class="el" href="classvigra_1_1linalg_1_1Matrix.html">Matrix&lt;T&gt;</a> containing the weights of those variables, in the same order (see example below). Variables not contained in <code>activeSets[i]</code> are zero at this solution.</p>
<p>The behavior of the algorithm can be adapted by <a class="el" href="classvigra_1_1linalg_1_1LeastAngleRegressionOptions.html">LeastAngleRegressionOptions</a>: </p>
<dl>
<dt><b>options.lasso()</b> (active by default) </dt>
<dd>Compute the LASSO solution as described above. </dd>
<dt><b>options.nnlasso()</b> (inactive by default) </dt>
<dd>Compute non-negative LASSO solutions, i.e. use the additional constraint that <b>x</b> &gt;= 0 in all solutions. </dd>
<dt><b>options.lars()</b> (inactive by default) </dt>
<dd>Compute a solution path according to the plain LARS rule, i.e. never remove a variable from the active set once it entered. </dd>
<dt><b>options.leastSquaresSolutions(bool)</b> (default: true) </dt>
<dd>Use the algorithm mode selected above to determine the sequence of active sets, but then compute and return an ordinary (unconstrained) least squares solution for every active set.<br/>
 <b>Note:</b> The second form of <a class="el" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression()</a> ignores this option and does always compute both constrained and unconstrained solutions (returned in <em>lasso_solutions</em> and <em>lsq_solutions</em> respectively). </dd>
<dt><b>maxSolutionCount(unsigned int n)</b> (default: n = 0, i.e. compute all solutions) </dt>
<dd>Compute at most <code>n</code> solutions. </dd>
</dl>
<p><b>Usage:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> m = ..., n = ...;</div>
<div class="line">Matrix&lt;double&gt; A(m, n), b(m, 1);</div>
<div class="line">... <span class="comment">// fill A and b</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// normalize the input</span></div>
<div class="line">Matrix&lt;double&gt; offset(1,n), scaling(1,n);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga9570361590f341c6a3699b1d2074c3de" title="Standardize the columns of a matrix according to given DataPreparationGoals.">prepareColumns</a>(A, A, offset, scaling, DataPreparationGoals(ZeroMean|UnitVariance));</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga9570361590f341c6a3699b1d2074c3de" title="Standardize the columns of a matrix according to given DataPreparationGoals.">prepareColumns</a>(b, b, DataPreparationGoals(ZeroMean));</div>
<div class="line"></div>
<div class="line"><span class="comment">// arrays to hold the output</span></div>
<div class="line">ArrayVector&lt;ArrayVector&lt;int&gt; &gt; activeSets;</div>
<div class="line">ArrayVector&lt;Matrix&lt;double&gt; &gt; solutions;</div>
<div class="line"></div>
<div class="line"><span class="comment">// run leastAngleRegression() in non-negative LASSO mode</span></div>
<div class="line"><span class="keywordtype">int</span> numSolutions = <a class="code" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression</a>(A, b, activeSets, solutions,</div>
<div class="line">                            LeastAngleRegressionOptions().nnlasso());</div>
<div class="line"></div>
<div class="line"><span class="comment">// print results</span></div>
<div class="line">Matrix&lt;double&gt; denseSolution(1, n);</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> k = 0; k &lt; numSolutions; ++k)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// transform the sparse solution into a dense vector</span></div>
<div class="line">    denseSolution.init(0.0); <span class="comment">// ensure that inactive variables are zero</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; activeSets[k].size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// set the values of the active variables;</span></div>
<div class="line">        <span class="comment">// activeSets[k][i] is the true index of the i-th variable in the active set</span></div>
<div class="line">        denseSolution(0, activeSets[k][i]) = solutions[k](i,0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// invert the input normalization</span></div>
<div class="line">    denseSolution = denseSolution * pointWise(scaling);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// output the solution</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;solution &quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span> &lt;&lt; denseSolution &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<ul>
<li>
<code>T</code> must be numeric type (compatible to double) </li>
<li>
<code>Array1 a1;</code><br/>
 <code>a1.push_back(<a class="el" href="classvigra_1_1ArrayVector.html">ArrayVector</a>&lt;int&gt;());</code> </li>
<li>
<code>Array2 a2;</code><br/>
 <code>a2.push_back(<a class="el" href="classvigra_1_1linalg_1_1Matrix.html">Matrix</a>&lt;T&gt;());</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga73b680f4375cd2963543db1a7cf85e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::linalg::nonnegativeLeastSquares </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-negative Least Squares Regression.</p>
<p>Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), and a column vector <em>b</em> of length <code>m</code> rows, this function computes a column vector <em>x</em> of length <code>n</code> with <b>non-negative entries</b> that solves the optimization problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf x} = \textrm{argmin} \left|\left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|\right|_2^2 \textrm{ subject to } \textrm{\bf x} \ge \textrm{\bf 0} \]" src="form_81.png"/>
</p>
<p>Both <em>b</em> and <em>x</em> must be column vectors (i.e. matrices with <code>1</code> column). Note that all matrices must already have the correct shape. The solution is computed by means of <a class="el" href="group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression()</a> with non-negativity constraint.</p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt; Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gaca08304f34fff2a829234d2c374f4252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::nonlinearLeastSquares </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a non-linear model to given data by minimizing least squares loss. </p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// variant 1: optimize a univariate model (&#39;x&#39; is a 1D array of scalar data points)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>S1, <span class="keyword">class </span>S2, </div>
<div class="line">              <span class="keyword">class </span>U, <span class="keywordtype">int</span> N, </div>
<div class="line">              <span class="keyword">class </span>Functor&gt;</div>
<div class="line">    T</div>
<div class="line">    <a class="code" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares</a>(MultiArrayView&lt;1, T, S1&gt; <span class="keyword">const</span> &amp; x,</div>
<div class="line">                          MultiArrayView&lt;1, T, S2&gt; <span class="keyword">const</span> &amp; y,</div>
<div class="line">                          TinyVector&lt;U, N&gt; &amp; model_parameters, </div>
<div class="line">                          Functor model,</div>
<div class="line">                          NonlinearLSQOptions <span class="keyword">const</span> &amp; options = NonlinearLSQOptions());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// variant 2: optimize a multivariate model (&#39;x&#39; is a 2D array of vector-valued data points)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>S1, <span class="keyword">class </span>S2, </div>
<div class="line">              <span class="keyword">class </span>U, <span class="keywordtype">int</span> N, </div>
<div class="line">              <span class="keyword">class </span>Functor&gt;</div>
<div class="line">    T</div>
<div class="line">    <a class="code" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares</a>(MultiArrayView&lt;2, T, S1&gt; <span class="keyword">const</span> &amp; x,</div>
<div class="line">                          MultiArrayView&lt;1, T, S2&gt; <span class="keyword">const</span> &amp; y,</div>
<div class="line">                          TinyVector&lt;U, N&gt; &amp; model_parameters, </div>
<div class="line">                          Functor model,</div>
<div class="line">                          NonlinearLSQOptions <span class="keyword">const</span> &amp; options = NonlinearLSQOptions());</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function implements the <a href="http://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm">Levenberg-Marquardt algorithm</a> to fit a non-linear model to given data. The model depends on a vector of parameters <b>p</b> which are to be choosen such that the least-squares residual between the data and the model's predictions is minimized according to the objective function:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde \textrm{\bf p} = \textrm{argmin}_{\textrm{\bf p}} \sum_i \left( y_i - f(\textrm{\bf x}_i; \textrm{\bf p}) \right)^2 \]" src="form_135.png"/>
</p>
<p>where <img class="formulaInl" alt="$f(\textrm{\bf x}; \textrm{\bf p})$" src="form_136.png"/> is the model to be optimized (with arguments <img class="formulaInl" alt="$\textrm{\bf x}$" src="form_142.png"/> and parameters <img class="formulaInl" alt="$\textrm{\bf p}$" src="form_143.png"/>), and <img class="formulaInl" alt="$(\textrm{\bf x}_i; y_i)$" src="form_137.png"/> are the feature/response pairs of the given data. Since the model is non-linear (otherwise, you should use ordinary <a class="el" href="group__Optimization.html#gab3be347f5631d0aa2ee74c07479e0383">leastSquares()</a>), it must be linearized in terms of a first-order Taylor expansion, and the optimal parameters <b>p</b> have to be determined iteratively. In order for the iterations to converge to the desired solution, a good initial guess on <b>p</b> is required.</p>
<p>The model must be specified by a functor which takes one of the following forms: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> DataType;   <span class="comment">// type of your data samples, may be any numeric type</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> N = ...;  <span class="comment">// number of model parameters</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// variant 1: the features x are scalars</span></div>
<div class="line"><span class="keyword">struct </span>UnivariateModel </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    T operator()(DataType x, TinyVector&lt;T, N&gt; <span class="keyword">const</span> &amp; p)<span class="keyword"> const </span>{ ... }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// variant 2: the features x are vectors</span></div>
<div class="line"><span class="keyword">struct </span>MultivariateModel</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    T operator()(MultiArrayView&lt;1, DataType&gt; <span class="keyword">const</span> &amp; x, TinyVector&lt;T, N&gt; <span class="keyword">const</span> &amp; p)<span class="keyword"> const </span>{ ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Each call to the functor's <code>operator()</code> computes the model's prediction for a single data point. The current model parameters are specified in a <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a> of appropriate length. The type <code>T</code> must be templated: normally, it is the same as <code>DataType</code>, but the <a class="el" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares()</a> function will temporarily replace it with a special number type that supports <a href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> (see <a class="el" href="classvigra_1_1autodiff_1_1DualVector.html">vigra::autodiff::DualVector</a>). In this way, the derivatives needed in the model's Taylor expansion can be computed automatically.</p>
<p>When the model is univariate (has a single scalar argument), the samples must be passed to <a class="el" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares()</a> in a pair 'x', 'y' of 1D <code><a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a></code>s (variant 1). When the model is multivariate (has a vector-valued argument), the 'x' input must be a 2D <code><a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a></code> (variant 2) whose rows represent a single data sample (i.e. the number of columns corresponds to the length of the model's argument vector). The number of rows in 'x' defines the number of data samples and must match the length of array 'y'.</p>
<p>The <code><a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a></code> 'model_parameters' holds the initial guess for the model parameters and will be overwritten by the optimal values found by the algorithm. The algorithm's internal behavior can be controlled by customizing the option object <a class="el" href="classvigra_1_1NonlinearLSQOptions.html">vigra::NonlinearLSQOptions</a>.</p>
<p>The function returns the residual sum of squared errors of the final solution.</p>
<p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="regression_8hxx_source.html">vigra/regression.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<p>Suppose that we want to fit a centered <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function of the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x ; a, s, b) = a \exp\left(-\frac{x^2}{2 s^2}\right) + b \]" src="form_138.png"/>
</p>
<p> to noisy data <img class="formulaInl" alt="$(x_i, y_i)$" src="form_139.png"/>, i.e. we want to find parameters a, s, b such that the residual <img class="formulaInl" alt="$\sum_i \left(y_i - f(x_i; a,s,b)\right)^2$" src="form_141.png"/> is minimized. The model parameters are placed in a <code>TinyVector&lt;T, 3&gt;</code> <b>p</b> according to the rules<br/>
 <code>p[0] &lt;=&gt; a</code>, <code>p[1] &lt;=&gt; s</code> and <code>p[2] &lt;=&gt; b</code>.<br/>
 The following functor computes the model's prediction for a single data point <code>x</code>: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>GaussianModel</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    T operator()(<span class="keywordtype">double</span> x, TinyVector&lt;T, 3&gt; <span class="keyword">const</span> &amp; p)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> p[0] * <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5 * <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(x / p[1])) + p[2];</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Now we can find optimal values for the parameters like this: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> size = ...;  <span class="comment">// number of data points</span></div>
<div class="line">MultiArray&lt;1, double&gt; x(size), y(size);    </div>
<div class="line">...   <span class="comment">// fill the data arrays</span></div>
<div class="line"></div>
<div class="line">TinyVector&lt;double, 3&gt; p(2.0, 1.0, 0.5);  <span class="comment">// your initial guess of the parameters</span></div>
<div class="line">                                         <span class="comment">// (will be overwritten with the optimal values)</span></div>
<div class="line"><span class="keywordtype">double</span> residual = <a class="code" href="group__Optimization.html#gaca08304f34fff2a829234d2c374f4252" title="Fit a non-linear model to given data by minimizing least squares loss.">nonlinearLeastSquares</a>(x, y, p, GaussianModel());</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Model parameters: a=&quot;</span> &lt;&lt; p[0] &lt;&lt; <span class="stringliteral">&quot;, s=&quot;</span> &lt;&lt; p[1] &lt;&lt; <span class="stringliteral">&quot;, b=&quot;</span> &lt;&lt; p[2] &lt;&lt; <span class="stringliteral">&quot; (residual: &quot;</span> &lt;&lt; residual &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>
</BODY>
</HTML>
