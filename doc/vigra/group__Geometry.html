<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Geometry</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.4 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Geometry
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Polygon.html">Polygon&lt; POINT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf0c2950994b2b4492b25953429e465c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaf0c2950994b2b4492b25953429e465c7">arcLengthQuantile</a> (double quantile) const </td></tr>
<tr class="separator:gaf0c2950994b2b4492b25953429e465c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c88f59fb7d18a293dbc5e6cbebd744"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24c88f59fb7d18a293dbc5e6cbebd744"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga24c88f59fb7d18a293dbc5e6cbebd744">closed</a> () const </td></tr>
<tr class="memdesc:ga24c88f59fb7d18a293dbc5e6cbebd744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the last and first points are equal or the polygon is empty. <br/></td></tr>
<tr class="separator:ga24c88f59fb7d18a293dbc5e6cbebd744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30425bc1089d9161fe7f6939b1057b33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga30425bc1089d9161fe7f6939b1057b33">contains</a> (const_reference point, coordinate_type tolerance) const </td></tr>
<tr class="separator:ga30425bc1089d9161fe7f6939b1057b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba489a131e75016f32095b106659d22"><td class="memTemplParams" colspan="2">template&lt;class PointArray1 , class PointArray2 &gt; </td></tr>
<tr class="memitem:ga8ba489a131e75016f32095b106659d22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga8ba489a131e75016f32095b106659d22">convexHull</a> (const PointArray1 &amp;points, PointArray2 &amp;convex_hull)</td></tr>
<tr class="memdesc:ga8ba489a131e75016f32095b106659d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull of a 2D polygon.  <a href="#ga8ba489a131e75016f32095b106659d22">More...</a><br/></td></tr>
<tr class="separator:ga8ba489a131e75016f32095b106659d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd3555b88c17d3243c2e33f16fd6ccb"><td class="memTemplParams" colspan="2">template&lt;class T , class S , class PointArray &gt; </td></tr>
<tr class="memitem:ga6bd3555b88c17d3243c2e33f16fd6ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga6bd3555b88c17d3243c2e33f16fd6ccb">extractContour</a> (MultiArrayView&lt; 2, T, S &gt; const &amp;label_image, Shape2 const &amp;anchor_point, PointArray &amp;contour_points)</td></tr>
<tr class="memdesc:ga6bd3555b88c17d3243c2e33f16fd6ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a polygon from the interpixel contour of a labeled region.  <a href="#ga6bd3555b88c17d3243c2e33f16fd6ccb">More...</a><br/></td></tr>
<tr class="separator:ga6bd3555b88c17d3243c2e33f16fd6ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69224e928001af45256b27778f4232c"><td class="memTemplParams" colspan="2">template&lt;class Point , class T , class S , class Value &gt; </td></tr>
<tr class="memitem:gad69224e928001af45256b27778f4232c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gad69224e928001af45256b27778f4232c">fillPolygon</a> (Polygon&lt; Point &gt; const &amp;p, MultiArrayView&lt; 2, T, S &gt; &amp;output_image, Value value)</td></tr>
<tr class="memdesc:gad69224e928001af45256b27778f4232c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render closed polygon <em>p</em> into the image <em>output_image</em>.  <a href="#gad69224e928001af45256b27778f4232c">More...</a><br/></td></tr>
<tr class="separator:gad69224e928001af45256b27778f4232c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga580f217e65860ef3b2c8bfdad0e22869"><td class="memItemLeft" align="right" valign="top">Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga580f217e65860ef3b2c8bfdad0e22869">interpolate</a> (unsigned int index, double offset) const </td></tr>
<tr class="separator:ga580f217e65860ef3b2c8bfdad0e22869"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga580f217e65860ef3b2c8bfdad0e22869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point interpolate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Linearly interpolate at <code>offset</code> between knots <code>index</code> and <code>index+1</code>.</p>
<p>Preconditions: <code>0 &lt;= index &lt; <a class="el" href="classvigra_1_1ArrayVectorView.html#a503ab01f6c0142145d3434f6924714e7">size()</a>-1</code> and <code>0 &lt;= offset &lt;= 1</code>. </p>

</div>
</div>
<a class="anchor" id="ga30425bc1089d9161fe7f6939b1057b33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_type&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether the given point lies within this polygon. Requires that this polygon is closed.</p>
<p>Points which lie directly on the polylines or coincide with a knot are considered inside (this behavior is consistent with <a class="el" href="group__Geometry.html#gad69224e928001af45256b27778f4232c" title="Render closed polygon p into the image output_image. ">fillPolygon()</a>). Parameter <em>tolerance</em> (interpreted as an absolute error bound) controls the numerical accuracy of this test. </p>

</div>
</div>
<a class="anchor" id="gaf0c2950994b2b4492b25953429e465c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double arcLengthQuantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantile</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the point on the polygon that corresponds to the given quantile.</p>
<p><em>quantile</em> must be in <code>[0.0, 1.0]</code>. The result of this function can be used as input to <code><a class="el" href="group__Geometry.html#ga580f217e65860ef3b2c8bfdad0e22869">interpolate()</a></code>. For example, the following code computes the point in the middle of the polygon:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> c = poly.arcLengthQuantile(0.5);</div>
<div class="line">Point center = poly.interpolate((<span class="keywordtype">int</span>)<a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down. ">floor</a>(c), c - <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down. ">floor</a>(c));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6bd3555b88c17d3243c2e33f16fd6ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::extractContour </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, S &gt; const &amp;&#160;</td>
          <td class="paramname"><em>label_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape2 const &amp;&#160;</td>
          <td class="paramname"><em>anchor_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointArray &amp;&#160;</td>
          <td class="paramname"><em>contour_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a polygon from the interpixel contour of a labeled region. </p>
<p>The point <em>anchor_point</em> must be in the region whose contour we want to extract, and must be adjacent to the contour. The algorithm uses the 'left hand on the wall' algorithm to trace the connected component whose label equals the label of the <em>anchor_point</em>. The contour is returned in <em>countour_points</em> as a closed polygon that circles the region counter-clockwise in the image coordinate system (i.e. the coordinate system where x points to the right and y points downwards). Since the resulting polygon represents the interpixel contour, all points will have one integer and one half-integer coordinate. </p>

</div>
</div>
<a class="anchor" id="ga8ba489a131e75016f32095b106659d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convexHull </td>
          <td>(</td>
          <td class="paramtype">const PointArray1 &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointArray2 &amp;&#160;</td>
          <td class="paramname"><em>convex_hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute convex hull of a 2D polygon. </p>
<p>The input array <em>points</em> contains a (not necessarily ordered) set of 2D points whose convex hull is to be computed. The array's <code>value_type</code> (i.e. the point type) must be compatible with std::vector (in particular, it must support indexing, copying, and have <code>size() == 2</code>). The points of the convex hull will be appended to the output array <em>convex_hull</em> (which must support <code>std::back_inserter(convex_hull)</code>). Since the convex hull is a closed polygon, the first and last point of the output will be the same (i.e. the first point will simply be inserted at the end again). The points of the convex hull will be ordered counter-clockwise, starting with the leftmost point of the input. The function implements Andrew's Monotone Chain algorithm. </p>

</div>
</div>
<a class="anchor" id="gad69224e928001af45256b27778f4232c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::fillPolygon </td>
          <td>(</td>
          <td class="paramtype">Polygon&lt; Point &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render closed polygon <em>p</em> into the image <em>output_image</em>. </p>
<p>All pixels on the polygon's contour and in its interior are set to the given <em>value</em>. Parts of the polygon outside the image region are clipped. The function uses a robust X-intersection array algorithm that is able to handle all corner cases (concave and self-intersecting polygons, knots on integer coordinates). </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Thu Jan 8 2015)
</i>
</tr>
</table>
</BODY>
</HTML>
