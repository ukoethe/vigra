/** \page ParallelProcessingTutorial Parallel Processing Tutorial

    <h2>Section Contents</h2>
    
    In this chapter some of VIGRA's parallel processing capabilities for applications in Image Processing are presented.

    <ul style="list-style-image:url(documents/bullet.gif)">
    <li> \ref ParallelFiltering
        <ul type="disc">
            <li> \ref Gaussian
            </ul>
    <li> \ref AgglomarativeClustering

    
    \section ParallelFiltering Parallel Filtering
    
    Many filters in VIGRA can be processed parallely by passing the BlockwiseConvolutionOptions. 
    
    \subsection Gaussian Parallel Gaussian Smoothing
    
    
    Here is an example:
    (Usage: smooth_blockwise.exe infile outfile)
    <a href="smooth_blockwise-example.html">smooth_blockwise.cxx</a>
    
    Here are the crucial parts of the example code:
    
    \code
    #include <vigra/multi_array.hxx>
    #include <vigra/impex.hxx>
    #include <vigra/convolution.hxx>
    #include <vigra/multi_blockwise.hxx>
    #include <iostream>

    using namespace vigra;

    int main (int argc, char ** argv) 
    {
        if(argc != 3) 
        {
            std::cout << "Usage: " << argv[0] << " infile outfile" << std::endl;
            std::cout << "(supported formats: " << impexListFormats() << ")" << std::endl;
            
            return 1;
        }
        try
        {
            // read image given as first argument
            ImageImportInfo info(argv[1]);
            
            // instantiate arrays for image data and for smoothed image of appropriate size
            if (info.isGrayscale()) 
            {
                MultiArray<2, float> imageArray(info.shape()),
                                                exportArray(info.shape());

                // copy image data into array
                importImage(info, imageArray);
                
                BlockwiseConvolutionOptions<2> opt = BlockwiseConvolutionOptions<2>();
                
                gaussianSmoothMultiArray(imageArray, exportArray, 
                                         BlockwiseConvolutionOptions<2>().stdDev(2.0));
                
                // write image data to the file given as second argument
                exportImage(exportArray, ImageExportInfo(argv[2]));
                
            }
            else
            {
                MultiArray<2, RGBValue<float> > imageArray(info.shape()),
                                                exportArray(info.shape());
            
                // copy image data into array
                importImage(info, imageArray);
                
                BlockwiseConvolutionOptions<2> opt = BlockwiseConvolutionOptions<2>();
                
                gaussianSmoothMultiArray(imageArray, exportArray, 
                                         BlockwiseConvolutionOptions<2>().stdDev(2.0));
                
                // write image data to the file given as second argument
                exportImage(exportArray, ImageExportInfo(argv[2]));
            }
            
            
        }
        catch (std::exception & e) 
        {
            // catch any errors that might have occurred and print their reason
            std::cout << e.what() << std::endl;
            return 1;
        }
        return 0;
    }
    \endcode
    
*/

/** \example smooth_blockwise.cxx
    Smooth an image using gaussianSmoothMultiArray(..., BlockwiseConvolutionOptions).
    <br>
    Usage: <TT>smooth_blockwise infile outfile</TT>
*/

